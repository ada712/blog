(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{428:function(t,s,a){t.exports=a.p+"assets/img/p1.65467969.png"},429:function(t,s,a){t.exports=a.p+"assets/img/p2.33a30e7d.png"},430:function(t,s,a){t.exports=a.p+"assets/img/p4.70c623ce.png"},431:function(t,s,a){t.exports=a.p+"assets/img/p5.706d195d.jpg"},507:function(t,s,a){"use strict";a.r(s);var e=a(2),n=Object(e.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"vue3-没有采用-fiber-依然很快-为什么"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#vue3-没有采用-fiber-依然很快-为什么"}},[t._v("#")]),t._v(" Vue3 没有采用 Fiber 依然很快，为什么")]),t._v(" "),s("p",[t._v("vue3 重新审视了 vdom，更改了自身对于 vdom 的对比算法。vdom 从之前的每次更新，\n都进行一次完 整遍历对比，改为了切分区块树，来进行动态内容更新。也就是只更新\nvdom 的绑定了动态数据的部分，把速度提高了 6 倍;")]),t._v(" "),s("h2",{attrs:{id:"mvvm-原理的理解"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#mvvm-原理的理解"}},[t._v("#")]),t._v(" MVVM 原理的理解")]),t._v(" "),s("p",[s("img",{attrs:{src:a(428),alt:"xx"}})]),t._v(" "),s("ul",[s("li",[t._v("传统的 MVC 指的是，用户操作会请求服务端路由，路由会调用对应的控制器来处理,控制器会获取数据。将结果返回给前端,⻚面重新渲染。")]),t._v(" "),s("li",[t._v("MVVM :传统的前端会将数据手动渲染到⻚面上，MVVM 模式不需要用户收到操作 dom 元素， "),s("strong",[t._v("数据驱动视图")]),t._v("即将数据绑定到 viewModel 层上，会自动将数据渲染到⻚面中，视图变化会通知 viewModel 层更新数据。 ViewModel 就是我们 MVVM 模式中的桥梁。")])]),t._v(" "),s("h2",{attrs:{id:"vue2-0-的双向数据绑定原理是什么"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#vue2-0-的双向数据绑定原理是什么"}},[t._v("#")]),t._v(" Vue2.0 的双向数据绑定原理是什么")]),t._v(" "),s("p",[t._v("vue.js 是采用"),s("strong",[t._v("数据劫持")]),t._v("结合"),s("strong",[t._v("发布者-订阅者模式")]),t._v("的方式，通过"),s("code",[t._v("Object.defineProperty()")]),t._v("来劫持各个属性的 setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。\n"),s("img",{attrs:{src:a(429),alt:"xx"}})]),t._v(" "),s("h2",{attrs:{id:"defineproperty-的缺点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#defineproperty-的缺点"}},[t._v("#")]),t._v(" defineProperty 的缺点")]),t._v(" "),s("ul",[s("li",[t._v("在 Vue 中，Object.defineProperty 无法监控到数组下标的变化，导致直接通过数组的下标给数组设置值，不能实时响应。")]),t._v(" "),s("li",[t._v("Object.defineProperty 只能劫持对象的属性,因此我们需要对每个对象的每个属性进行遍历。")])]),t._v(" "),s("h2",{attrs:{id:"proxy"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#proxy"}},[t._v("#")]),t._v(" Proxy")]),t._v(" "),s("ul",[s("li",[t._v("可以监听数组变化")]),t._v(" "),s("li",[t._v("性能更加的好，降低对象复杂度等。")])]),t._v(" "),s("h2",{attrs:{id:"vue-的渲染过程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#vue-的渲染过程"}},[t._v("#")]),t._v(" Vue 的渲染过程")]),t._v(" "),s("ol",[s("li",[t._v("调用 compile 函数,生成 render 函数字符串 ,编译过程如下:")])]),t._v(" "),s("ul",[s("li",[t._v("parse 函数解析 template,生成 ast(抽象语法树)")]),t._v(" "),s("li",[t._v("optimize 函数优化静态节点 (标记不需要每次都更新的内容,diff 算法会直接跳过静态节点,从 而减少比较的过程,优化了 patch 的性能)")]),t._v(" "),s("li",[t._v("generate 函数生成 render 函数字符串")])]),t._v(" "),s("ol",{attrs:{start:"2"}},[s("li",[s("p",[t._v("调用 new Watcher 函数,监听数据的变化,当数据发生变化时，重新执行 vm._update()方法")])]),t._v(" "),s("li",[s("p",[t._v("update 方法会调用 patch 方法,对比新旧 vnode 对象,通过 DOM diff 算法,添加、修改、删除真正\n的 DOM 元素。")]),t._v(" "),s("h2",{attrs:{id:"生命周期"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#生命周期"}},[t._v("#")]),t._v(" 生命周期")])])]),t._v(" "),s("h2",{attrs:{id:"nexttick-实现"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#nexttick-实现"}},[t._v("#")]),t._v(" nextTick 实现")]),t._v(" "),s("p",[t._v("Vue 在内部对异步队列尝试使用原生的 Promise.then、MutationObserver 和 setImmediate，如果执\n行环境不支持，则会采用 setTimeout(fn, 0) 代替。 源码里 render Watcher 异步更新队列也是通过 nextTick 实现。\n"),s("img",{attrs:{src:a(430),alt:"xx"}}),t._v("\n仔细跟踪了代码执行过程我们会发现，真正的去遍历 watcher，批处理更新是在 "),s("strong",[t._v("microtask(微任务)")]),t._v(" 中执行的，而 且用户在修改数据后自己执行的 nextTick(cb)也会在此时执行 cb，他们都是在同一个 **microtask (微任务)**中执行。")]),t._v(" "),s("h2",{attrs:{id:"vue-是如何对数组方法进行变异的"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#vue-是如何对数组方法进行变异的"}},[t._v("#")]),t._v(" vue 是如何对数组方法进行变异的 ?")]),t._v(" "),s("p",[t._v("Vue 通过原型拦截的方式重写了数组的 7 个方法，这样当调用数组 api 时，可以通知依赖更新。\n如果数组中包含着引用类型，会对数组中的引用类型再次进行监控。")]),t._v(" "),s("h3",{attrs:{id:"原理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#原理"}},[t._v("#")]),t._v(" 原理")]),t._v(" "),s("p",[t._v("首先获取到这个数组的 Observer 对象，如果是插入新的值，就调用 observeArray 对新的值进行监 听，然后手动调用 notify，通知 render watcher，执行 update。")]),t._v(" "),s("h2",{attrs:{id:"vue-diff-算法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#vue-diff-算法"}},[t._v("#")]),t._v(" vue Diff 算法")]),t._v(" "),s("ul",[s("li",[t._v("diff 算法比较新旧节点的时候，比较只会在同层级进行, 不会跨层级比较")]),t._v(" "),s("li",[t._v("vue 的 diff 算法会有一个猜测优化，vue 认为一个列表一般只有往头部添加、删除、或者往尾部添加 删除元素，所以 vue 的 diff 算法会把 oldCh 和 newCh 各有两个头尾的变量 StartIdx 和 EndIdx，它们的 2 个变量相互比较，一共有 4 种比较方式。")])]),t._v(" "),s("h2",{attrs:{id:"理解"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#理解"}},[t._v("#")]),t._v(" 理解")]),t._v(" "),s("ul",[s("li",[t._v("先同级比较，在比较子节点。")]),t._v(" "),s("li",[t._v("先判断一方有儿子一方没儿子的情况。")]),t._v(" "),s("li",[t._v("比较都有儿子的情况。")]),t._v(" "),s("li",[t._v("递归比较子节点。")]),t._v(" "),s("li",[t._v("利用了双指针的方式。")])]),t._v(" "),s("p",[s("img",{attrs:{src:a(431),alt:"xx"}})]),t._v(" "),s("h2",{attrs:{id:"流程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#流程"}},[t._v("#")]),t._v(" 流程")]),t._v(" "),s("h3",{attrs:{id:"_1-patch-函数接收两个参数-oldvnode-和-vnode-分别代表新的节点和之前的旧节点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-patch-函数接收两个参数-oldvnode-和-vnode-分别代表新的节点和之前的旧节点"}},[t._v("#")]),t._v(" 1. patch 函数接收两个参数 oldVnode 和 Vnode 分别代表新的节点和之前的旧节点")]),t._v(" "),s("ul",[s("li",[t._v("1.首先会判断是否为相同节点，如果两个节点都是一样的，那么就深入检查他们的子节点。否 则就不作比较直接采用新的 Vnode。")]),t._v(" "),s("li",[t._v("2.深入检查执行 patchVnode。就是所谓的打补丁。")])]),t._v(" "),s("h3",{attrs:{id:"_2-patchvnode-方法会做以下几件事"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-patchvnode-方法会做以下几件事"}},[t._v("#")]),t._v(" 2. patchVnode 方法会做以下几件事")]),t._v(" "),s("ul",[s("li",[s("ol",[s("li",[t._v("判断 Vnode 和 oldVnode 是否指向同一个对象，如果是，那么直接 return")])])]),t._v(" "),s("li",[s("ol",{attrs:{start:"2"}},[s("li",[t._v("如果他们都有文本节点并且不相等，那么将 el 的文本节点设置为 Vnode 的文本节点")])])]),t._v(" "),s("li",[s("ol",{attrs:{start:"3"}},[s("li",[t._v("如果 oldVnode 有子节点而 Vnode 没有，则删除 el 的子节点")])])]),t._v(" "),s("li",[s("ol",{attrs:{start:"4"}},[s("li",[t._v("如果 oldVnode 没有子节点而 Vnode 有，则将 Vnode 的子节点真实化之后添加到 el")])])]),t._v(" "),s("li",[s("ol",{attrs:{start:"5"}},[s("li",[t._v("如果两者都有子节点，则执行 updateChildren 函数比较子节点，这一步很重要(精髓)")])])])]),t._v(" "),s("h3",{attrs:{id:"_3-updatechildren-分别对-olds、olde、s、e-两两做-samevnode-比较-有四种比较方式-当其中-两个能匹配上那么真实-dom-中的相应节点会移到-vnode-相应的位置-在比较的过程中-变量会往-中间靠-一旦-startidx-endidx-表明-oldch-和-newch-至少有一个已经遍历完了-就会结束比-较。匹配过程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-updatechildren-分别对-olds、olde、s、e-两两做-samevnode-比较-有四种比较方式-当其中-两个能匹配上那么真实-dom-中的相应节点会移到-vnode-相应的位置-在比较的过程中-变量会往-中间靠-一旦-startidx-endidx-表明-oldch-和-newch-至少有一个已经遍历完了-就会结束比-较。匹配过程"}},[t._v("#")]),t._v(" 3. updateChildren 分别对 oldS、oldE、S、E 两两做 sameVnode 比较，有四种比较方式，当其中 两个能匹配上那么真实 dom 中的相应节点会移到 Vnode 相应的位置;在比较的过程中，变量会往 中间靠，一旦 StartIdx>EndIdx 表明 oldCh 和 newCh 至少有一个已经遍历完了，就会结束比 较。匹配过程")]),t._v(" "),s("ul",[s("li",[s("ol",[s("li",[t._v("如果 sameVnode(oldStartVnode, newStartVnode)或者 sameVnode(oldEndVnode, newEndVnode)，直接将该 VNode 节点进行 patchVnode 即可。")])])]),t._v(" "),s("li",[s("ol",{attrs:{start:"2"}},[s("li",[t._v("如果 sameVnode(oldStartVnode, newEndVnode)，这说明 oldStartVnode 已经跑到了 oldEndVnode 后面去了，进行 patchVnode 的同时还需要将真实 DOM 节点移动到 oldEndVnode 的后面。")])])]),t._v(" "),s("li",[s("ol",{attrs:{start:"3"}},[s("li",[t._v("如果 sameVnode(oldEndVnode, newStartVnode)，这说明 oldEndVnode 跑到了 oldStartVnode 的前面，进行 patchVnode 的同时真实的 DOM 节点移动到了 oldStartVnode 的 前面。")])])]),t._v(" "),s("li",[s("ol",{attrs:{start:"4"}},[s("li",[t._v("如果以上情况均不符合，分为两种情况\n**\n(1). 如果新旧子节点都存在 key，那么会根据 oldChild 的 key 生成一张 hash 表，\n用 newStartVnode 的 key 与 hash 表做匹配，匹配成功就判断 newStartVnode 和匹配 节点是否为 sameNode ，如果是，就将这个真实 DOM 移动到 oldStartVnode 对应的真 实 DOM 的前面，否则将 newStartVnode 生成对应的节点插入到 oldStartVnode 对应 的真实 DOM 的前面，最后 newStartVnode 指针向中间移动\n(2). 如果没有 key,则直接将 S 生成新的节点插入真实 DOM。**")])])]),t._v(" "),s("li",[s("ol",{attrs:{start:"5"}},[s("li",[t._v("全部比较完成以后，发现 oldStartIdx > oldEndIdx 的话，说明老节点已经遍历完了，新节点比老节点多，所以这时候多出来的新节点需要一个一个创建出来加入到真实 DOM 中")])])]),t._v(" "),s("li",[s("ol",{attrs:{start:"6"}},[s("li",[t._v("如果全部比较完成以后发现 newStartIdx > newEndIdx，则说明新节点已经遍历完了，老节点多余新节点，这个时候需要将多余的老节点从真实 DOM 中移除\n"),s("a",{attrs:{href:"https://github.com/answershuto/learnVue/blob/master/docs/VirtualDOM%E4%B8%8Ediff(Vue%E5%AE%9E%E7%8E%B0).MarkDown",target:"_blank",rel:"noopener noreferrer"}},[t._v("diff"),s("OutboundLink")],1),t._v("\n简述:")])])]),t._v(" "),s("li",[s("ol",[s("li",[t._v("头头比较、尾尾比较、头尾、尾头")])])]),t._v(" "),s("li",[s("ol",{attrs:{start:"2"}},[s("li",[t._v("根据新节点，生成一个 key => index 的映射表")])])]),t._v(" "),s("li",[s("ol",{attrs:{start:"3"}},[s("li",[t._v("如果两个的 key 一样，比较属性、和移动")])])]),t._v(" "),s("li",[s("ol",{attrs:{start:"4"}},[s("li",[t._v("去老的节点找有没对应的，如果有一样的就复用")])])]),t._v(" "),s("li",[s("ol",{attrs:{start:"5"}},[s("li",[t._v("如果新的比老的多，那就添加，老的比新的多，那就删除")])])])]),t._v(" "),s("h2",{attrs:{id:"描述组件渲染和更新过程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#描述组件渲染和更新过程"}},[t._v("#")]),t._v(" 描述组件渲染和更新过程")]),t._v(" "),s("p",[t._v("渲染组件时，会通过 Vue.extend 方法构建子组件的构造函数，并进行实例化。最终手动调用 $mount() 进行挂载。更新组件时会进行 patchVnode 流程。核心就是 diff 算法。")]),t._v(" "),s("h2",{attrs:{id:"组件中的-data-为什么是一个函数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#组件中的-data-为什么是一个函数"}},[t._v("#")]),t._v(" 组件中的 data 为什么是一个函数?")]),t._v(" "),s("p",[t._v("同一个组件被复用多次时，会创建多个实例。但是这些实例用的是同一个构造函数，如果 data 是一个 对象的话。那么所有组件都共享了同一个对象。为了保证组件的数据独立性要求每个组件必须通过 data 函数 返回一个对象作为组件的状态。")]),t._v(" "),s("h2",{attrs:{id:"v-model-中的实现原理及如何自定义-v-model"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#v-model-中的实现原理及如何自定义-v-model"}},[t._v("#")]),t._v(" v-model 中的实现原理及如何自定义 v-model")]),t._v(" "),s("p",[t._v("v-model 可以看成是 value + input 方法 的语法糖\n组件的 v-model 就是 value + input 的语法糖")]),t._v(" "),s("div",{staticClass:"language-js line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[t._v("\nVue"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("component")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'el-checkbox'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("template")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),s("span",{pre:!0,attrs:{class:"token template-string"}},[s("span",{pre:!0,attrs:{class:"token template-punctuation string"}},[t._v("`")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('<input type="checkbox" :checked="check"\n@change="$emit(\'change\',$event.target.checked)">')]),s("span",{pre:!0,attrs:{class:"token template-punctuation string"}},[t._v("`")])]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("model")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("prop")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'check'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 更改默认的value的名字")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("event")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'change'")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 更改默认的方法名 } }")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("props")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("check")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" Boolean "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br")])]),s("h2",{attrs:{id:"keep-alive-的实现原理和缓存策略"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#keep-alive-的实现原理和缓存策略"}},[t._v("#")]),t._v(" keep-alive 的实现原理和缓存策略")]),t._v(" "),s("p",[s("strong",[t._v("实现原理")])]),t._v(" "),s("ul",[s("li",[t._v("获取 keep-alive 包裹着的第一个子组件对象及其组件名。")]),t._v(" "),s("li",[t._v("根据设定的 include/exclude(如果有)进行条件匹配,决定是否缓存。不匹配,直接返回组件实例。")]),t._v(" "),s("li",[t._v("根据组件 name ID 和 tag 生成缓存 Key,并在缓存对象中查找是否已缓存过该组件实例。\n如果存在, 直接取出缓存值并更新该 key 在 this.keys 中的位置(更新 key 的位置是实现 LRU 置换策略的关 键)。")]),t._v(" "),s("li",[t._v("在 this.cache 对象中存储该组件实例并保存 key 值,之后检查缓存的实例数量是否超过 max 的设置 值,\n超过则根据 LRU 置换策略删除最近最久未使用的实例(即是下标为 0 的那个 key)。")]),t._v(" "),s("li",[t._v("最后组件实例的 keepAlive 属性设置为 true,这个在渲染和执行被包裹组件的钩子函数会用到。")])]),t._v(" "),s("h2",{attrs:{id:"lru-缓存淘汰算法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#lru-缓存淘汰算法"}},[t._v("#")]),t._v(" LRU 缓存淘汰算法")]),t._v(" "),s("p",[t._v("LRU(Least recently used)算法根据数据的历史访问记录来进行淘汰数据,其核心思想是“如果数据最\n近被访问过,那么将来被访问的几率也更高”。既优先淘汰最久没被访问的数据")]),t._v(" "),s("h2",{attrs:{id:"vm-set-实现原理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#vm-set-实现原理"}},[t._v("#")]),t._v(" vm.$set()实现原理")]),t._v(" "),s("ul",[s("li",[t._v("判断目标是数组,使用 vue 实现的变异方法 splice 实现响应式")]),t._v(" "),s("li",[t._v("如果目标是对象,判断属性存在,即为响应式,直接赋值")]),t._v(" "),s("li",[t._v("如果 target 本身就不是响应式,直接赋值")]),t._v(" "),s("li",[t._v("如果属性不是响应式,则调用 defineReactive 方法进行响应式处理")]),t._v(" "),s("li",[t._v("不允许"),s("strong",[t._v("为根数据对象添加属性")])])]),t._v(" "),s("h2",{attrs:{id:"vue-事件机制-on-off-emit-once"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#vue-事件机制-on-off-emit-once"}},[t._v("#")]),t._v(" Vue 事件机制,$on,$off,$emit,$once")]),t._v(" "),s("blockquote",[s("p",[t._v("Vue 事件机制是非常经典的事件中心的实现。")])]),t._v(" "),s("ul",[s("li",[t._v("把所有的事件用 vm._events 存储起来。")]),t._v(" "),s("li",[t._v("当执行 vm.$on(event,fn) 的时候，按事件的名称 event 把回调函数 fn 存储起来\nvm._events[event].push(fn) 。")]),t._v(" "),s("li",[t._v("当执行 vm.$emit(event) 的时候，根据事件名 event 找到所有的回调函数 let cbs = vm._events[event] ，然后遍历执行所有的回调函数。")]),t._v(" "),s("li",[t._v("执行 vm.$off(event,fn) 的时候会移除指定事件名 event 和指定的 fn 。")]),t._v(" "),s("li",[t._v("执行 vm.$once(event,fn) 的时候，内部就是执行 vm.$on ，并且当回调函数执行一次后再通过\nvm.$off 移除事件的回调，这样就确保了回调函数只执行一次。")])]),t._v(" "),s("div",{staticClass:"language-js line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Vue")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("constructor")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 事件通道调度中心")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("_events "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" Object"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("create")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("$on")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("event"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" fn")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("_events"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("event"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("||")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("_events"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("event"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("push")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("fn"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("$once")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("event"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" fn")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("on")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("$off")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("event"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" on"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("fn")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("apply")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" arguments"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 缓存fn，删除时可用到 on.fn = fn this.$on(event, on)")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("$off")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("event"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" fn")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" cbs "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("_events"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("event"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 没有传fn，全部回调删除")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!")]),t._v("fn"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("_events"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("event"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" cb"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" i "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" cbs"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("length"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("while")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("i"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("--")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      cb "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" cbs"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("i"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("cb "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("===")]),t._v(" fn "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("||")]),t._v(" cb"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("fn "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("===")]),t._v(" fn"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        cbs"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("splice")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("i"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("break")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("$emit")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("event")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" cbs "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("_events"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("event"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("cbs"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" args "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("...")]),t._v("arguments"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n      cbs"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("map")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("item")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("item")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("apply")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" args"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br"),s("span",{staticClass:"line-number"},[t._v("10")]),s("br"),s("span",{staticClass:"line-number"},[t._v("11")]),s("br"),s("span",{staticClass:"line-number"},[t._v("12")]),s("br"),s("span",{staticClass:"line-number"},[t._v("13")]),s("br"),s("span",{staticClass:"line-number"},[t._v("14")]),s("br"),s("span",{staticClass:"line-number"},[t._v("15")]),s("br"),s("span",{staticClass:"line-number"},[t._v("16")]),s("br"),s("span",{staticClass:"line-number"},[t._v("17")]),s("br"),s("span",{staticClass:"line-number"},[t._v("18")]),s("br"),s("span",{staticClass:"line-number"},[t._v("19")]),s("br"),s("span",{staticClass:"line-number"},[t._v("20")]),s("br"),s("span",{staticClass:"line-number"},[t._v("21")]),s("br"),s("span",{staticClass:"line-number"},[t._v("22")]),s("br"),s("span",{staticClass:"line-number"},[t._v("23")]),s("br"),s("span",{staticClass:"line-number"},[t._v("24")]),s("br"),s("span",{staticClass:"line-number"},[t._v("25")]),s("br"),s("span",{staticClass:"line-number"},[t._v("26")]),s("br"),s("span",{staticClass:"line-number"},[t._v("27")]),s("br"),s("span",{staticClass:"line-number"},[t._v("28")]),s("br"),s("span",{staticClass:"line-number"},[t._v("29")]),s("br"),s("span",{staticClass:"line-number"},[t._v("30")]),s("br"),s("span",{staticClass:"line-number"},[t._v("31")]),s("br"),s("span",{staticClass:"line-number"},[t._v("32")]),s("br"),s("span",{staticClass:"line-number"},[t._v("33")]),s("br"),s("span",{staticClass:"line-number"},[t._v("34")]),s("br"),s("span",{staticClass:"line-number"},[t._v("35")]),s("br"),s("span",{staticClass:"line-number"},[t._v("36")]),s("br"),s("span",{staticClass:"line-number"},[t._v("37")]),s("br"),s("span",{staticClass:"line-number"},[t._v("38")]),s("br"),s("span",{staticClass:"line-number"},[t._v("39")]),s("br"),s("span",{staticClass:"line-number"},[t._v("40")]),s("br"),s("span",{staticClass:"line-number"},[t._v("41")]),s("br")])]),s("h2",{attrs:{id:"vuex-的实现原理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#vuex-的实现原理"}},[t._v("#")]),t._v(" vuex 的实现原理")]),t._v(" "),s("ul",[s("li",[s("ol",[s("li",[t._v("vuex 在初始化时候会通过 mixins 注入 beforeCreate 钩子去初始化 vuex，通过 parent.$store构建组 件直接关系，让每个组件都能访问到$store。")])])]),t._v(" "),s("li",[s("ol",{attrs:{start:"2"}},[s("li",[t._v("接着 new Store 去构建安装 modules(递归处理)、resetStoreVM、循环 plugins 列表调用。")])])])]),t._v(" "),s("p",[t._v("vuex 内部会自己重新 new Vue，把 state 赋值给 Vue.data.$$state，把getters赋值给Vue.computed， getters的返回值是依赖与state，也就vue.data，所有说vuex里的getters与计算属性一样，有缓存效 果。\n我们获取state时本质会返回data.$$state(因为 Srore 类里劫持了 get state)，所以我们获取的就是响应式 的数据\nvuex 修改 state 会统一通过 withCommit 方法去修改，该方法调用会设置 committing 的为 true，会认为这 是一个合法的修改，当我们不通过 commit 去触发_withCommit 修改，vuex 都会发出警告，但是不会影 响值的修改。\n当我们设置了 strict 时，vuex 会 watch state 的变化，通过判断_withCommit 的值来给我们发出警告")]),t._v(" "),s("h2",{attrs:{id:"vue-router-怎么实现路由切换"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#vue-router-怎么实现路由切换"}},[t._v("#")]),t._v(" vue-router 怎么实现路由切换")]),t._v(" "),s("div",{staticClass:"language-js line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1.")]),t._v(" vue"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("use")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("vueRouter"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("时会mixins注入beforeCreate去初始化router\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2.")]),t._v(" 接着会把根Vue实例的_route 属性定义成响应式的。\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("3.")]),t._v(" 在每个 "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("**")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("router"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("view"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("**")]),t._v("执行 render 函数的时候，都会访问 parent"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("$route")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("本质就是访问\n_route "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("，触发getter。把 "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("**")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("router"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("view"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("**")]),t._v(" 收集为依赖。\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("4.")]),t._v(" 内容监听hashChange和html history改变，去触发transitionTo，调用history"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("pushState等去修\n改地址\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("5.")]),t._v(" 当跳转时候会触发transitionTo方法，会修改app"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("_route，触发setter，因此会通知"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("**")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("router"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("view"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("**")]),t._v("渲染watcher更新，重新渲染组件。\n\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br")])]),t._v(" "),s("h2",{attrs:{id:"computed-的实现原理-和-methods-的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#computed-的实现原理-和-methods-的区别"}},[t._v("#")]),t._v(" computed 的实现原理，和 methods 的区别")]),t._v(" "),s("p",[t._v("计算属性在触发 get 的时候，首先会判断 watcher.dirty 属性，根据这个属性实现缓存惰性原理。只有当\n这个属性给 true 时才会重新获取依赖，否则拿缓存的值。 接着还有 Dep.target 判断，这个作用就是去收集依赖计算属性的依赖，触发 watcher.depend()方法，会\n在 computed watcher 里 deps 添加依赖。 所以 computed 内的响应式数据会收集 computed-watcher 和依赖 render-watcher 的依赖。")]),t._v(" "),s("h2",{attrs:{id:"vue-中子组件为何不可以修改父组件传递的-prop"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#vue-中子组件为何不可以修改父组件传递的-prop"}},[t._v("#")]),t._v(" vue 中子组件为何不可以修改父组件传递的 Prop")]),t._v(" "),s("p",[t._v("单向数据流\n在组件 "),s("strong",[t._v("initProps")]),t._v(" 方法的时候，会对 props 进行 defineReactive 操作，传入的第四个参数是自定义的 set 函数，当修改 props 时触发 set，然后进行判断，如果不是 root 根组件，并且不是更新子组件，vue 就 会报一个警告。\n修改改引用数据类型的某个属性值时，对应的 props 也会修改，并且 vue 不会报警告。因为 props 是浅监听")]),t._v(" "),s("blockquote",[s("p",[t._v("由于 props 本身是通过 defineReactive 定义的，所以 props 本身是响应式的，但没有对值 进行深度定义。为什么这样做呢?很简单，我们知道 props 是来自外界的数据， props 是来自 父组件的数据，这个数据如果是一个对象(包括纯对象和数组)，那么它本身可能已经是响应式的 了，所以不再需要重复定义。")])]),t._v(" "),s("p",[t._v("为什么 props 只做一层响应，因为传过来的可能是基础类型(string、number)")]),t._v(" "),s("h2",{attrs:{id:"v-if-实现原理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#v-if-实现原理"}},[t._v("#")]),t._v(" v-if 实现原理")]),t._v(" "),s("p",[t._v("Vue 内部会把 v-if、v-else、v-else-if 解析称为一个三元运算符，在 parse 时，对于有 v-if 节点会添加一个 if 和 ifConditions 属性，对于 v-else/v-else-if，并不会把当前对应的 AST 对象添加到 AST 树里，而是会把自 己的 AST 添加到最近的 v-if 的 ifConditions 属性。\nifConditions 是一个数组，每各项是一个对象，对应有 exp 和 block，exp 代表表达式，block 代表 el。 最后在执行 generate 生成 render 函数时候会对有 if 属性的 AST 执行 genIf 函数，最后会生成一个三元表达\n式。")]),t._v(" "),s("h2",{attrs:{id:"v-for-实现原理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#v-for-实现原理"}},[t._v("#")]),t._v(" v-for 实现原理")]),t._v(" "),s("p",[t._v("在解析模板的时，对于有 v-for 的节点会执行 parseFor()函数，会在 AST 里添加 for、iterator1、\niterator2...的属性，for 的值为要遍历的值，iterator1、iterator2 为迭代器的别名，(比如 key/index) 在执行 generate 生成 render 函数时候会对有 for 属性的 AST 执行 genFor 函数，会生成_l 也就是 renderList\n方法。\nrenderList 方法会对传入的数据根据不同的类型做了处理( 因为支持循环数组、对象、数字或者字符\n串)，对每一项执行_c(createElement)方法去创建元素。")]),t._v(" "),s("h2",{attrs:{id:"异步组件实现原理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#异步组件实现原理"}},[t._v("#")]),t._v(" 异步组件实现原理")]),t._v(" "),s("p",[t._v("vue 异步组件内部有三种实现方式:工厂函数、Promise、高级异步组件。 组件有对象和函数的形式，普通对象组件注册时会执行 Vue.extend()函数，生成一个 cid。走正常流程。\n当组件是一个函数时，且这个函数是异步加载的，那 webpack 会将编译后的代码分割成不同的块，这些 块将通过 Ajax 请求自动下载。在 vue 里，异步组件没有执行 vue.extend 函数，没有 cid，渲染时候会先 生成一个注释节点，再执行 factory(resolve, reject)执行我们的工厂函数，组件的工厂函数通常会先发送 请求去加载我们的异步组件的 JS 文件，等待加载成功后会执行 resolve，接着会执行 forceRender()函 数，这个方法会遍历 "),s("strong",[t._v("factory.contexts")]),t._v(" ，拿到每一个调用异步组件的实例 "),s("strong",[t._v("vm")]),t._v(" , 执行\n"),s("strong",[t._v("vm.$forceUpdate()")]),t._v(" 方法重新渲染。\n异步组件实现的本质是 2 次渲染，除了 0 delay 的高级异步组件第一次直接渲染成 loading 组件外，其 它都是第一次渲染生成一个注释节点，当异步获取组件成功后，再通过 "),s("strong",[t._v("forceRender")]),t._v(" 强制重新渲染， 这样就能正确渲染出我们异步加载的组件了。\npromise、高级异步组件同理。")]),t._v(" "),s("h2",{attrs:{id:"slot-实现"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#slot-实现"}},[t._v("#")]),t._v(" slot 实现")]),t._v(" "),s("p",[t._v("普通插槽是在父组件编译和渲染阶段生成 "),s("strong",[t._v("vnodes")]),t._v(" ，所以数据的作用域是父组件实例，子组件渲染的时 候直接拿到这些渲染好的 "),s("strong",[t._v("vnodes")]),t._v(" 。\n作用域插槽，父组件在编译和渲染阶段并不会直接生成 "),s("strong",[t._v("vnodes")]),t._v(" ，而是在父节点 vnode 的 "),s("strong",[t._v("data")]),t._v(" 中保 留一个 scopedSlots 对象，存储着不同名称的插槽以及它们对应的渲染函数，只有在编译和渲染子组 件阶段才会执行这个渲染函数生成 "),s("strong",[t._v("vnodes")]),t._v(" ，由于是在子组件环境执行的，所以对应的数据作用域是子 组件实例。")]),t._v(" "),s("h2",{attrs:{id:"vue-中常见性能优化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#vue-中常见性能优化"}},[t._v("#")]),t._v(" Vue 中常见性能优化")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("不要将所有的数据都放在 data 中，data 中的数据都会增加 getter 和 setter，会收集对应的 watcher")])]),t._v(" "),s("li",[s("p",[t._v("vue 在 v-for 时给每项元素绑定事件时，可以用事件代理。")])]),t._v(" "),s("li",[s("p",[t._v("SPA ⻚面采用 keep-alive 缓存组件。")])]),t._v(" "),s("li",[s("p",[t._v("拆分组件( 提高复用性、增加代码的可维护性,减少不必要的渲染 )")])]),t._v(" "),s("li",[s("p",[t._v("v-if 当值为 false 时内部指令不会执行,具有阻断功能，很多情况下可以使用 v-if 替代 v-show。")])]),t._v(" "),s("li",[s("p",[t._v("key 保证唯一性 ( 默认 vue 会采用就地复用策略 )")])]),t._v(" "),s("li",[s("p",[t._v("Object.freeze 冻结数据")])]),t._v(" "),s("li",[s("p",[t._v("合理使用路由懒加载、异步组件")])]),t._v(" "),s("li",[s("p",[t._v("数据持久化的问题 (防抖、节流)")])])])])}),[],!1,null,null,null);s.default=n.exports}}]);