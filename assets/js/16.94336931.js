(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{484:function(v,_,t){v.exports=t.p+"assets/img/p1.a97012c8.png"},485:function(v,_,t){v.exports=t.p+"assets/img/p2.7c4e69f1.png"},641:function(v,_,t){"use strict";t.r(_);var r=t(2),e=Object(r.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h2",{attrs:{id:"javascript-的数据类型有哪些"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#javascript-的数据类型有哪些"}},[v._v("#")]),v._v(" JavaScript 的数据类型有哪些？")]),v._v(" "),_("p",[v._v("JavaScript共有 "),_("strong",[v._v("8")]),v._v(" 种数据类型")]),v._v(" "),_("p",[v._v("基本数据类型： "),_("strong",[v._v("Undefined、Null、Boolean、Number、String、Symbol、BigInt")])]),v._v(" "),_("p",[v._v("引用数据类型："),_("strong",[v._v("Object")])]),v._v(" "),_("blockquote",[_("p",[v._v("其中 Symbol 和 BigInt 是ES6 中新增的数据类型：")])]),v._v(" "),_("ul",[_("li",[v._v("Symbol 代表创建后独一无二且不可变的数据类型，它主要是为了解决可能出现的全局变量冲突的问题。")]),v._v(" "),_("li",[v._v("BigInt 是一种数字类型的数据，它可以表示任意精度格式的整数，使用 BigInt 可以安全地存储和操作大整数，即使这个数已经超出了 Number 能够表示的安全整数范围。")])]),v._v(" "),_("h2",{attrs:{id:"cookie的同源策略是怎么样的-跨域情况下如何携带cookie"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#cookie的同源策略是怎么样的-跨域情况下如何携带cookie"}},[v._v("#")]),v._v(" cookie的同源策略是怎么样的，跨域情况下如何携带cookie？")]),v._v(" "),_("p",[v._v("同源策略（协议&域名&端口）是浏览器安全机制的一部分，尤其是 "),_("code",[v._v("cookie")]),v._v(" 信息，它里面存在着 "),_("code",[v._v("sessionID")]),v._v(" ，这是与服务端的 "),_("code",[v._v("session")]),v._v(" 会话的重要凭证。")]),v._v(" "),_("p",[v._v("当涉及到Cookie时，同源策略的表现如下：")]),v._v(" "),_("ul",[_("li",[v._v("默认情况下，只有来自同一源的请求才会携带Cookie。如果请求的源不同，浏览器就不会发送Cookie。")]),v._v(" "),_("li",[v._v("但是，如果设置了document.cookie，那么这个Cookie就可以被其他源的脚本访问和修改")]),v._v(" "),_("li",[v._v("对于跨域请求，可以通过设置document.cookie来让浏览器将Cookie发送给其他源的服务器")])]),v._v(" "),_("p",[v._v("跨域问题解决方案")]),v._v(" "),_("ul",[_("li",[v._v("JSONP（JSON with Padding）：通过动态插入"),_("strong",[v._v("script")]),v._v("标签来实现跨域请求。服务器将数据包装在一个函数调用中返回，客户端在处理响应时将其包装在一个函数调用中，从而实现跨域访问数据的效果。但是，这种方法只适用于GET请求，并且有一定的安全风险。")]),v._v(" "),_("li",[v._v("CORS（跨来源资源共享）：通过服务器端设置CORS响应头，允许来自其他源的请求携带特定的Cookie。在服务器端设置"),_("strong",[v._v("Access-Control-Allow-Origin")]),v._v("头为允许的源，并设置"),_("strong",[v._v("Access-Control-Allow-Credentials")]),v._v("头为true，这样就可以允许跨域请求携带Cookie。另外，还可以使用代理服务器来绕过同源策略的限制。")]),v._v(" "),_("li",[v._v("使用代理服务器：在客户端使用代理服务器来发送请求，代理服务器可以访问不同源的资源或进行跨域请求。这种方法需要在客户端（前端）进行配置，并使用代理服务器来发送所有请求。\n修改浏览器设置：在某些情况下，可以通过修改浏览器设置来关闭同源策略的限制。但是，这种方法存在一定的安全风险，不建议使用。")])]),v._v(" "),_("p",[v._v("总的来说，为了解决跨域问题，最安全和常见的方法是使用"),_("strong",[v._v("CORS（后端处理）或代理服务器（vue项目的配置）")])]),v._v(" "),_("h2",{attrs:{id:"http-常见状态码和缓存策略"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http-常见状态码和缓存策略"}},[v._v("#")]),v._v(" HTTP 常见状态码和缓存策略")]),v._v(" "),_("ul",[_("li",[v._v("常见状态码")])]),v._v(" "),_("ul",[_("li",[v._v("200 - 成功。")]),v._v(" "),_("li",[v._v("301 - 永久重定向（配合 location，浏览器自动处理）。")]),v._v(" "),_("li",[v._v("302 - 临时重定向（配合 location，浏览器自动处理）。")]),v._v(" "),_("li",[v._v("304 - 资源未被修改-启用缓存（引出下面的缓存策略）。")]),v._v(" "),_("li",[v._v("403 - 没权限。")]),v._v(" "),_("li",[v._v("404 - 资源未找到。")]),v._v(" "),_("li",[v._v("500 - 服务器错误。")]),v._v(" "),_("li",[v._v("504 - 网关超时。")])]),v._v(" "),_("h3",{attrs:{id:"强缓存-浏览器决定-和-协商缓存-服务器决定"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#强缓存-浏览器决定-和-协商缓存-服务器决定"}},[v._v("#")]),v._v(" 强缓存（浏览器决定） 和 协商缓存（服务器决定）")]),v._v(" "),_("p",[_("strong",[v._v("强缓存：")])]),v._v(" "),_("ul",[_("li",[v._v("Expires (http1.0协议)")]),v._v(" "),_("li",[v._v("Cache-Control （http1.1协议）")])]),v._v(" "),_("ul",[_("li",[v._v("由于Expires参照的是本地客户端的时间，可被修改，所以"),_("strong",[v._v("Cache-control")]),v._v("的优先级要高于"),_("strong",[v._v("Expires")])]),v._v(" "),_("li",[v._v("不会向服务器发送请求，直接从缓存中读取资源，在chrome控制台的Network选项中可以看到该请求返回200的状态码，并且size显示from disk cache或from memory cache两种（灰色表示缓存）。")])]),v._v(" "),_("p",[_("strong",[v._v("协商缓存：")])]),v._v(" "),_("ul",[_("li",[v._v("Etag、If-None-Match (http1.1协议)")]),v._v(" "),_("li",[v._v("Last-Modified、If-Modified-Since (http1.0协议)-对比的是时间值")])]),v._v(" "),_("ul",[_("li",[v._v("向服务器发送请求，服务器会根据这个请求的request header的一些参数来判断是否命中协商缓存，如果命中，则返回304状态码并带上新的response header通知浏览器从缓存中读取资源；")])]),v._v(" "),_("p",[_("strong",[v._v("强缓存优先级大于协商缓存，即两者同时存在时，如果强缓存开启且在有效期内，则不会走协商缓存。")])]),v._v(" "),_("p",[_("strong",[v._v("共同点：都是从客户端缓存中读取资源； 区别是强缓存不会发请求，协商缓存会发请求（与服务端发生交互）。")])]),v._v(" "),_("h2",{attrs:{id:"进程和线程的区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#进程和线程的区别"}},[v._v("#")]),v._v(" 进程和线程的区别？")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("计算机资源独立分配到各个进程，进程之间 互相独立（可以通信，但是代价较大）")])]),v._v(" "),_("li",[_("p",[v._v("一个进程由一个或多个线程组成，是包含关系")])]),v._v(" "),_("li",[_("p",[v._v("同一进程下的各个线程之间共享程序的内存空间")])])]),v._v(" "),_("p",[_("strong",[v._v("进程是cpu资源分配的最小单位（是能拥有资源和独立运行的最小单位）")])]),v._v(" "),_("p",[_("strong",[v._v("线程是cpu调度的最小单位（线程是建立在进程的基础上的一次程序运行单位-可理解为实例）")])]),v._v(" "),_("h2",{attrs:{id:"浏览器的进程和线程是怎样的-从上面引出这个问题"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#浏览器的进程和线程是怎样的-从上面引出这个问题"}},[v._v("#")]),v._v(" 浏览器的进程和线程是怎样的？（从上面引出这个问题）")]),v._v(" "),_("p",[_("img",{attrs:{src:t(484),alt:"avatar"}})]),v._v(" "),_("ul",[_("li",[_("ol",[_("li",[v._v("Browser进程（主进程）")])])])]),v._v(" "),_("blockquote",[_("p",[v._v("控制chrome的地址栏，书签栏，返回和前进按钮，同时还有浏览器的不可见部分，例如网络请求和文件访问")])]),v._v(" "),_("ul",[_("li",[_("ol",{attrs:{start:"2"}},[_("li",[v._v("第三方插件进程")])])])]),v._v(" "),_("blockquote",[_("p",[v._v("每种插件一个进程，插件运行时才会创建")])]),v._v(" "),_("ul",[_("li",[_("ol",{attrs:{start:"3"}},[_("li",[v._v("GPU进程")])])])]),v._v(" "),_("blockquote",[_("p",[v._v("仅此一个 ，用于3D绘制等")])]),v._v(" "),_("ul",[_("li",[_("ol",{attrs:{start:"4"}},[_("li",[v._v("浏览器渲染进程（浏览器内核）")])])])]),v._v(" "),_("blockquote",[_("p",[v._v("负责界面渲染，脚本执行，事件处理等")])]),v._v(" "),_("p",[_("strong",[v._v("多进程的优势")])]),v._v(" "),_("ul",[_("li",[_("p",[v._v("1.避免单个页面崩溃造成整个浏览器的卡顿（由于每一个 Tab页 都是独立的进程）")])]),v._v(" "),_("li",[_("p",[v._v("2.避免第三方插件崩溃影响整个浏览器（由于第三方插件是独立的进程）")])]),v._v(" "),_("li",[_("p",[v._v("3.多进程充分利用多核优势（"),_("strong",[v._v("现在的 CPU 性能都很高")]),v._v("）")])])]),v._v(" "),_("h2",{attrs:{id:"多线程的浏览器内核"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#多线程的浏览器内核"}},[v._v("#")]),v._v(" 多线程的浏览器内核")]),v._v(" "),_("p",[v._v("浏览器的内核，是极其复杂的，毕竟浏览器的整个核心，就是它，它主要由以下五种线程组成：")]),v._v(" "),_("h4",{attrs:{id:"_1-gui渲染线程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-gui渲染线程"}},[v._v("#")]),v._v(" 1. GUI渲染线程")]),v._v(" "),_("p",[v._v("负责渲染浏览器界面（解析 HTML ，CSS，构建 "),_("code",[v._v("DOM树")]),v._v(" "),_("code",[v._v("CSSOM树")]),v._v(" 和 "),_("code",[v._v("Render树")]),v._v(" ，布局和绘制等）。")]),v._v(" "),_("p",[v._v("GUI 更新会被保存在一个队列中等到 JS 引擎空闲时立即被执行，当界面需要重绘或由于某种操作引发的重排时，该线程就会执行。")]),v._v(" "),_("p",[_("strong",[v._v("GUI 渲染线程与 JS 引擎线程是互斥的")]),v._v("，这也是造成 "),_("code",[v._v("JS堵塞")]),v._v(" 的原因所在。")]),v._v(" "),_("p",[v._v("由于 JavaScript 是可操纵 DOM 的，如果在修改这些元素属性同时渲染界面（即 JS 引擎线程和 GUI 渲染线程同时运行），那么渲染线程前后获得的元素数据就可能不一致了。")]),v._v(" "),_("p",[v._v("因此为了防止渲染出现不可预期的结果，浏览器设置 GUI 渲染线程与 JavaScript 引擎为互斥的关系，当 JavaScript 引擎执行时 GUI 线程会被挂起，GUI 更新会被保存在一个队列中等到引擎线程空闲时立即被执行。")]),v._v(" "),_("p",[v._v("如果想了解有关于 "),_("code",[v._v("CSS")]),v._v(" 和 "),_("code",[v._v("JS")]),v._v(" 的堵塞问题，可以查阅 "),_("a",{attrs:{href:"https://juejin.cn/post/7044360789708242980",title:"https://juejin.cn/post/7044360789708242980",target:"_blank",rel:"noopener noreferrer"}},[v._v("面试中常问到的CSS堵塞和JS堵塞"),_("OutboundLink")],1)]),v._v(" "),_("h4",{attrs:{id:"_2-js引擎线程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-js引擎线程"}},[v._v("#")]),v._v(" 2. JS引擎线程")]),v._v(" "),_("p",[v._v("也称为 JS 内核，负责处理 JavaScript 脚本程序。")]),v._v(" "),_("p",[v._v("JS引擎一直等待着任务队列中任务的到来，然后加以处理，一个Tab页中无论什么时候都只有一个JS线程在运行JS程序（我们早在之前说过了，JS是一门"),_("strong",[v._v("单线程")]),v._v("的语言。至于原因可以查阅 "),_("a",{attrs:{href:"https://juejin.cn/post/6886602875225833480#heading-1",title:"https://juejin.cn/post/6886602875225833480#heading-1",target:"_blank",rel:"noopener noreferrer"}},[v._v("单线程的JS"),_("OutboundLink")],1)]),v._v(" "),_("p",[v._v("再次注意，"),_("strong",[v._v("GUI 渲染线程与 JS 引擎线程是互斥的")]),v._v(" ，所以，如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。")]),v._v(" "),_("h4",{attrs:{id:"_3-事件触发线程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-事件触发线程"}},[v._v("#")]),v._v(" 3. 事件触发线程")]),v._v(" "),_("p",[v._v("首先这属于浏览器而不是JS引擎，主要用来控制事件循环（可以理解，JS引擎自己都忙不过来，需要浏览器另开线程协助）")]),v._v(" "),_("p",[v._v("当JS引擎执行代码块如setTimeOut时（也可来自浏览器内核的其他线程,如鼠标点击、AJAX异步请求等），会将对应任务添加到事件线程中。")]),v._v(" "),_("p",[_("strong",[v._v("当对应的事件符合触发条件被触发时，该线程会把是事件添加到待处理队列（宏任务）的队尾，等待JS引擎的处理。")])]),v._v(" "),_("p",[v._v("同样地，由于 JS 是"),_("strong",[v._v("单线程")]),v._v("的，所以需要等到 JS 引擎空闲了之后，才会对待处理队列进行处理。")]),v._v(" "),_("h4",{attrs:{id:"_4-定时触发器线程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-定时触发器线程"}},[v._v("#")]),v._v(" 4. 定时触发器线程")]),v._v(" "),_("p",[v._v("传说中的 "),_("code",[v._v("setInterval")]),v._v(" 与 "),_("code",[v._v("setTimeout")]),v._v(" 所在线程。")]),v._v(" "),_("p",[v._v("因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确。")]),v._v(" "),_("p",[v._v("因此通过单独线程来计时并触发定时，计时完毕后，添加到事件队列（宏任务）中，等待JS引擎空闲后执行。")]),v._v(" "),_("p",[v._v("不禁感叹，懂得 JS 的"),_("strong",[v._v("单线程")]),v._v(" 原来那么有用。")]),v._v(" "),_("p",[v._v("需要值得注意的是，W3C 在 HTML 标准中规定，规定要求 "),_("code",[v._v("setTimeout")]),v._v(" 中低于4ms的时间间隔算为4ms。")]),v._v(" "),_("h4",{attrs:{id:"_5-异步http请求线程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_5-异步http请求线程"}},[v._v("#")]),v._v(" 5. 异步http请求线程")]),v._v(" "),_("p",[_("code",[v._v("XMLHttpRequest")]),v._v(" 在连接后是通过浏览器新开的一个线程请求。")]),v._v(" "),_("p",[v._v("当检测到状态更新时，如果没有设置回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列（微任务）中，等待 JS 引擎执行。")]),v._v(" "),_("p",[v._v("关于这个事件队列的执行机制，以及对于 "),_("code",[v._v("微任务")]),v._v(" 与 "),_("code",[v._v("宏任务")]),v._v(" 云里雾里的，可以查阅"),_("a",{attrs:{href:"https://juejin.cn/post/6886602875225833480",title:"https://juejin.cn/post/6886602875225833480",target:"_blank",rel:"noopener noreferrer"}},[v._v("一文搞懂JS系列（六）之微任务与宏任务，Event Loop"),_("OutboundLink")],1)]),v._v(" "),_("h2",{attrs:{id:"什么是作用域-js有哪些作用域-有什么特点"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#什么是作用域-js有哪些作用域-有什么特点"}},[v._v("#")]),v._v(" 什么是作用域 ，js有哪些作用域，有什么特点")]),v._v(" "),_("p",[v._v("作用域就是变量和函数的可访问范围。在特定的作用域内，变量和函数可以被访问和使用，而在作用域之外则无法访问。")]),v._v(" "),_("p",[_("strong",[v._v("在JavaScript中，主要有以下几种作用域：")])]),v._v(" "),_("p",[_("strong",[v._v("全局作用域")]),v._v("：")]),v._v(" "),_("ul",[_("li",[v._v("在代码的任何位置都可以访问全局作用域中的变量和函数。在浏览器环境中，全局作用域就是window对象。")])]),v._v(" "),_("p",[_("strong",[v._v("函数作用域")]),v._v("：")]),v._v(" "),_("ul",[_("li",[v._v("在函数内部声明的变量和函数只在函数内部可见，这就是函数作用域。需要注意的是，ES6以前的JavaScript版本中，函数作用域是通过函数声明（function declaration）和变量声明（var）来实现的。")])]),v._v(" "),_("p",[_("strong",[v._v("块级作用域")]),v._v("：")]),v._v(" "),_("ul",[_("li",[v._v("块级作用域是由一对花括号{}定义的代码块。在ES6中引入了let和const关键字，它们声明的变量具有块级作用域。这意味着在这些关键字声明的变量只在声明它们的代码块内可见。")])]),v._v(" "),_("p",[_("strong",[v._v("作用域的特点主要有以下几点：")])]),v._v(" "),_("p",[_("strong",[v._v("层次性")]),v._v("：")]),v._v(" "),_("ul",[_("li",[v._v("作用域之间存在层次关系，例如函数作用域嵌套在全局作用域中，块级作用域嵌套在函数作用域中。当访问一个变量时，JavaScript会首先在当前作用域中查找，如果找不到，就会向上级作用域查找，直到找到为止(作用域链)。")])]),v._v(" "),_("p",[_("strong",[v._v("隔离性")]),v._v("：")]),v._v(" "),_("ul",[_("li",[v._v("不同作用域中的变量和函数是相互隔离的，互不影响。这有助于减少变量和函数的冲突，提高代码的可维护性。")])]),v._v(" "),_("p",[_("strong",[v._v("生命周期")]),v._v("：")]),v._v(" "),_("ul",[_("li",[v._v("变量的生命周期与作用域紧密相关。全局变量的生命周期是整个程序的运行期间，而局部变量（如函数作用域和块级作用域的变量）的生命周期则是从声明开始到其作用域结束。")])]),v._v(" "),_("h2",{attrs:{id:"什么是原型链-如何实现继承"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#什么是原型链-如何实现继承"}},[v._v("#")]),v._v(" 什么是原型链，如何实现继承")]),v._v(" "),_("p",[v._v("关系图\n"),_("img",{attrs:{src:t(485),alt:"avatar"}})])])}),[],!1,null,null,null);_.default=e.exports}}]);