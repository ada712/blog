(window.webpackJsonp=window.webpackJsonp||[]).push([[82],{563:function(t,s,a){"use strict";a.r(s);var n=a(2),e=Object(n.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"一、js基础"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#一、js基础"}},[t._v("#")]),t._v(" 一、JS基础")]),t._v(" "),s("h3",{attrs:{id:"_1-1-js有哪些数据类型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-js有哪些数据类型"}},[t._v("#")]),t._v(" 1.1 Js有哪些数据类型")]),t._v(" "),s("p",[t._v("JavaScript共有 "),s("strong",[t._v("8")]),t._v(" 种数据类型")]),t._v(" "),s("p",[t._v("基本数据类型： "),s("strong",[t._v("Undefined、Null、Boolean、Number、String、Symbol、BigInt")])]),t._v(" "),s("p",[t._v("引用数据类型："),s("strong",[t._v("Object")])]),t._v(" "),s("blockquote",[s("p",[t._v("其中 Symbol 和 BigInt 是ES6 中新增的数据类型：")])]),t._v(" "),s("ul",[s("li",[t._v("Symbol 代表创建后独一无二且不可变的数据类型，它主要是为了解决可能出现的全局变量冲突的问题。")]),t._v(" "),s("li",[t._v("BigInt 是一种数字类型的数据，它可以表示任意精度格式的整数，使用 BigInt 可以安全地存储和操作大整数，即使这个数已经超出了 Number 能够表示的安全整数范围。")])]),t._v(" "),s("h3",{attrs:{id:"_1-2-说说你对堆区和栈区的理解"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-说说你对堆区和栈区的理解"}},[t._v("#")]),t._v(" 1.2 说说你对堆区和栈区的理解")]),t._v(" "),s("p",[s("strong",[t._v("在操作系统中，内存被分为栈区和堆区")])]),t._v(" "),s("ul",[s("li",[t._v("栈区内存由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。")]),t._v(" "),s("li",[t._v("堆区内存一般由开发着分配释放，若开发者不释放，程序结束时可能由垃圾回收机制回收。")])]),t._v(" "),s("p",[s("strong",[t._v("在数据结构中：")])]),t._v(" "),s("ul",[s("li",[t._v("在数据结构中，栈中数据的存取方式为先进后出。")]),t._v(" "),s("li",[t._v("堆是一个优先队列，是按优先级来进行排序的，优先级可以按照大小来规定。")])]),t._v(" "),s("p",[s("strong",[t._v("数据的储存方式")])]),t._v(" "),s("ul",[s("li",[t._v("原始数据类型直接存储在栈（stack）中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；")]),t._v(" "),s("li",[t._v("引用数据类型存储在堆（heap）中的对象，占据空间大、大小不固定。如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。")])]),t._v(" "),s("h3",{attrs:{id:"_1-3-数据类型检测的方式有哪些"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-数据类型检测的方式有哪些"}},[t._v("#")]),t._v(" 1.3 数据类型检测的方式有哪些")]),t._v(" "),s("p",[t._v("然后判断数据类型的方法一般可以通过："),s("strong",[t._v("typeof")]),t._v("、"),s("strong",[t._v("instanceof")]),t._v("、"),s("strong",[t._v("constructor")]),t._v("、"),s("strong",[t._v("toString")]),t._v("四种常用方法")]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",[t._v("不同类型的优缺点")]),t._v(" "),s("th",[t._v("typeof")]),t._v(" "),s("th",[t._v("instanceof")]),t._v(" "),s("th",[t._v("constructor")]),t._v(" "),s("th",[t._v("Object.prototype.toString.call")])])]),t._v(" "),s("tbody",[s("tr",[s("td",[t._v("优点")]),t._v(" "),s("td",[t._v("使用简单")]),t._v(" "),s("td",[t._v("能检测出"),s("code",[t._v("引用类型")])]),t._v(" "),s("td",[t._v("基本能检测所有的类型（除了null和undefined）")]),t._v(" "),s("td",[t._v("检测出所有的类型")])]),t._v(" "),s("tr",[s("td",[t._v("缺点")]),t._v(" "),s("td",[t._v("只能检测出除null外的基本数据类型和引用数据类型中的function")]),t._v(" "),s("td",[t._v("不能检测出基本类型，且不能跨iframe")]),t._v(" "),s("td",[t._v("constructor易被修改，也不能跨iframe")]),t._v(" "),s("td",[t._v("IE6下，undefined和null均为Object")])])])]),t._v(" "),s("h3",{attrs:{id:"_1-4-判断数组的方式有哪些"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-4-判断数组的方式有哪些"}},[t._v("#")]),t._v(" 1.4 判断数组的方式有哪些")]),t._v(" "),s("ul",[s("li",[t._v("通过Object.prototype.toString.call()做判断")]),t._v(" "),s("li",[t._v("通过原型链做判断")]),t._v(" "),s("li",[t._v("通过ES6的Array.isArray()做判断")]),t._v(" "),s("li",[t._v("通过instanceof做判断")]),t._v(" "),s("li",[t._v("通过Array.prototype.isPrototypeOf")])]),t._v(" "),s("h3",{attrs:{id:"_1-5-null和undefined区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-5-null和undefined区别"}},[t._v("#")]),t._v(" 1.5 null和undefined区别")]),t._v(" "),s("ul",[s("li",[t._v("首先 Undefined 和 Null 都是基本数据类型，这两个基本数据类型分别都只有一个值，就是 undefined 和 null。")]),t._v(" "),s("li",[t._v("undefined 代表的含义是"),s("strong",[t._v("未定义")]),t._v("，null 代表的含义是"),s("strong",[t._v("空对象")]),t._v("。一般变量声明了但还没有定义的时候会返回 undefined，null主要用于赋值给一些可能会返回对象的变量，作为初始化。")]),t._v(" "),s("li",[t._v("undefined 在 JavaScript 中不是一个保留字，这意味着可以使用 undefined 来作为一个变量名，但是这样的做法是非常危险的，它会影响对 undefined 值的判断。我们可以通过一些方法获得安全的 undefined 值，比如说 void 0。")]),t._v(" "),s("li",[t._v("当对这两种类型使用 typeof 进行判断时，Null 类型化会返回 “object”，这是一个历史遗留的问题。当使用双等号对两种类型的值进行比较时会返回 true，使用三个等号时会返回 false。")])]),t._v(" "),s("h3",{attrs:{id:"_1-6-typeof-null-的结果是什么-为什么"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-6-typeof-null-的结果是什么-为什么"}},[t._v("#")]),t._v(" 1.6 typeof null 的结果是什么，为什么？")]),t._v(" "),s("p",[t._v("typeof null 的结果是Object。")]),t._v(" "),s("p",[t._v("在 JavaScript 第一个版本中，所有值都存储在 32 位的单元中，每个单元包含一个小的 "),s("strong",[t._v("类型标签(1-3 bits)")]),t._v(" 以及当前要存储值的真实数据。类型标签存储在每个单元的低位中，共有五种数据类型：")]),t._v(" "),s("div",{staticClass:"language-php line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-php"}},[s("code",[s("span",{pre:!0,attrs:{class:"token number"}},[t._v("000")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword type-declaration"}},[t._v("object")]),t._v("   "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" 当前存储的数据指向一个对象。\n  "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword type-declaration"}},[t._v("int")]),t._v("      "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" 当前存储的数据是一个 "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("31")]),t._v(" 位的有符号整数。\n"),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("010")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" double   "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" 当前存储的数据指向一个双精度的浮点数。\n"),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("100")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword type-declaration"}},[t._v("string")]),t._v("   "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" 当前存储的数据指向一个字符串。\n"),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("110")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" boolean  "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" 当前存储的数据是布尔值。\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br")])]),s("p",[t._v("如果最低位是 1，则类型标签标志位的长度只有一位；如果最低位是 0，则类型标签标志位的长度占三位，为存储其他四种数据类型提供了额外两个 bit 的长度。")]),t._v(" "),s("p",[t._v("有两种特殊数据类型：")]),t._v(" "),s("ul",[s("li",[t._v("undefined的值是 (-2)30(一个超出整数范围的数字)；")]),t._v(" "),s("li",[t._v("null 的值是机器码 NULL 指针(null 指针的值全是 0)")])]),t._v(" "),s("p",[t._v("那也就是说null的类型标签也是000，和Object的类型标签一样，所以会被判定为Object。")]),t._v(" "),s("h3",{attrs:{id:"_1-7-为什么0-1-0-2-0-3-如何让其相等-精度丢失"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-7-为什么0-1-0-2-0-3-如何让其相等-精度丢失"}},[t._v("#")]),t._v(" 1.7 为什么0.1+0.2 ! == 0.3，如何让其相等 (精度丢失)")]),t._v(" "),s("p",[t._v("计算机是通过二进制的方式存储数据的，所以计算机计算0.1+0.2的时候，实际上是计算的两个数的二进制的和。")]),t._v(" "),s("p",[t._v("在 Js中只有一种数字类型：Number，它的实现遵循IEEE 754标准，使用64位固定长度来表示，也就是标准的double双精度浮点数。在二进制科学表示法中，双精度浮点数的小数部分最多只能保留52位，再加上前面的1，其实就是保留53位有效数字，剩余的需要舍去，遵从“0舍1入”的原则。")]),t._v(" "),s("p",[t._v("根据这个原则，0.1和0.2的二进制数相加，再转化为十进制数就是："),s("code",[t._v("0.30000000000000004")]),t._v("。所以不相等")]),t._v(" "),s("p",[t._v("解决方法就是设置一个误差范围，通常称为“机器精度”。对JavaScript来说，这个值通常为2-52，在ES6中，提供了"),s("code",[t._v("Number.EPSILON")]),t._v("属性，而它的值就是2-52，只要判断"),s("code",[t._v("0.1+0.2-0.3")]),t._v("是否小于"),s("code",[t._v("Number.EPSILON")]),t._v("，如果小于，就可以判断为0.1+0.2 ===0.3")]),t._v(" "),s("div",{staticClass:"language-javascript line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-javascript"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("numberepsilon")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("arg1"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("arg2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("                  \n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" Math"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("abs")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("arg1 "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" arg2"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" Number"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("EPSILON")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("        \n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("        \n​\nconsole"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("numberepsilon")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0.1")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0.2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0.3")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// true")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br")])]),s("h3",{attrs:{id:"_1-8-如何获取安全的-undefined-值"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-8-如何获取安全的-undefined-值"}},[t._v("#")]),t._v(" 1.8 如何获取安全的 undefined 值？")]),t._v(" "),s("p",[t._v("因为 undefined 是一个标识符，所以可以被当作变量来使用和赋值，但是这样会影响 undefined 的正常判断。表达式 void ___ 没有返回值，因此返回结果是 undefined。void 并不改变表达式的结果，只是让表达式不返回值。因此可以用 void 0 来获得 undefined。")]),t._v(" "),s("h3",{attrs:{id:"_1-9-typeof-nan-的结果是什么"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-9-typeof-nan-的结果是什么"}},[t._v("#")]),t._v(" 1.9 typeof NaN 的结果是什么？")]),t._v(" "),s("p",[t._v("NaN 指“不是一个数字”（not a number），NaN 是一个“警戒值”（sentinel value，有特殊用途的常规值），用于指出数字类型中的错误情况，即“执行数学运算没有成功，这是失败后返回的结果”。")]),t._v(" "),s("div",{staticClass:"language-csharp line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-csharp"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("typeof")]),t._v(" NaN"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v('// "number"')]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])]),s("p",[t._v("NaN 是一个特殊值，它和自身不相等，是唯一一个非自反的值。所谓的非自反就是说，NaN 与谁都不相等，包括它本身，但在 NaN ！= NaN 下会返回true")]),t._v(" "),s("h3",{attrs:{id:"_1-10-isnan-和-number-isnan-函数的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-10-isnan-和-number-isnan-函数的区别"}},[t._v("#")]),t._v(" 1.10 isNaN 和 Number.isNaN 函数的区别？")]),t._v(" "),s("ul",[s("li",[t._v("函数 isNaN 接收参数后，会尝试将这个参数转换为数值，任何不能被转换为数值的的值都会返回 true，因此非数字值传入也会返回 true ，会影响 NaN 的判断。")]),t._v(" "),s("li",[t._v("函数 Number.isNaN 会首先判断传入参数是否为数字，如果是数字再继续判断是否为 NaN ，不会进行数据类型的转换，这种方法对于 NaN 的判断更为准确。")])]),t._v(" "),s("h3",{attrs:{id:"_1-11-操作符的强制类型转换规则是什么"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-11-操作符的强制类型转换规则是什么"}},[t._v("#")]),t._v(" 1.11 == 操作符的强制类型转换规则是什么？")]),t._v(" "),s("p",[t._v("对于 "),s("code",[t._v("==")]),t._v(" 来说，如果对比双方的类型"),s("strong",[t._v("不一样")]),t._v("，就会进行"),s("strong",[t._v("类型转换")]),t._v("。假如对比 "),s("code",[t._v("x")]),t._v(" 和 "),s("code",[t._v("y")]),t._v(" 是否相同，就会进行如下判断流程：")]),t._v(" "),s("ol",{attrs:{start:"0"}},[s("li",[t._v("首先会判断两者类型是否"),s("strong",[t._v("相同，")]),t._v(" 相同的话就比较两者的大小；")]),t._v(" "),s("li",[t._v("类型不相同的话，就会进行类型转换；")]),t._v(" "),s("li",[t._v("会先判断是否在对比 "),s("code",[t._v("null")]),t._v(" 和 "),s("code",[t._v("undefined")]),t._v("，是的话就会返回 "),s("code",[t._v("true")])]),t._v(" "),s("li",[t._v("判断两者类型是否为 "),s("code",[t._v("string")]),t._v(" 和 "),s("code",[t._v("number")]),t._v("，是的话就会将字符串转换为 "),s("code",[t._v("number")])])]),t._v(" "),s("div",{staticClass:"language-ini line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-ini"}},[s("code",[s("span",{pre:!0,attrs:{class:"token key attr-name"}},[t._v("1")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token value attr-value"}},[t._v("= '1'")]),t._v("\n      ↓\n"),s("span",{pre:!0,attrs:{class:"token key attr-name"}},[t._v("1")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token value attr-value"}},[t._v("=  1")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br")])]),s("ol",{attrs:{start:"0"}},[s("li",[t._v("判断其中一方是否为 "),s("code",[t._v("boolean")]),t._v("，是的话就会把 "),s("code",[t._v("boolean")]),t._v(" 转为 "),s("code",[t._v("number")]),t._v(" 再进行判断")])]),t._v(" "),s("div",{staticClass:"language-ini line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-ini"}},[s("code",[s("span",{pre:!0,attrs:{class:"token key attr-name"}},[t._v("'1'")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token value attr-value"}},[t._v("= true")]),t._v("\n        ↓\n"),s("span",{pre:!0,attrs:{class:"token key attr-name"}},[t._v("'1'")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token value attr-value"}},[t._v("=  1")]),t._v("\n        ↓\n "),s("span",{pre:!0,attrs:{class:"token key attr-name"}},[t._v("1  ")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token value attr-value"}},[t._v("=  1")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br")])]),s("ol",{attrs:{start:"0"}},[s("li",[t._v("判断其中一方是否为 "),s("code",[t._v("object")]),t._v(" 且另一方为 "),s("code",[t._v("string")]),t._v("、"),s("code",[t._v("number")]),t._v(" 或者 "),s("code",[t._v("symbol")]),t._v("，是的话就会把 "),s("code",[t._v("object")]),t._v(" 转为原始类型再进行判断")])]),t._v(" "),s("div",{staticClass:"language-ini line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-ini"}},[s("code",[s("span",{pre:!0,attrs:{class:"token key attr-name"}},[t._v("'1'")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token value attr-value"}},[t._v("= { name: 'js' }        ↓'1' == '[object Object]'")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])]),s("p",[t._v("其流程图如下：")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/446f656981cc4acb92f92ef6c57c3686~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image?",alt:"微信截图_20221004091412.png"}})]),t._v(" "),s("h3",{attrs:{id:"_1-12-其他值类型转成字符串的转换规则"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-12-其他值类型转成字符串的转换规则"}},[t._v("#")]),t._v(" 1.12 其他值类型转成字符串的转换规则？")]),t._v(" "),s("ul",[s("li",[t._v('Null 和 Undefined 类型 ，null 转换为 "null"，undefined 转换为 "undefined"，')]),t._v(" "),s("li",[t._v('Boolean 类型，true 转换为 "true"，false 转换为 "false"。')]),t._v(" "),s("li",[t._v("Number 类型的值直接转换，不过那些极小和极大的数字会使用指数形式。")]),t._v(" "),s("li",[t._v("Symbol 类型的值直接转换，但是只允许显式强制类型转换，使用隐式强制类型转换会产生错误。")]),t._v(" "),s("li",[t._v('对普通对象来说，除非自行定义 toString() 方法，否则会调用 toString()（Object.prototype.toString()）来返回内部属性 [[Class]] 的值，如"[object Object]"。如果对象有自己的 toString() 方法，字符串化时就会调用该方法并使用其返回值。')])]),t._v(" "),s("h3",{attrs:{id:"_1-13-其他值类型转成数字的转换规则"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-13-其他值类型转成数字的转换规则"}},[t._v("#")]),t._v(" 1.13. 其他值类型转成数字的转换规则？")]),t._v(" "),s("ul",[s("li",[t._v("Undefined 类型的值转换为 NaN。")]),t._v(" "),s("li",[t._v("Null 类型的值转换为 0。")]),t._v(" "),s("li",[t._v("Boolean 类型的值，true 转换为 1，false 转换为 0。")]),t._v(" "),s("li",[t._v("String 类型的值转换如同使用 Number() 函数进行转换，如果包含非数字值则转换为 NaN，空字符串为 0。")]),t._v(" "),s("li",[t._v("Symbol 类型的值不能转换为数字，会报错。")]),t._v(" "),s("li",[t._v("对象（包括数组）会首先被转换为相应的基本类型值，如果返回的是非数字的基本类型值，则再遵循以上规则将其强制转换为数字。")])]),t._v(" "),s("p",[t._v("为了将值转换为相应的基本类型值， 隐式转换会首先检查该值是否有valueOf()方法。如果有并且返回基本类型值，就使用该值进行强制类型转换。如果没有就使用 toString() 的返回值（如果存在）来进行强制类型转换。")]),t._v(" "),s("p",[t._v("如果 valueOf() 和 toString() 均不返回基本类型值，会产生 TypeError 错误。")]),t._v(" "),s("h3",{attrs:{id:"_1-14-其他值类型转成布尔类型的转换规则"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-14-其他值类型转成布尔类型的转换规则"}},[t._v("#")]),t._v(" 1.14 其他值类型转成布尔类型的转换规则？")]),t._v(" "),s("p",[t._v('以下这些是假值： undefined 、 null 、 false 、 +0、-0 和 NaN 、 ""')]),t._v(" "),s("p",[t._v("假值的布尔强制类型转换结果为 false。从逻辑上说，假值列表以外的都应该是真值。")]),t._v(" "),s("h3",{attrs:{id:"_1-15-和-操作符的返回值"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-15-和-操作符的返回值"}},[t._v("#")]),t._v(" 1.15. || 和 && 操作符的返回值？")]),t._v(" "),s("p",[t._v("|| 和 && 首先会对第一个操作数执行条件判断，如果其不是布尔值就先强制转换为布尔类型，然后再执行条件判断。")]),t._v(" "),s("ul",[s("li",[t._v("对于 || 来说，如果条件判断结果为 true 就返回第一个操作数的值，如果为 false 就返回第二个操作数的值。")]),t._v(" "),s("li",[t._v("&& 则相反，如果条件判断结果为 true 就返回第二个操作数的值，如果为 false 就返回第一个操作数的值。")])]),t._v(" "),s("p",[t._v("|| 和 && 返回它们其中一个操作数的值，而非条件判断的结果")]),t._v(" "),s("h3",{attrs:{id:"_1-16-object-is-与比较操作符-、-的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-16-object-is-与比较操作符-、-的区别"}},[t._v("#")]),t._v(" 1.16. Object.is() 与比较操作符 “===”、“==” 的区别？")]),t._v(" "),s("ul",[s("li",[t._v("使用双等号（==）进行相等判断时，如果两边的类型不一致，则会进行强制类型转化后再进行比较。")]),t._v(" "),s("li",[t._v("使用三等号（===）进行相等判断时，如果两边的类型不一致时，不会做强制类型准换，直接返回 false。")]),t._v(" "),s("li",[t._v("使用 Object.is 来进行相等判断时，一般情况下和三等号的判断相同，它处理了一些特殊的情况，比如 -0 和 +0 不再相等，两个 NaN 是相等的。")])]),t._v(" "),s("h3",{attrs:{id:"_1-17-什么是-javascript-中的包装类型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-17-什么是-javascript-中的包装类型"}},[t._v("#")]),t._v(" 1.17. 什么是 JavaScript 中的包装类型？")]),t._v(" "),s("p",[t._v("在 JavaScript 中，基本类型是没有属性和方法的，但是为了便于操作基本类型的值，在调用基本类型的属性或方法时 JavaScript 会在后台隐式地将基本类型的值转换为对象。如：")]),t._v(" "),s("div",{staticClass:"language-ini line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-ini"}},[s("code",[s("span",{pre:!0,attrs:{class:"token key attr-name"}},[t._v("const a")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token value attr-value"}},[t._v('"abc";')]),t._v("\na.length; // 3\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br")])]),s("p",[t._v("在访问"),s("code",[t._v("'abc'.length")]),t._v("时，JavaScript 将"),s("code",[t._v("'abc'")]),t._v("在后台转换成"),s("code",[t._v("String('abc')")]),t._v("，然后再访问其"),s("code",[t._v("length")]),t._v("属性。")]),t._v(" "),s("h3",{attrs:{id:"_1-18-js中隐式转换规则"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-18-js中隐式转换规则"}},[t._v("#")]),t._v(" 1.18 Js中隐式转换规则")]),t._v(" "),s("p",[t._v("在 if 语句、逻辑语句、数学运算逻辑、== 等情况下都可能出现隐式类型转换。")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8249e191d95c46a8b66effb504b3de93~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image?",alt:"微信截图_20221004091517.png"}})]),t._v(" "),s("p",[t._v("坑: 判断时, 尽量不要用 "),s("code",[t._v("= =")]),t._v(" , 要用 "),s("code",[t._v("= = =")]),t._v(" ( 两个等号判断, 如果类型不同, 默认会进行隐式类型转换再比较)")]),t._v(" "),s("h3",{attrs:{id:"_1-19-说说你对this的理解"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-19-说说你对this的理解"}},[t._v("#")]),t._v(" 1.19 说说你对this的理解")]),t._v(" "),s("p",[t._v("this"),s("code",[t._v("是一个在运行时才进行绑定的引用")]),t._v("，在不同的情况下它可能会被绑定不同的对象。")]),t._v(" "),s("h3",{attrs:{id:"_1-20-如何判断-this-的指向"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-20-如何判断-this-的指向"}},[t._v("#")]),t._v(" 1.20 如何判断 this 的指向")]),t._v(" "),s("ul",[s("li",[t._v("第一种是"),s("strong",[t._v("函数调用模式")]),t._v("，当一个函数不是一个对象的属性时，直接作为函数来调用时，this 指向全局对象。")]),t._v(" "),s("li",[t._v("第二种是"),s("strong",[t._v("方法调用模式")]),t._v("，如果一个函数作为一个对象的方法来调用时，this 指向这个对象。")]),t._v(" "),s("li",[t._v("第三种是"),s("strong",[t._v("构造器调用模式")]),t._v("，如果一个函数用 new 调用时，函数执行前会新创建一个对象，this 指向这个新创建的对象。")]),t._v(" "),s("li",[t._v("第四种是 "),s("strong",[t._v("apply 、 call 和 bind 调用模式")]),t._v("，这三个方法都可以显示的指定调用函数的 this 指向。其中 apply 方法接收两个参数：一个是 this 绑定的对象，一个是参数数组。call 方法接收的参数，第一个是 this 绑定的对象，后面的其余参数是传入函数执行的参数。也就是说，在使用 call() 方法时，传递给函数的参数必须逐个列举出来。bind 方法通过传入一个对象，返回一个 this 绑定了传入对象的新函数。这个函数的 this 指向除了使用 new 时会被改变，其他情况下都不会改变。")])]),t._v(" "),s("h4",{attrs:{id:"this绑定的优先级"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#this绑定的优先级"}},[t._v("#")]),t._v(" "),s("strong",[t._v("this绑定的优先级")])]),t._v(" "),s("p",[t._v("new绑定优先级 > 显示绑定优先级 > 隐式绑定优先级 > 默认绑定优先级")]),t._v(" "),s("h3",{attrs:{id:"_1-21-map和object的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-21-map和object的区别"}},[t._v("#")]),t._v(" 1.21 Map和Object的区别")]),t._v(" "),s("table",[s("thead",[s("tr",[s("th"),t._v(" "),s("th",[t._v("Map")]),t._v(" "),s("th",[t._v("Object")])])]),t._v(" "),s("tbody",[s("tr",[s("td",[t._v("意外的键")]),t._v(" "),s("td",[t._v("Map默认情况不包含任何键，只包含显式插入的键。")]),t._v(" "),s("td",[t._v("Object 有一个原型, 原型链上的键名有可能和自己在对象上的设置的键名产生冲突。")])]),t._v(" "),s("tr",[s("td",[t._v("键的类型")]),t._v(" "),s("td",[t._v("Map的键可以是任意值，包括函数、对象或任意基本类型。")]),t._v(" "),s("td",[t._v("Object 的键必须是 String 或是Symbol。")])]),t._v(" "),s("tr",[s("td",[t._v("键的顺序")]),t._v(" "),s("td",[t._v("Map 中的 key 是有序的。因此，当迭代的时候， Map 对象以插入的顺序返回键值。")]),t._v(" "),s("td",[t._v("Object 的键是无序的")])]),t._v(" "),s("tr",[s("td",[t._v("Size")]),t._v(" "),s("td",[t._v("Map 的键值对个数可以轻易地通过size 属性获取")]),t._v(" "),s("td",[t._v("Object 的键值对个数只能手动计算")])]),t._v(" "),s("tr",[s("td",[t._v("迭代")]),t._v(" "),s("td",[t._v("Map 是 iterable 的，所以可以直接被迭代。")]),t._v(" "),s("td",[t._v("迭代Object需要以某种方式获取它的键然后才能迭代。")])]),t._v(" "),s("tr",[s("td",[t._v("性能")]),t._v(" "),s("td",[t._v("在频繁增删键值对的场景下表现更好。")]),t._v(" "),s("td",[t._v("在频繁添加和删除键值对的场景下未作出优化。")])])])]),t._v(" "),s("h3",{attrs:{id:"_1-22-说说你对json的理解"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-22-说说你对json的理解"}},[t._v("#")]),t._v(" 1.22 说说你对JSON的理解")]),t._v(" "),s("p",[t._v("JSON 是一种基于文本的轻量级的数据交换格式。它可以被任何的编程语言读取和作为数据格式来传递。")]),t._v(" "),s("p",[t._v("在项目开发中，使用 JSON 作为前后端数据交换的方式。在前端通过将一个符合 JSON 格式的数据结构序列化为 JSON 字符串，然后将它传递到后端，后端通过 JSON 格式的字符串解析后生成对应的数据结构，以此来实现前后端数据的一个传递。")]),t._v(" "),s("p",[t._v("因为 JSON 的语法是基于 js 的，因此很容易将 JSON 和 js 中的对象弄混，但是应该注意的是 JSON 和 js 中的对象不是一回事，JSON 中对象格式更加严格，比如说在 JSON 中属性值不能为函数，不能出现 NaN 这样的属性值等，因此大多数的 js 对象是不符合 JSON 对象的格式的。")]),t._v(" "),s("p",[t._v("在 js 中提供了两个函数来实现 js 数据结构和 JSON 格式的转换处理，")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("JSON.stringify")]),t._v(" 函数，通过传入一个符合 JSON 格式的数据结构，将其转换为一个 JSON 字符串。如果传入的数据结构不符合 JSON 格式，那么在序列化的时候会对这些值进行对应的特殊处理，使其符合规范。在前端向后端发送数据时，可以调用这个函数将数据对象转化为 JSON 格式的字符串。")]),t._v(" "),s("li",[s("strong",[t._v("JSON.parse()")]),t._v(" 函数，这个函数用来将 JSON 格式的字符串转换为一个 js 数据结构，如果传入的字符串不是标准的 JSON 格式的字符串的话，将会抛出错误。当从后端接收到 JSON 格式的字符串时，可以通过这个方法来将其解析为一个 js 数据结构，以此来进行数据的访问。")])]),t._v(" "),s("h3",{attrs:{id:"_1-222-string和json-stringify的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-222-string和json-stringify的区别"}},[t._v("#")]),t._v(" 1.222 String和JSON.stringify的区别")]),t._v(" "),s("div",{staticClass:"language-javascript line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-javascript"}},[s("code",[t._v("console"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("String")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"abc"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// abc")]),t._v("\nconsole"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("JSON")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("stringify")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"abc"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v('// "abc"')]),t._v("\n​\nconsole"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("String")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("key")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"value"')]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// [object Object]")]),t._v("\nconsole"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("JSON")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("stringify")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("key")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"value"')]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v('// {"key":"value"}')]),t._v("\n​\nconsole"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("String")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 1,2,3")]),t._v("\nconsole"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("JSON")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("stringify")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// [1,2,3]")]),t._v("\n​\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" obj "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    title"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"devpoint"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("toString")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"obj"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nconsole"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("String")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("obj"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// obj")]),t._v("\nconsole"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("JSON")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("stringify")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("obj"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v('// {"title":"devpoint"}')]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br"),s("span",{staticClass:"line-number"},[t._v("10")]),s("br"),s("span",{staticClass:"line-number"},[t._v("11")]),s("br"),s("span",{staticClass:"line-number"},[t._v("12")]),s("br"),s("span",{staticClass:"line-number"},[t._v("13")]),s("br"),s("span",{staticClass:"line-number"},[t._v("14")]),s("br"),s("span",{staticClass:"line-number"},[t._v("15")]),s("br"),s("span",{staticClass:"line-number"},[t._v("16")]),s("br"),s("span",{staticClass:"line-number"},[t._v("17")]),s("br")])]),s("ul",[s("li",[t._v("当需要将一个数组和一个普通对象转换为字符串时，经常使用"),s("code",[t._v("JSON.stringify")]),t._v("。")]),t._v(" "),s("li",[t._v("如果需要对象的"),s("code",[t._v("toString")]),t._v("方法被重写，则需要使用String()。")]),t._v(" "),s("li",[t._v("在其他情况下，使用"),s("code",[t._v("String()")]),t._v("将变量转换为字符串。")])]),t._v(" "),s("h3",{attrs:{id:"_1-23-什么是伪数组-类数组"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-23-什么是伪数组-类数组"}},[t._v("#")]),t._v(" 1.23 什么是伪数组(类数组)")]),t._v(" "),s("p",[t._v("一个拥有 length 属性和若干索引属性的对象就可以被称为类数组对象，类数组对象和数组类似，但是不能调用数组的方法。")]),t._v(" "),s("p",[t._v("常见的类数组对象有 arguments 和 DOM 方法的返回结果，还有一个函数也可以被看作是类数组对象，因为它含有 length 属性值，代表可接收的参数个数。")]),t._v(" "),s("h3",{attrs:{id:"_1-24-类数组转换成数组的方法有哪些"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-24-类数组转换成数组的方法有哪些"}},[t._v("#")]),t._v(" 1.24 类数组转换成数组的方法有哪些")]),t._v(" "),s("p",[t._v("常见的类数组转换为数组的方法有这样几种：")]),t._v(" "),s("ul",[s("li",[t._v("通过 call 调用数组的 slice 方法来实现转换")])]),t._v(" "),s("div",{staticClass:"language-javascript line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-javascript"}},[s("code",[s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Array")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("prototype"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("slice")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("call")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("arrayLike"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])]),s("ul",[s("li",[t._v("通过 call 调用数组的 splice 方法来实现转换")])]),t._v(" "),s("div",{staticClass:"language-javascript line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-javascript"}},[s("code",[s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Array")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("prototype"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("splice")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("call")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("arrayLike"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])]),s("ul",[s("li",[t._v("通过 apply 调用数组的 concat 方法来实现转换")])]),t._v(" "),s("div",{staticClass:"language-ini line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-ini"}},[s("code",[t._v("Array.prototype.concat.apply([], arrayLike);\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])]),s("ul",[s("li",[t._v("通过 Array.from 方法来实现转换")])]),t._v(" "),s("div",{staticClass:"language-csharp line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-csharp"}},[s("code",[t._v("Array"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("from")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("arrayLike"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])]),s("h3",{attrs:{id:"_1-25-unicode、utf-8、utf-16、utf-32的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-25-unicode、utf-8、utf-16、utf-32的区别"}},[t._v("#")]),t._v(" 1.25 "),s("strong",[t._v("Unicode、UTF-8、UTF-16、UTF-32的区别？")])]),t._v(" "),s("ul",[s("li",[s("code",[t._v("Unicode")]),t._v(" 是编码字符集（字符集），而"),s("code",[t._v("UTF-8")]),t._v("、"),s("code",[t._v("UTF-16")]),t._v("、"),s("code",[t._v("UTF-32")]),t._v("是字符集编码（编码规则）；")]),t._v(" "),s("li",[s("code",[t._v("UTF-16")]),t._v(" 使用变长码元序列的编码方式，相较于定长码元序列的"),s("code",[t._v("UTF-32")]),t._v("算法更复杂，甚至比同样是变长码元序列的"),s("code",[t._v("UTF-8")]),t._v("也更为复杂，因为其引入了独特的"),s("strong",[t._v("代理对")]),t._v("这样的代理机制；")]),t._v(" "),s("li",[s("code",[t._v("UTF-8")]),t._v("需要判断每个字节中的开头标志信息，所以如果某个字节在传送过程中出错了，就会导致后面的字节也会解析出错；而"),s("code",[t._v("UTF-16")]),t._v("不会判断开头标志，即使错也只会错一个字符，所以容错能力教强；")]),t._v(" "),s("li",[t._v("如果字符内容全部英文或英文与其他文字混合，但英文占绝大部分，那么用"),s("code",[t._v("UTF-8")]),t._v("就比"),s("code",[t._v("UTF-16")]),t._v("节省了很多空间；而如果字符内容全部是中文这样类似的字符或者混合字符中中文占绝大多数，那么"),s("code",[t._v("UTF-16")]),t._v("就占优势了，可以节省很多空间；")])]),t._v(" "),s("h3",{attrs:{id:"_1-26-常见的位运算符有哪些-其计算规则是什么"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-26-常见的位运算符有哪些-其计算规则是什么"}},[t._v("#")]),t._v(" 1.26 常见的位运算符有哪些？其计算规则是什么？")]),t._v(" "),s("p",[t._v("现代计算机中数据都是以二进制的形式存储的，即0、1两种状态，计算机对二进制数据进行的运算加减乘除等都是叫位运算，即将符号位共同参与运算的运算。")]),t._v(" "),s("p",[t._v("常见的位运算有以下几种：")]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",[t._v("运算符")]),t._v(" "),s("th",[t._v("描述")]),t._v(" "),s("th",[t._v("运算规则")]),t._v(" "),s("th")])]),t._v(" "),s("tbody",[s("tr",[s("td",[s("code",[t._v("&")])]),t._v(" "),s("td",[t._v("与")]),t._v(" "),s("td",[t._v("两个位都为1时，结果才为1")]),t._v(" "),s("td")]),t._v(" "),s("tr",[s("td",[t._v("`")]),t._v(" "),s("td",[t._v("或")]),t._v(" "),s("td",[t._v("两个位都为0时，结果才为0")]),t._v(" "),s("td")]),t._v(" "),s("tr",[s("td",[s("code",[t._v("^")])]),t._v(" "),s("td",[t._v("异或")]),t._v(" "),s("td",[t._v("两个位相同为0，相异为1")]),t._v(" "),s("td")]),t._v(" "),s("tr",[s("td",[s("code",[t._v("~")])]),t._v(" "),s("td",[t._v("取反")]),t._v(" "),s("td",[t._v("0变1，1变0")]),t._v(" "),s("td")]),t._v(" "),s("tr",[s("td",[s("code",[t._v("<<")])]),t._v(" "),s("td",[t._v("左移")]),t._v(" "),s("td",[t._v("各二进制位全部左移若干位，高位丢弃，低位补0")]),t._v(" "),s("td")]),t._v(" "),s("tr",[s("td",[s("code",[t._v(">>")])]),t._v(" "),s("td",[t._v("右移")]),t._v(" "),s("td",[t._v("各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃")]),t._v(" "),s("td")])])]),t._v(" "),s("h3",{attrs:{id:"_1-27-为什么函数的-arguments-参数是类数组而不是数组-如何遍历类数组"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-27-为什么函数的-arguments-参数是类数组而不是数组-如何遍历类数组"}},[t._v("#")]),t._v(" 1.27 为什么函数的 arguments 参数是类数组而不是数组？如何遍历类数组?")]),t._v(" "),s("p",[s("code",[t._v("arguments")]),t._v("是一个对象，它的属性是从 0 开始依次递增的数字，还有"),s("code",[t._v("callee")]),t._v("和"),s("code",[t._v("length")]),t._v("等属性，与数组相似；但是它却没有数组常见的方法属性，如"),s("code",[t._v("forEach")]),t._v(", "),s("code",[t._v("reduce")]),t._v("等，所以叫它们类数组。")]),t._v(" "),s("p",[t._v("要遍历类数组，有三个方法：")]),t._v(" "),s("p",[t._v("（1）将数组的方法应用到类数组上，这时候就可以使用"),s("code",[t._v("call")]),t._v("和"),s("code",[t._v("apply")]),t._v("方法，如：")]),t._v(" "),s("div",{staticClass:"language-javascript line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-javascript"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("foo")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  Array"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("prototype"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("forEach")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("call")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("arguments"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("a")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" console"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("a"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br")])]),s("p",[t._v("（2）使用Array.from方法将类数组转化成数组：‌")]),t._v(" "),s("div",{staticClass:"language-javascript line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-javascript"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("foo")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" arrArgs "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" Array"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("from")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("arguments"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n  arrArgs"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("forEach")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("a")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" console"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("a"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br")])]),s("p",[t._v("（3）使用展开运算符将类数组转化成数组")]),t._v(" "),s("div",{staticClass:"language-javascript line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-javascript"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("foo")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" arrArgs "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("...")]),t._v("arguments"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n    arrArgs"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("forEach")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("a")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" console"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("a"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br")])]),s("h3",{attrs:{id:"_1-28-escape、encodeuri、encodeuricomponent-的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-28-escape、encodeuri、encodeuricomponent-的区别"}},[t._v("#")]),t._v(" 1.28 escape、encodeURI、encodeURIComponent 的区别")]),t._v(" "),s("ul",[s("li",[t._v("encodeURI 是对整个 URI 进行转义，将 URI 中的非法字符转换为合法字符，所以对于一些在 URI 中有特殊意义的字符不会进行转义。")]),t._v(" "),s("li",[t._v("encodeURIComponent 是对 URI 的组成部分进行转义，所以一些特殊字符也会得到转义。")]),t._v(" "),s("li",[t._v("escape 和 encodeURI 的作用相同，不过它们对于 unicode 编码为 0xff 之外字符的时候会有区别，escape 是直接在字符的 unicode 编码前加上 %u，而 encodeURI 首先会将字符转换为 UTF-8 的格式，再在每个字节前加上 %。")])]),t._v(" "),s("h3",{attrs:{id:"_1-29-什么是尾调用-使用尾调用有什么好处"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-29-什么是尾调用-使用尾调用有什么好处"}},[t._v("#")]),t._v(" 1.29 什么是尾调用，使用尾调用有什么好处？")]),t._v(" "),s("p",[t._v("尾调用指的是函数的最后一步调用另一个函数。代码执行是基于执行栈的，所以当在一个函数里调用另一个函数时，会保留当前的执行上下文，然后再新建另外一个执行上下文加入栈中。使用尾调用的话，因为已经是函数的最后一步，所以这时可以不必再保留当前的执行上下文，从而节省了内存，这就是尾调用优化。")]),t._v(" "),s("p",[s("strong",[t._v("但是 ES6 的尾调用优化只在严格模式下开启，正常模式是无效的。")])]),t._v(" "),s("h3",{attrs:{id:"_1-30-use-strict是什么-它有什么用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-30-use-strict是什么-它有什么用"}},[t._v("#")]),t._v(" 1.30 use strict是什么? 它有什么用？")]),t._v(" "),s("p",[t._v("use strict 是一种 ECMAscript5 添加的（严格模式）运行模式，这种模式使得 Javascript 在更严格的条件下运行。设立严格模式的目的如下：")]),t._v(" "),s("ul",[s("li",[t._v("消除 Javascript 语法的不合理、不严谨之处，减少怪异行为;")]),t._v(" "),s("li",[t._v("消除代码运行的不安全之处，保证代码运行的安全；")]),t._v(" "),s("li",[t._v("提高编译器效率，增加运行速度；")]),t._v(" "),s("li",[t._v("为未来新版本的 Javascript 做好铺垫。")])]),t._v(" "),s("p",[t._v("区别：")]),t._v(" "),s("ul",[s("li",[t._v("禁止使用 with 语句。")]),t._v(" "),s("li",[t._v("禁止 this 关键字指向全局对象。")]),t._v(" "),s("li",[t._v("对象不能有重名的属性。")])]),t._v(" "),s("h3",{attrs:{id:"_1-31-如何判断一个对象是否属于某个类"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-31-如何判断一个对象是否属于某个类"}},[t._v("#")]),t._v(" 1.31 如何判断一个对象是否属于某个类？")]),t._v(" "),s("ul",[s("li",[t._v("第一种方式，使用 instanceof 运算符来判断构造函数的 prototype 属性是否出现在对象的原型链中的任何位置。")]),t._v(" "),s("li",[t._v("第二种方式，通过对象的 constructor 属性来判断，对象的 constructor 属性指向该对象的构造函数，但是这种方式不是很安全，因为 constructor 属性可以被改写。")]),t._v(" "),s("li",[t._v("第三种方式，如果需要判断的是某个内置的引用类型的话，可以使用 Object.prototype.toString() 方法来打印对象的[[Class]] 属性来进行判断。")])]),t._v(" "),s("h3",{attrs:{id:"_1-32-强类型语言和弱类型语言的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-32-强类型语言和弱类型语言的区别"}},[t._v("#")]),t._v(" 1.32 强类型语言和弱类型语言的区别")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("强类型语言")]),t._v("：强类型语言也称为强类型定义语言，是一种总是强制类型定义的语言，要求变量的使用要严格符合定义，所有变量都必须先定义后使用。Java和C++等语言都是强制类型定义的，也就是说，一旦一个变量被指定了某个数据类型，如果不经过强制转换，那么它就永远是这个数据类型了。例如你有一个整数，如果不显式地进行转换，你不能将其视为一个字符串。")]),t._v(" "),s("li",[s("strong",[t._v("弱类型语言")]),t._v("：弱类型语言也称为弱类型定义语言，与强类型定义相反。JavaScript语言就属于弱类型语言。简单理解就是一种变量类型可以被忽略的语言。比如JavaScript是弱类型定义的，在JavaScript中就可以将字符串'12'和整数3进行连接得到字符串'123'，在相加的时候会进行强制类型转换。")])]),t._v(" "),s("p",[t._v("两者对比：强类型语言在速度上可能略逊色于弱类型语言，但是强类型语言带来的严谨性可以有效地帮助避免许多错误。")]),t._v(" "),s("h3",{attrs:{id:"_1-33-解释性语言和编译型语言的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-33-解释性语言和编译型语言的区别"}},[t._v("#")]),t._v(" 1.33 解释性语言和编译型语言的区别")]),t._v(" "),s("p",[t._v("（1）解释型语言 使用专门的解释器对源程序逐行解释成特定平台的机器码并立即执行。是代码在执行时才被解释器一行行动态翻译和执行，而不是在执行之前就完成翻译。解释型语言不需要事先编译，其直接将源代码解释成机器码并立即执行，所以只要某一平台提供了相应的解释器即可运行该程序。其特点总结如下")]),t._v(" "),s("ul",[s("li",[t._v("解释型语言每次运行都需要将源代码解释称机器码并执行，效率较低；")]),t._v(" "),s("li",[t._v("只要平台提供相应的解释器，就可以运行源代码，所以可以方便源程序移植；")]),t._v(" "),s("li",[t._v("JavaScript、Python等属于解释型语言。")])]),t._v(" "),s("p",[t._v("（2）编译型语言 使用专门的编译器，针对特定的平台，将高级语言源代码一次性的编译成可被该平台硬件执行的机器码，并包装成该平台所能识别的可执行性程序的格式。在编译型语言写的程序执行之前，需要一个专门的编译过程，把源代码编译成机器语言的文件，如exe格式的文件，以后要再运行时，直接使用编译结果即可，如直接运行exe文件。因为只需编译一次，以后运行时不需要编译，所以编译型语言执行效率高。其特点总结如下：")]),t._v(" "),s("ul",[s("li",[t._v("一次性的编译成平台相关的机器语言文件，运行时脱离开发环境，运行效率高；")]),t._v(" "),s("li",[t._v("与特定平台相关，一般无法移植到其他平台；")]),t._v(" "),s("li",[t._v("C、C++等属于编译型语言。")])]),t._v(" "),s("p",[s("strong",[t._v("两者主要区别在于：")]),t._v(" 后者源程序编译后即可在该平台运行，前者是在运行期间才编译。所以后者运行速度快，前者跨平台性好。")]),t._v(" "),s("h3",{attrs:{id:"_1-34-for-in和for-of的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-34-for-in和for-of的区别"}},[t._v("#")]),t._v(" 1.34 for...in和for...of的区别")]),t._v(" "),s("p",[t._v("for…of 是ES6新增的遍历方式，允许遍历一个含有iterator接口的数据结构（数组、对象等）并且返回各项的值，和ES3中的for…in的区别如下")]),t._v(" "),s("ul",[s("li",[t._v("for…of 遍历获取的是对象的键值，for…in 获取的是对象的键名；")]),t._v(" "),s("li",[t._v("for… in 会遍历对象的整个原型链，性能非常差不推荐使用，而 for … of 只遍历当前对象不会遍历原型链；")]),t._v(" "),s("li",[t._v("对于数组的遍历，for…in 会返回数组中所有可枚举的属性(包括原型链上可枚举的属性)，for…of 只返回数组的下标对应的属性值；")])]),t._v(" "),s("p",[s("strong",[t._v("总结：")]),t._v(" for...in 循环主要是为了遍历对象而生，不适用于遍历数组；for...of 循环可以用来遍历数组、类数组对象，字符串、Set、Map 以及 Generator 对象。")]),t._v(" "),s("h3",{attrs:{id:"_1-35-ajax、axios、fetch的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-35-ajax、axios、fetch的区别"}},[t._v("#")]),t._v(" 1.35 ajax、axios、fetch的区别")]),t._v(" "),s("p",[s("strong",[t._v("（1）AJAX")]),t._v(" Ajax 即“AsynchronousJavascriptAndXML”（异步 JavaScript 和 XML），是指一种创建交互式网页应用的网页开发技术。它是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。通过在后台与服务器进行少量数据交换，Ajax 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。传统的网页（不使用 Ajax）如果需要更新内容，必须重载整个网页页面。其缺点如下：")]),t._v(" "),s("ul",[s("li",[t._v("本身是针对MVC编程，不符合前端MVVM的浪潮")]),t._v(" "),s("li",[t._v("基于原生XHR开发，XHR本身的架构不清晰")]),t._v(" "),s("li",[t._v("不符合关注分离（Separation of Concerns）的原则")]),t._v(" "),s("li",[t._v("配置和调用方式非常混乱，而且基于事件的异步模型不友好。")])]),t._v(" "),s("p",[s("strong",[t._v("（2）Fetch")]),t._v(" fetch号称是AJAX的替代品，是在ES6出现的，使用了ES6中的promise对象。Fetch是基于promise设计的。Fetch的代码结构比起ajax简单多。"),s("strong",[t._v("fetch不是ajax的进一步封装，而是原生js，没有使用XMLHttpRequest对象")]),t._v("。")]),t._v(" "),s("p",[t._v("fetch的优点：")]),t._v(" "),s("ul",[s("li",[t._v("语法简洁，更加语义化")]),t._v(" "),s("li",[t._v("基于标准 Promise 实现，支持 async/await")]),t._v(" "),s("li",[t._v("更加底层，提供的API丰富（request, response）")]),t._v(" "),s("li",[t._v("脱离了XHR，是ES规范里新的实现方式")])]),t._v(" "),s("p",[t._v("fetch的缺点：")]),t._v(" "),s("ul",[s("li",[t._v("fetch只对网络请求报错，对400，500都当做成功的请求，服务器返回 400，500 错误码时并不会 reject，只有网络错误这些导致请求不能完成时，fetch 才会被 reject。")]),t._v(" "),s("li",[t._v("fetch默认不会带cookie，需要添加配置项： fetch(url, {credentials: 'include'})")]),t._v(" "),s("li",[t._v("fetch不支持abort，不支持超时控制，使用setTimeout及Promise.reject的实现的超时控制并不能阻止请求过程继续在后台运行，造成了流量的浪费")]),t._v(" "),s("li",[t._v("fetch没有办法原生监测请求的进度，而XHR可以")])]),t._v(" "),s("p",[s("strong",[t._v("（3）Axios")]),t._v(" Axios 是一种基于Promise封装的HTTP客户端，其特点如下：")]),t._v(" "),s("ul",[s("li",[t._v("浏览器端发起XMLHttpRequests请求")]),t._v(" "),s("li",[t._v("node端发起http请求")]),t._v(" "),s("li",[t._v("支持Promise API")]),t._v(" "),s("li",[t._v("监听请求和返回")]),t._v(" "),s("li",[t._v("对请求和返回进行转化")]),t._v(" "),s("li",[t._v("取消请求")]),t._v(" "),s("li",[t._v("自动转换json数据")]),t._v(" "),s("li",[t._v("客户端支持抵御XSRF攻击")])]),t._v(" "),s("h3",{attrs:{id:"_1-36-数组的遍历方法有哪些"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-36-数组的遍历方法有哪些"}},[t._v("#")]),t._v(" 1.36 数组的遍历方法有哪些")]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",[s("strong",[t._v("方法")])]),t._v(" "),s("th",[s("strong",[t._v("是否改变原数组")])]),t._v(" "),s("th",[s("strong",[t._v("特点")])])])]),t._v(" "),s("tbody",[s("tr",[s("td",[t._v("forEach()")]),t._v(" "),s("td",[t._v("否")]),t._v(" "),s("td",[t._v("数组方法，不改变原数组的长度，没有返回值")])]),t._v(" "),s("tr",[s("td",[t._v("map()")]),t._v(" "),s("td",[t._v("否")]),t._v(" "),s("td",[t._v("数组方法，不改变原数组的长度，有返回值，可链式调用")])]),t._v(" "),s("tr",[s("td",[t._v("filter()")]),t._v(" "),s("td",[t._v("否")]),t._v(" "),s("td",[t._v("数组方法，过滤数组，返回包含符合条件的元素的数组，可链式调用")])]),t._v(" "),s("tr",[s("td",[t._v("for...of")]),t._v(" "),s("td",[t._v("否")]),t._v(" "),s("td",[t._v("for...of遍历具有Iterator迭代器的对象的属性，返回的是数组的元素、对象的属性值，不能遍历普通的obj对象，将异步循环变成同步循环")])]),t._v(" "),s("tr",[s("td",[t._v("every() 和 some()")]),t._v(" "),s("td",[t._v("否")]),t._v(" "),s("td",[t._v("数组方法，some()只要有一个是true，便返回true；而every()只要有一个是false，便返回false.")])]),t._v(" "),s("tr",[s("td",[t._v("find() 和 findIndex()")]),t._v(" "),s("td",[t._v("否")]),t._v(" "),s("td",[t._v("数组方法，find()返回的是第一个符合条件的值；findIndex()返回的是第一个返回条件的值的索引值")])]),t._v(" "),s("tr",[s("td",[t._v("reduce() 和 reduceRight()")]),t._v(" "),s("td",[t._v("否")]),t._v(" "),s("td",[t._v("数组方法，reduce()对数组正序操作；reduceRight()对数组逆序操作")])])])]),t._v(" "),s("h3",{attrs:{id:"_1-37-foreach和map方法有什么区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-37-foreach和map方法有什么区别"}},[t._v("#")]),t._v(" 1.37 forEach和map方法有什么区别")]),t._v(" "),s("p",[t._v("这方法都是用来遍历数组的，两者区别如下：")]),t._v(" "),s("ul",[s("li",[t._v("forEach()方法会针对每一个元素执行提供的函数，如果遍历的元素是引用数据类型，则可以改变指针指向的堆内存里的值，该方法没有返回值；")]),t._v(" "),s("li",[t._v("map()方法返回一个新数组，新数组中的值为原数组调用函数处理之后的值，如果遍历的元素是引用数据类型，则可以改变指针指向的堆内存里的值")])]),t._v(" "),s("h3",{attrs:{id:"_1-38-说说你对浅拷贝和深拷贝的理解"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-38-说说你对浅拷贝和深拷贝的理解"}},[t._v("#")]),t._v(" 1.38 说说你对浅拷贝和深拷贝的理解")]),t._v(" "),s("p",[s("strong",[t._v("浅拷贝")])]),t._v(" "),s("ul",[s("li",[t._v("浅拷贝，指的是创建新的数据，这个数据有着原始数据属性值的一份精确拷贝")]),t._v(" "),s("li",[t._v("如果属性是基本类型，拷贝的就是基本类型的值。如果属性是引用类型，拷贝的就是内存地址")]),t._v(" "),s("li",[t._v("即浅拷贝是拷贝一层，深层次的引用类型则共享内存地址")])]),t._v(" "),s("p",[t._v("常见的浅拷贝：")]),t._v(" "),s("ul",[s("li",[t._v("Object.assign")]),t._v(" "),s("li",[t._v("Object.create")]),t._v(" "),s("li",[t._v("slice")]),t._v(" "),s("li",[t._v("concat()")]),t._v(" "),s("li",[t._v("展开运算符")])]),t._v(" "),s("p",[s("strong",[t._v("深拷贝")])]),t._v(" "),s("p",[t._v("深拷贝开辟一个新的栈，两个对象属完成相同，但是对应两个不同的地址，修改一个对象的属性，不会改变另一个对象的属性")]),t._v(" "),s("p",[t._v("常见的深拷贝方式有：")]),t._v(" "),s("ul",[s("li",[t._v("_.cloneDeep()")]),t._v(" "),s("li",[t._v("jQuery.extend()")]),t._v(" "),s("li",[t._v("JSON.stringify()")]),t._v(" "),s("li",[t._v("手写循环递归")])]),t._v(" "),s("h3",{attrs:{id:"_1-39-json-stringify深拷贝的缺点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-39-json-stringify深拷贝的缺点"}},[t._v("#")]),t._v(" 1.39 JSON.stringify深拷贝的缺点")]),t._v(" "),s("ul",[s("li",[t._v("如果obj里面有时间对象，则JSON.stringify后再JSON.parse的结果，时间将只是字符串的形式，而不是对象的形式")]),t._v(" "),s("li",[t._v("如果obj里面有RegExp，则打印出来是空对象")]),t._v(" "),s("li",[t._v("如果对象中有函数或者undefined，则会直接被丢掉")]),t._v(" "),s("li",[t._v("如果json里有对象是由构造函数生成的，则会丢掉对象的constructon")])]),t._v(" "),s("h3",{attrs:{id:"_1-40-知道lodash吗-它有哪些常见的api"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-40-知道lodash吗-它有哪些常见的api"}},[t._v("#")]),t._v(" 1.40 知道lodash吗？它有哪些常见的API ？")]),t._v(" "),s("p",[t._v("Lodash是一个一致性、模块化、高性能的 JavaScript 实用工具库。")]),t._v(" "),s("ul",[s("li",[t._v("_.cloneDeep 深度拷贝")]),t._v(" "),s("li",[t._v("_.reject 根据条件去除某个元素。")]),t._v(" "),s("li",[t._v("_.drop(array, [n=1] ) 作用：将 "),s("code",[t._v("array")]),t._v(" 中的前 "),s("code",[t._v("n")]),t._v(" 个元素去掉，然后返回剩余的部分.")])]),t._v(" "),s("h3",{attrs:{id:"_1-41-lhs-和-rhs-查询"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-41-lhs-和-rhs-查询"}},[t._v("#")]),t._v(" 1.41 LHS 和 RHS 查询")]),t._v(" "),s("p",[s("code",[t._v("LHS (Left-hand Side)")]),t._v(" 和 "),s("code",[t._v("RHS (Right-hand Side)")]),t._v(" ，是在代码执行阶段 JS 引擎操作变量的两种方式，二者区别就是对变量的查询目的是 "),s("strong",[t._v("变量赋值")]),t._v(" 还是 "),s("strong",[t._v("查询")]),t._v(" 。")]),t._v(" "),s("p",[s("strong",[t._v("LHS")]),t._v(" 可以理解为变量在赋值操作符"),s("code",[t._v("(=)")]),t._v("的左侧，例如 "),s("code",[t._v("a = 1")]),t._v("，当前引擎对变量 "),s("code",[t._v("a")]),t._v(" 查找的目的是"),s("strong",[t._v("变量赋值")]),t._v("。这种情况下，引擎不关心变量 "),s("code",[t._v("a")]),t._v(" 原始值是什么，只管将值 "),s("code",[t._v("1")]),t._v(" 赋给 "),s("code",[t._v("a")]),t._v(" 变量。")]),t._v(" "),s("p",[s("strong",[t._v("RHS")]),t._v(" 可以理解为变量在赋值操作符"),s("code",[t._v("(=)")]),t._v("的右侧，例如："),s("code",[t._v("console.log(a)")]),t._v("，其中引擎对变量"),s("code",[t._v("a")]),t._v("的查找目的就是 "),s("strong",[t._v("查询")]),t._v("，它需要找到变量 "),s("code",[t._v("a")]),t._v(" 对应的实际值是什么，然后才能将它打印出来。")]),t._v(" "),s("h3",{attrs:{id:"_1-42-includes-比-indexof好在哪"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-42-includes-比-indexof好在哪"}},[t._v("#")]),t._v(" 1.42 includes 比 indexOf好在哪？")]),t._v(" "),s("p",[t._v("includes可以检测"),s("code",[t._v("NaN")]),t._v("，indexOf不能检测"),s("code",[t._v("NaN")]),t._v("，includes内部使用了"),s("code",[t._v("Number.isNaN")]),t._v("对"),s("code",[t._v("NaN")]),t._v("进行了匹配")]),t._v(" "),s("h3",{attrs:{id:"_1-43-amd-和-cmd-的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-43-amd-和-cmd-的区别"}},[t._v("#")]),t._v(" 1.43 AMD 和 CMD 的区别？")]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",[t._v("模块化")]),t._v(" "),s("th",[t._v("代表应用")]),t._v(" "),s("th",[t._v("特点")])])]),t._v(" "),s("tbody",[s("tr",[s("td",[t._v("AMD")]),t._v(" "),s("td",[t._v("require.js")]),t._v(" "),s("td",[t._v("1、AMD的api默认一个当多个用 2、依赖前置，异步执行")])]),t._v(" "),s("tr",[s("td",[t._v("CMD")]),t._v(" "),s("td",[t._v("sea.js")]),t._v(" "),s("td",[t._v("1、CMD的api严格区分，推崇职责单一 2、依赖就近，按需加载，同步执行")])])])]),t._v(" "),s("h3",{attrs:{id:"_1-44-a-1-a-2-a-3-有可能是-true-吗"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-44-a-1-a-2-a-3-有可能是-true-吗"}},[t._v("#")]),t._v(" 1.44 (a == 1 && a == 2 && a == 3) 有可能是 true 吗？")]),t._v(" "),s("p",[s("strong",[t._v("方案一：重写toString()或valueOf()")])]),t._v(" "),s("div",{staticClass:"language-css line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-css"}},[s("code",[s("span",{pre:!0,attrs:{class:"token selector"}},[t._v("let a =")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token selector"}},[t._v("i: 1,\n    toString: function ()")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        return a.i++"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\nconsole."),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("a == 1 && a == 2 && a == 3"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" // true\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br")])]),s("p",[s("strong",[t._v("方案二：数组")])]),t._v(" "),s("p",[t._v("数组的toString接口默认调用数组的join方法，重写join方法。定义a为数字，每次比较时就会调用 toString()方法，我们把数组的shift方法覆盖toString即可：")]),t._v(" "),s("div",{staticClass:"language-ini line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-ini"}},[s("code",[s("span",{pre:!0,attrs:{class:"token key attr-name"}},[t._v("let a")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token value attr-value"}},[t._v("[1,2,3];")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token key attr-name"}},[t._v("a.toString")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token value attr-value"}},[t._v("a.shift;")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token key attr-name"}},[t._v("console.log(a")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token value attr-value"}},[t._v("= 1 && a == 2 && a == 3); // true")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br")])]),s("p",[t._v("当然把toString改为valueOf也是一样效果：")]),t._v(" "),s("div",{staticClass:"language-ini line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-ini"}},[s("code",[s("span",{pre:!0,attrs:{class:"token key attr-name"}},[t._v("let a")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token value attr-value"}},[t._v("[1,2,3];")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token key attr-name"}},[t._v("a. valueOf")]),t._v("  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token value attr-value"}},[t._v("a.shift;")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token key attr-name"}},[t._v("console.log(a")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token value attr-value"}},[t._v("= 1 && a == 2 && a == 3); // true")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br")])]),s("p",[s("strong",[t._v("方案三：使用Object.defineProperty()")])]),t._v(" "),s("p",[t._v("Object.defineProperty()用于定义对象中的属性，接收三个参数：object对象、对象中的属性，属性描述符。属性描述符中get:访问该属性时自动调用。")]),t._v(" "),s("div",{staticClass:"language-javascript line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-javascript"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v("  _a "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nObject"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("defineProperty")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'a'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("get")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" _a"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\nconsole"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("a"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("===")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&&")]),t._v(" a"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("===")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&&")]),t._v(" a"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("===")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//true")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br")])]),s("h3",{attrs:{id:"_1-45-js中的-mul-函数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-45-js中的-mul-函数"}},[t._v("#")]),t._v(" 1.45 JS中的 MUL 函数")]),t._v(" "),s("p",[t._v("MUL表示数的简单乘法。在这种技术中，将一个值作为参数传递给一个函数，而该函数将返回另一个函数，将第二个值传递给该函数，然后重复继续。例如:x"),s("em",[t._v("y")]),t._v("z可以表示为")]),t._v(" "),s("div",{staticClass:"language-javascript line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-javascript"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("mul")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("x")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("y")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("z")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" x "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" y "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" z\n​\nconsole"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("mul")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 6")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br")])]),s("h3",{attrs:{id:"_1-46-深度遍历广度遍历的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-46-深度遍历广度遍历的区别"}},[t._v("#")]),t._v(" 1.46 深度遍历广度遍历的区别？")]),t._v(" "),s("p",[t._v("对于算法来说 无非就是时间换空间 空间换时间")]),t._v(" "),s("ul",[s("li",[t._v("1、深度优先不需要记住所有的节点, 所以占用空间小, 而广度优先需要先记录所有的节点占用空间大")]),t._v(" "),s("li",[t._v("2、深度优先有回溯的操作(没有路走了需要回头)所以相对而言时间会长一点")]),t._v(" "),s("li",[t._v("3、深度优先采用的是"),s("strong",[t._v("堆栈")]),t._v("的形式, 即先进后出")]),t._v(" "),s("li",[t._v("4、广度优先则采用的是"),s("strong",[t._v("队列")]),t._v("的形式, 即先进先出")])]),t._v(" "),s("h3",{attrs:{id:"_1-47-js中的设计模式有哪些"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-47-js中的设计模式有哪些"}},[t._v("#")]),t._v(" 1.47 JS中的设计模式有哪些？")]),t._v(" "),s("h4",{attrs:{id:"单例模式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#单例模式"}},[t._v("#")]),t._v(" "),s("strong",[t._v("单例模式")])]),t._v(" "),s("p",[t._v("保证一个类仅有一个实例，并提供一个访问它的全局访问点。实现的方法为先判断实例存在与否，如果存在则直接返回，如果不存在就创建了再返回，这就确保了一个类只有一个实例对象。")]),t._v(" "),s("h4",{attrs:{id:"策略模式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#策略模式"}},[t._v("#")]),t._v(" "),s("strong",[t._v("策略模式")])]),t._v(" "),s("p",[t._v("定义一系列的算法，把他们一个个封装起来，并且使他们可以相互替换。")]),t._v(" "),s("h4",{attrs:{id:"代理模式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#代理模式"}},[t._v("#")]),t._v(" "),s("strong",[t._v("代理模式")])]),t._v(" "),s("p",[t._v("为一个对象提供一个代用品或占位符，以便控制对它的访问。")]),t._v(" "),s("h4",{attrs:{id:"中介者模式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#中介者模式"}},[t._v("#")]),t._v(" "),s("strong",[t._v("中介者模式")])]),t._v(" "),s("p",[t._v("通过一个中介者对象，其他所有的相关对象都通过该中介者对象来通信，而不是相互引用，当其中的一个对象发生改变时，只需要通知中介者对象即可。通过中介者模式可以解除对象与对象之间的紧耦合关系。")]),t._v(" "),s("h4",{attrs:{id:"装饰者模式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#装饰者模式"}},[t._v("#")]),t._v(" "),s("strong",[t._v("装饰者模式")])]),t._v(" "),s("p",[t._v("在不改变对象自身的基础上，在程序运行期间给对象动态地添加方法。")]),t._v(" "),s("h3",{attrs:{id:"_1-48-foreach如何跳出循环"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-48-foreach如何跳出循环"}},[t._v("#")]),t._v(" 1.48 forEach如何跳出循环？")]),t._v(" "),s("p",[t._v("forEach是不能通过"),s("code",[t._v("break")]),t._v("或者"),s("code",[t._v("return")]),t._v("来实现跳出循环的，为什么呢？实现过forEach的同学应该都知道，forEach的的回调函数形成了一个作用域，在里面使用"),s("code",[t._v("return")]),t._v("并不会跳出，只会被当做"),s("code",[t._v("continue")])]),t._v(" "),s("p",[t._v("可以利用"),s("code",[t._v("try catch")])]),t._v(" "),s("div",{staticClass:"language-javascript line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-javascript"}},[s("code",[t._v("　　"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("getItemById")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("arr"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" id")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" item "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("try")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            arr"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("forEach")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("curItem"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" i")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n                "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("curItem"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("id "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" id"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n                    item "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" curItem"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n                    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("throw")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("Error")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n                "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("catch")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("e"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" item"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br"),s("span",{staticClass:"line-number"},[t._v("10")]),s("br"),s("span",{staticClass:"line-number"},[t._v("11")]),s("br"),s("span",{staticClass:"line-number"},[t._v("12")]),s("br"),s("span",{staticClass:"line-number"},[t._v("13")]),s("br")])]),s("h3",{attrs:{id:"_1-49-js中如何将页面重定向到另一个页面"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-49-js中如何将页面重定向到另一个页面"}},[t._v("#")]),t._v(" 1.49 JS中如何将页面重定向到另一个页面？")]),t._v(" "),s("p",[t._v('1、使用 location.href：window.location.href ="url"')]),t._v(" "),s("p",[t._v('2、使用 location.replace： window.location.replace("url");')]),t._v(" "),s("h3",{attrs:{id:"_1-50-移动端如何实现上拉加载-下拉刷新"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-50-移动端如何实现上拉加载-下拉刷新"}},[t._v("#")]),t._v(" 1.50 移动端如何实现上拉加载，下拉刷新？")]),t._v(" "),s("p",[s("strong",[t._v("上拉加载")])]),t._v(" "),s("p",[t._v("上拉加载的本质是页面触底，或者快要触底时的动作")]),t._v(" "),s("p",[t._v("判断页面触底我们需要先了解一下下面几个属性")]),t._v(" "),s("ul",[s("li",[s("code",[t._v("scrollTop")]),t._v("：滚动视窗的高度距离"),s("code",[t._v("window")]),t._v("顶部的距离，它会随着往上滚动而不断增加，初始值是0，它是一个变化的值")]),t._v(" "),s("li",[s("code",[t._v("clientHeight")]),t._v(":它是一个定值，表示屏幕可视区域的高度；")]),t._v(" "),s("li",[s("code",[t._v("scrollHeight")]),t._v("：页面不能滚动时也是存在的,此时scrollHeight等于clientHeight。scrollHeight表示"),s("code",[t._v("body")]),t._v("所有元素的总长度(包括body元素自身的padding)")])]),t._v(" "),s("p",[t._v("综上我们得出一个触底公式：")]),t._v(" "),s("div",{staticClass:"language-auto line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("scrollTop + clientHeight >= scrollHeight\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])]),s("p",[s("strong",[t._v("下拉刷新")])]),t._v(" "),s("p",[t._v("下拉刷新的本质是页面本身置于顶部时，用户下拉时需要触发的动作")]),t._v(" "),s("p",[t._v("关于下拉刷新的原生实现，主要分成三步：")]),t._v(" "),s("ul",[s("li",[t._v("监听原生"),s("code",[t._v("touchstart")]),t._v("事件，记录其初始位置的值，"),s("code",[t._v("e.touches[0].pageY")]),t._v("；")]),t._v(" "),s("li",[t._v("监听原生"),s("code",[t._v("touchmove")]),t._v("事件，记录并计算当前滑动的位置值与初始位置值的差值，大于"),s("code",[t._v("0")]),t._v("表示向下拉动，并借助CSS3的"),s("code",[t._v("translateY")]),t._v("属性使元素跟随手势向下滑动对应的差值，同时也应设置一个允许滑动的最大值；")]),t._v(" "),s("li",[t._v("监听原生"),s("code",[t._v("touchend")]),t._v("事件，若此时元素滑动达到最大值，则触发"),s("code",[t._v("callback")]),t._v("，同时将"),s("code",[t._v("translateY")]),t._v("重设为"),s("code",[t._v("0")]),t._v("，元素回到初始位置")])]),t._v(" "),s("h3",{attrs:{id:"_1-51-js-中的数组和函数在内存中是如何存储的"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-51-js-中的数组和函数在内存中是如何存储的"}},[t._v("#")]),t._v(" 1.51 JS 中的数组和函数在内存中是如何存储的？")]),t._v(" "),s("p",[t._v("JavaScript 中的数组存储大致需要分为两种情况：")]),t._v(" "),s("ul",[s("li",[t._v("同种类型数据的数组分配连续的内存空间")]),t._v(" "),s("li",[t._v("存在非同种类型数据的数组使用哈希映射分配内存空间")])]),t._v(" "),s("blockquote",[s("p",[t._v("温馨提示：可以想象一下连续的内存空间只需要根据索引（指针）直接计算存储位置即可。如果是哈希映射那么首先需要计算索引值，然后如果索引值有冲突的场景下还需要进行二次查找（需要知道哈希的存储方式）。")])]),t._v(" "),s("h2",{attrs:{id:"二、闭包与作用域"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#二、闭包与作用域"}},[t._v("#")]),t._v(" 二、闭包与作用域")]),t._v(" "),s("h3",{attrs:{id:"_2-1-什么是闭包"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-什么是闭包"}},[t._v("#")]),t._v(" 2.1 什么是闭包？")]),t._v(" "),s("ul",[s("li",[t._v("✅ 官方说法：闭包就是指有权访问另一个函数作用域中的变量的函数。")]),t._v(" "),s("li",[t._v("✅ MDN说法：闭包是一种特殊的对象。它由两部分构成：函数，以及创建该函数的环境。环境由闭包创建时在作用域中的任何局部变量组成。")])]),t._v(" "),s("p",[s("strong",[t._v("深度回答")])]),t._v(" "),s("p",[t._v("浏览器在加载页面会把代码放在栈内存（ ECStack ）中执行，函数进栈执行会产生一个私有上下文（ EC ），此上下文能保护里面的使用变量（ AO ）不受外界干扰，并且如果当前执行上下文中的某些内容，被上下文以外的内容占用，当前上下文不会出栈释放，这样可以保存里面的变量和变量值，所以我认为闭包是一种保存和保护内部私有变量的机制。")]),t._v(" "),s("h3",{attrs:{id:"_2-2-闭包的作用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-闭包的作用"}},[t._v("#")]),t._v(" 2.2 闭包的作用")]),t._v(" "),s("p",[t._v("闭包有两个常用的用途；")]),t._v(" "),s("ul",[s("li",[t._v("闭包的第一个用途是使我们在函数外部能够访问到函数内部的变量。通过使用闭包，可以通过在外部调用闭包函数，从而在外部访问到函数内部的变量，可以使用这种方法来"),s("strong",[t._v("创建私有变量")]),t._v("。")]),t._v(" "),s("li",[t._v("闭包的另一个用途是使已经运行结束的函数上下文中的"),s("strong",[t._v("变量对象继续留在内存中")]),t._v("，因为闭包函数保留了这个变量对象的引用，所以这个变量对象不会被回收。")])]),t._v(" "),s("h3",{attrs:{id:"_2-3-闭包在项目中的引用场景-以及带来的问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-闭包在项目中的引用场景-以及带来的问题"}},[t._v("#")]),t._v(" 2.3 闭包在项目中的引用场景，以及带来的问题")]),t._v(" "),s("p",[t._v("在实际的项目中，会基于闭包把自己编写的模块内容包裹起来，这样编写就可以保护自己的代码是私有的，防止和全局变量或者是其他的代码冲突，这一点是利用保护机制。")]),t._v(" "),s("p",[t._v("但是不建议过多的使用闭包，因为使用不被释放的上下文，是占用栈内存空间的，过多的使用会导致导致内存泄漏。")]),t._v(" "),s("p",[t._v("解决闭包带来的内存泄漏问题的方法是：使用完闭包函数后手动释放。")]),t._v(" "),s("h3",{attrs:{id:"_2-4-闭包的使用场景"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-4-闭包的使用场景"}},[t._v("#")]),t._v(" 2.4 闭包的使用场景")]),t._v(" "),s("ol",[s("li",[s("code",[t._v("return")]),t._v(" 回一个函数")]),t._v(" "),s("li",[t._v("函数作为参数")]),t._v(" "),s("li",[t._v("IIFE（自执行函数）")]),t._v(" "),s("li",[t._v("循环赋值")]),t._v(" "),s("li",[t._v("使用回调函数就是在使用闭包")]),t._v(" "),s("li",[t._v("节流防抖")]),t._v(" "),s("li",[t._v("函数柯里化")])]),t._v(" "),s("h3",{attrs:{id:"_2-5-闭包的执行过程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-5-闭包的执行过程"}},[t._v("#")]),t._v(" 2.5 闭包的执行过程")]),t._v(" "),s("ol",[s("li",[s("p",[t._v("形成私有上下文")])]),t._v(" "),s("li",[s("p",[t._v("进栈执行")])]),t._v(" "),s("li",[s("p",[t._v("一系列操作")]),t._v(" "),s("p",[t._v("(1). 初始化作用域链（两头<当前作用域，上级作用域>）")]),t._v(" "),s("p",[t._v("(2). 初始化this")]),t._v(" "),s("p",[t._v("(3). 初始化arguments")]),t._v(" "),s("p",[t._v("(4). 赋值形参")]),t._v(" "),s("p",[t._v("(5). 变量提升")]),t._v(" "),s("p",[t._v("(6). 代码执行")]),t._v(" "),s("ul",[s("li",[t._v("遇到变量就先看是否是自己私有的，不是自己私有的按照作用域链上查找，如果不是上级的就继续线上查找，，直到 EC(G)，变量的查找其实就是一个作用域链的拼接过程，拼接查询的链式就是作用域链。")])])]),t._v(" "),s("li",[s("p",[t._v("正常情况下，代码执行完成之后，私有上下文出栈被回收。但是遇到特殊情况，如果当前私有上下文执行完成之后中的某个东西被执行上下文以外的东西占用，则当前私有上下文就不会出栈释放，也就是形成了不被销毁的上下文，闭包。")])])]),t._v(" "),s("h3",{attrs:{id:"_2-6-执行上下文的类型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-6-执行上下文的类型"}},[t._v("#")]),t._v(" 2.6 执行上下文的类型")]),t._v(" "),s("p",[s("strong",[t._v("（1）全局执行上下文")])]),t._v(" "),s("p",[t._v("任何不在函数内部的都是全局执行上下文，它首先会创建一个全局的window对象，并且设置this的值等于这个全局对象，一个程序中只有一个全局执行上下文。")]),t._v(" "),s("p",[s("strong",[t._v("（2）函数执行上下文")])]),t._v(" "),s("p",[t._v("当一个函数被调用时，就会为该函数创建一个新的执行上下文，函数的上下文可以有任意多个。")]),t._v(" "),s("p",[s("strong",[t._v("（3）")]),t._v(" "),s("code",[t._v("eval")]),s("strong",[t._v("函数执行上下文")])]),t._v(" "),s("p",[t._v("执行在eval函数中的代码会有属于他自己的执行上下文，不过eval函数不常使用，不做介绍。")]),t._v(" "),s("h3",{attrs:{id:"_2-7-执行上下文栈是什么"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-7-执行上下文栈是什么"}},[t._v("#")]),t._v(" 2.7 执行上下文栈是什么")]),t._v(" "),s("ul",[s("li",[t._v("JavaScript引擎使用执行上下文栈来管理执行上下文")]),t._v(" "),s("li",[t._v("当JavaScript执行代码时，首先遇到全局代码，会创建一个全局执行上下文并且压入执行栈中，每当遇到一个函数调用，就会为该函数创建一个新的执行上下文并压入栈顶，引擎会执行位于执行上下文栈顶的函数，当函数执行完成之后，执行上下文从栈中弹出，继续执行下一个上下文。当所有的代码都执行完毕之后，从栈中弹出全局执行上下文。")])]),t._v(" "),s("h3",{attrs:{id:"_2-8-执行上下文的三个阶段"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-8-执行上下文的三个阶段"}},[t._v("#")]),t._v(" 2.8 执行上下文的三个阶段")]),t._v(" "),s("p",[s("strong",[t._v("创建阶段 → 执行阶段 → 回收阶段")])]),t._v(" "),s("hr"),t._v(" "),s("p",[s("strong",[t._v("创建阶段")])]),t._v(" "),s("p",[t._v("（1）this绑定")]),t._v(" "),s("ul",[s("li",[t._v("在全局执行上下文中，this指向全局对象（window对象）")]),t._v(" "),s("li",[t._v("在函数执行上下文中，this指向取决于函数如何调用。如果它被一个引用对象调用，那么 this 会被设置成那个对象，否则 this 的值被设置为全局对象或者 undefined")])]),t._v(" "),s("p",[t._v("（2）创建词法环境组件")]),t._v(" "),s("ul",[s("li",[t._v("词法环境是一种有"),s("strong",[t._v("标识符——变量映射")]),t._v("的数据结构，标识符是指变量/函数名，变量是对实际对象或原始数据的引用。")]),t._v(" "),s("li",[t._v("词法环境的内部有两个组件："),s("strong",[t._v("加粗样式")]),t._v("：环境记录器:用来储存变量个函数声明的实际位置"),s("strong",[t._v("外部环境的引用")]),t._v("：可以访问父级作用域")])]),t._v(" "),s("p",[t._v("（3）创建变量环境组件")]),t._v(" "),s("ul",[s("li",[t._v("变量环境也是一个词法环境，其环境记录器持有变量声明语句在执行上下文中创建的绑定关系。")])]),t._v(" "),s("p",[s("strong",[t._v("执行阶段")])]),t._v(" "),s("p",[t._v("在这阶段，执行变量赋值、代码执行")]),t._v(" "),s("p",[t._v("如果 "),s("code",[t._v("Javascript")]),t._v(" 引擎在源代码中声明的实际位置找不到变量的值，那么将为其分配 "),s("code",[t._v("undefined")]),t._v(" 值")]),t._v(" "),s("p",[s("strong",[t._v("回收阶段")])]),t._v(" "),s("p",[t._v("执行上下文出栈等待虚拟机回收执行上下文")]),t._v(" "),s("h3",{attrs:{id:"_2-9-谈谈你对作用域的理解"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-9-谈谈你对作用域的理解"}},[t._v("#")]),t._v(" 2.9 谈谈你对作用域的理解")]),t._v(" "),s("ul",[s("li",[t._v("作用域可以视为一套规则，这套规则用来管理引擎如何在当前作用域以及嵌套的子作用域根据标识符名称进行变量查找。")]),t._v(" "),s("li",[t._v("简单来说作用域就是变量的有效范围。在一定的空间里可以对变量数据进行读写操作，这个空间就是变量的作用域。")])]),t._v(" "),s("h4",{attrs:{id:"_1-全局作用域"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-全局作用域"}},[t._v("#")]),t._v(" （1）全局作用域")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("直接写在script标签的JS代码，都在全局作用域。在全局作用域下声明的变量叫做全局变量（在块级外部定义的变量）。")])]),t._v(" "),s("li",[s("p",[t._v("全局变量在全局的任何位置下都可以使用；全局作用域中无法访问到局部作用域的中的变量。")])]),t._v(" "),s("li",[s("p",[t._v("全局作用域在页面打开的时候创建，在页面关闭时销毁。")])]),t._v(" "),s("li",[s("p",[s("strong",[t._v("所有 window 对象的属性拥有全局作用域")])]),t._v(" "),s("p",[s("em",[t._v("var和function命令声明的全局变量和函数是window对象的属性和方法")])]),t._v(" "),s("p",[t._v("let命令、const命令、class命令声明的全局变量，不属于window对象的属性")])])]),t._v(" "),s("h4",{attrs:{id:"_2-函数作用域-局部作用域"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-函数作用域-局部作用域"}},[t._v("#")]),t._v(" （2）函数作用域(局部作用域)")]),t._v(" "),s("ul",[s("li",[t._v("调用函数时会创建函数作用域，函数执行完毕以后，作用域销毁。每调用一次函数就会创建一个新的函数作用域，他们之间是相互独立的。")]),t._v(" "),s("li",[t._v("在函数作用域中可以访问全局变量，在函数的外面无法访问函数内的变量。")]),t._v(" "),s("li",[t._v("当在函数作用域操作一个变量时，它会先在自身作用域中寻找，如果有就直接使用，如果没有就向上一作用域中寻找，直到找到全局作用域，如果全局作用域中仍然没有找到，则会报错。")])]),t._v(" "),s("h4",{attrs:{id:"_3-块级作用域"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-块级作用域"}},[t._v("#")]),t._v(" （3）块级作用域")]),t._v(" "),s("ul",[s("li",[t._v("ES6之前JavaScript采用的是函数作用域+词法作用域，ES6引入了块级作用域。")]),t._v(" "),s("li",[t._v("任何一对花括号{}中的语句集都属于一个块,"),s("strong",[t._v("在块中使用let和const声明的变量")]),t._v("，外部是访问不到的，这种作用域的规则就叫块级作用域。")]),t._v(" "),s("li",[t._v("通过var声明的变量或者非严格模式下创建的函数声明没有块级作用域。")])]),t._v(" "),s("h4",{attrs:{id:"_4-词法作用域"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-词法作用域"}},[t._v("#")]),t._v(" （4）词法作用域")]),t._v(" "),s("ul",[s("li",[t._v("词法作用域是静态的作用域，无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由"),s("strong",[t._v("函数被声明时所处的位置")]),t._v("决定。")]),t._v(" "),s("li",[t._v("编译的词法分析阶段基本能够知道全部标识符在哪里以及是如何声明的，从而能够预测在执行过中如何对它们进行查找。")]),t._v(" "),s("li",[t._v("换句话说，词法作用域就是你在写代码的时候就已经决定了变量的作用域。")])]),t._v(" "),s("h3",{attrs:{id:"_2-10-什么是作用域链"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-10-什么是作用域链"}},[t._v("#")]),t._v(" 2.10 什么是作用域链")]),t._v(" "),s("p",[t._v("当在"),s("code",[t._v("js")]),t._v("中使用一个变量的时候，首先"),s("code",[t._v("js")]),t._v("引擎会尝试在当前作用域下去寻找该变量，如果没找到，再到它的上层作用域寻找，以此类推直到找到该变量或是已经到了全局作用域，这样的变量作用域访问的链式结构, 被称之为作用域链")]),t._v(" "),s("p",[s("strong",[t._v("深度回答")])]),t._v(" "),s("p",[t._v("作用域链的本质上是一个指向变量对象的指针列表。变量对象是一个包含了执行环境中所有变量和函数的对象。作用域链的前端始终都是当前执行上下文的变量对象。全局执行上下文的变量对象（也就是全局对象）始终是作用域链的最后一个对象。")]),t._v(" "),s("h3",{attrs:{id:"_2-11-作用域链的作用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-11-作用域链的作用"}},[t._v("#")]),t._v(" 2.11 作用域链的作用")]),t._v(" "),s("p",[t._v("作用域链的作用是"),s("strong",[t._v("保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，可以访问到外层环境的变量和函数。")])]),t._v(" "),s("h3",{attrs:{id:"_2-12-作用域的常见应用场景"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-12-作用域的常见应用场景"}},[t._v("#")]),t._v(" 2.12 作用域的常见应用场景")]),t._v(" "),s("p",[t._v("作用域的一个常见运用场景之一，就是 "),s("strong",[t._v("模块化")]),t._v("。")]),t._v(" "),s("p",[t._v("由于 javascript 并未原生支持模块化导致了很多令人口吐芬芳的问题，比如全局作用域污染和变量名冲突，代码结构臃肿且复用性不高。在正式的模块化方案出台之前，开发者为了解决这类问题，想到了使用函数作用域来创建模块的方案。")]),t._v(" "),s("h3",{attrs:{id:"_2-13-说说js中的预解析"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-13-说说js中的预解析"}},[t._v("#")]),t._v(" 2.13 说说Js中的预解析？")]),t._v(" "),s("p",[t._v("JS 引擎在运行一份代码的时候，会按照下面的步骤进行工作：")]),t._v(" "),s("p",[t._v("1.把变量的声明提升到当前作用域的最前面，只会提升声明，不会提升赋值")]),t._v(" "),s("p",[t._v("2.把函数的声明提升到当前作用域的最前面，只会提升声明，不会提升调用")]),t._v(" "),s("p",[t._v("3.先提升 function，在提升 var")]),t._v(" "),s("h3",{attrs:{id:"_2-14-变量提升与函数提升的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-14-变量提升与函数提升的区别"}},[t._v("#")]),t._v(" 2.14 变量提升与函数提升的区别？")]),t._v(" "),s("p",[s("strong",[t._v("变量提升")])]),t._v(" "),s("p",[t._v("简单说就是在 JavaScript 代码执行前引擎会先进行预编译，预编译期间会将"),s("code",[t._v("变量声明与函数声明")]),t._v("提升至其"),s("code",[t._v("对应作用域的最顶端")]),t._v("，"),s("code",[t._v("函数内声明的变量")]),t._v("只会提升至"),s("code",[t._v("该函数作用域最顶层")]),t._v("，"),s("code",[t._v("当函数内部定义的一个变量与外部相同时")]),t._v("，那么"),s("code",[t._v("函数体内的这个变量就会被上升到最顶端")]),t._v("。")]),t._v(" "),s("p",[s("strong",[t._v("函数提升")])]),t._v(" "),s("p",[t._v("函数提升只会提升函数声明式写法，函数表达式的写法不存在函数提升")]),t._v(" "),s("p",[t._v("函数提升的优先级大于变量提升的优先级，即函数提升在变量提升之上")]),t._v(" "),s("h3",{attrs:{id:"_2-14-如何延长作用域链"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-14-如何延长作用域链"}},[t._v("#")]),t._v(" 2.14 如何延长作用域链？")]),t._v(" "),s("p",[t._v("作用域链是可以延长的。")]),t._v(" "),s("p",[t._v("延长作用域链： 执行环境的类型只有两种，全局和局部（函数）。但是有些语句可以在作用域链的前端临时增加一个变量对象，该变量对象会在代码执行后被移除。")]),t._v(" "),s("p",[t._v("具体来说就是执行这两个语句时，作用域链都会得到加强")]),t._v(" "),s("ol",{attrs:{start:"0"}},[s("li",[t._v("try - catch 语句的 catch 块：会创建一个新的变量对象，包含的是被抛出的错误对 象的声明。")]),t._v(" "),s("li",[t._v("with 语句：with 语句会将指定的对象添加到作用域链中。")])]),t._v(" "),s("h3",{attrs:{id:"_2-15-浏览器的垃圾回收机制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-15-浏览器的垃圾回收机制"}},[t._v("#")]),t._v(" 2.15 浏览器的垃圾回收机制")]),t._v(" "),s("h4",{attrs:{id:"_1-内存的生命周期"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-内存的生命周期"}},[t._v("#")]),t._v(" （1）内存的生命周期")]),t._v(" "),s("p",[t._v("JS 环境中分配的内存, 一般有如下生命周期：")]),t._v(" "),s("ol",{attrs:{start:"0"}},[s("li",[s("p",[t._v("内存分配：当我们声明变量、函数、对象的时候，系统会自动为他们分配内存")])]),t._v(" "),s("li",[s("p",[t._v("内存使用：即读写内存，也就是使用变量、函数等")])]),t._v(" "),s("li",[s("p",[t._v("内存回收：使用完毕，由垃圾回收自动回收不再使用的内存")]),t._v(" "),s("p",[t._v("全局变量一般不会回收, 一般局部变量的的值, 不用了, 会被自动回收掉")])])]),t._v(" "),s("h4",{attrs:{id:"_2-垃圾回收的概念"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-垃圾回收的概念"}},[t._v("#")]),t._v(" （2）垃圾回收的概念")]),t._v(" "),s("p",[s("strong",[t._v("垃圾回收")]),t._v("：JavaScript代码运行时，需要分配内存空间来储存变量和值。当变量不在参与运行时，就需要系统收回被占用的内存空间，这就是垃圾回收。")]),t._v(" "),s("p",[s("strong",[t._v("回收机制")]),t._v("：")]),t._v(" "),s("ul",[s("li",[t._v("Javascript 具有自动垃圾回收机制，会定期对那些不再使用的变量、对象所占用的内存进行释放，原理就是找到不再使用的变量，然后释放掉其占用的内存。")]),t._v(" "),s("li",[t._v("JavaScript中存在两种变量：局部变量和全局变量。全局变量的生命周期会持续要页面卸载；而局部变量声明在函数中，它的生命周期从函数执行开始，直到函数执行结束，在这个过程中，局部变量会在堆或栈中存储它们的值，当函数执行结束后，这些局部变量不再被使用，它们所占有的空间就会被释放。")]),t._v(" "),s("li",[t._v("不过，当局部变量被外部函数使用时，其中一种情况就是闭包，在函数执行结束后，函数外部的变量依然指向函数内部的局部变量，此时局部变量依然在被使用，所以不会回收。")])]),t._v(" "),s("h4",{attrs:{id:"_3-垃圾回收的方式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-垃圾回收的方式"}},[t._v("#")]),t._v(" （3）垃圾回收的方式")]),t._v(" "),s("p",[s("strong",[t._v("1.引用计数法")])]),t._v(" "),s("ul",[s("li",[t._v("这个用的相对较少，IE采用的引用计数算法。引用计数就是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型赋值给该变量时，则这个值的引用次数就是1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数就减1。当这个引用次数变为0时，说明这个变量已经没有价值，因此，在在机回收期下次再运行时，这个变量所占有的内存空间就会被释放出来。")]),t._v(" "),s("li",[t._v("这种方法会引起"),s("strong",[t._v("循环引用")]),t._v("的问题：例如："),s("code",[t._v("obj1")]),t._v("和"),s("code",[t._v("obj2")]),t._v("通过属性进行相互引用，两个对象的引用次数都是2。当使用循环计数时，由于函数执行完后，两个对象都离开作用域，函数执行结束，"),s("code",[t._v("obj1")]),t._v("和"),s("code",[t._v("obj2")]),t._v("还将会继续存在，因此它们的引用次数永远不会是0，就会引起循环引用。")])]),t._v(" "),s("p",[s("strong",[t._v("2.标记清除法")])]),t._v(" "),s("p",[t._v("现代的浏览器已经不再使用引用计数算法了。")]),t._v(" "),s("p",[t._v("现代浏览器通用的大多是基于标记清除算法的某些改进算法，总体思想都是一致的。")]),t._v(" "),s("ul",[s("li",[t._v("标记清除是浏览器常见的垃圾回收方式，当变量进入执行环境时，就标记这个变量“进入环境”，被标记为“进入环境”的变量是不能被回收的，因为他们正在被使用。当变量离开环境时，就会被标记为“离开环境”，被标记为“离开环境”的变量会被内存释放。")]),t._v(" "),s("li",[t._v("垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记。然后，它会去掉环境中的变量以及被环境中的变量引用的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后。垃圾收集器完成内存清除工作，销毁那些带标记的值，并回收他们所占用的内存空间。")])]),t._v(" "),s("h4",{attrs:{id:"_4-如何减少垃圾回收"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-如何减少垃圾回收"}},[t._v("#")]),t._v(" （4）如何减少垃圾回收")]),t._v(" "),s("p",[t._v("虽然浏览器可以进行垃圾自动回收，但是当代码比较复杂时，垃圾回收所带来的代价比较大，所以应该尽量减少垃圾回收。")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("对数组进行优化：")]),t._v(" 在清空一个数组时，最简单的方法就是给其赋值为[ ]，但是与此同时会创建一个新的空对象，可以将数组的长度设置为0，以此来达到清空数组的目的。")]),t._v(" "),s("li",[s("strong",[t._v("对")]),s("code",[t._v("object")]),s("strong",[t._v("进行优化：")]),t._v(" 对象尽量复用，对于不再使用的对象，就将其设置为null，尽快被回收。")]),t._v(" "),s("li",[s("strong",[t._v("对函数进行优化：")]),t._v(" 在循环中的函数表达式，如果可以复用，尽量放在函数的外面。")])]),t._v(" "),s("h4",{attrs:{id:"_5-内存泄漏是什么"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-内存泄漏是什么"}},[t._v("#")]),t._v(" （5）内存泄漏是什么")]),t._v(" "),s("p",[t._v("是指由于疏忽或错误造成程序未能释放已经不再使用的内存")]),t._v(" "),s("h4",{attrs:{id:"_6-哪些情况会导致内存泄漏"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_6-哪些情况会导致内存泄漏"}},[t._v("#")]),t._v(" （6）哪些情况会导致内存泄漏")]),t._v(" "),s("p",[t._v("以下四种情况会造成内存的泄漏：")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("意外的全局变量：")]),t._v(" 由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。")]),t._v(" "),s("li",[s("strong",[t._v("被遗忘的计时器或回调函数：")]),t._v(" 设置了 setInterval 定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。")]),t._v(" "),s("li",[s("strong",[t._v("脱离 DOM 的引用：")]),t._v(" 获取一个 DOM 元素的引用，而后面这个元素被删除，由于一直保留了对这个元素的引用，所以它也无法被回收。")]),t._v(" "),s("li",[s("strong",[t._v("闭包：")]),t._v(" 不合理的使用闭包，从而导致某些变量一直被留在内存当中。")])]),t._v(" "),s("h2",{attrs:{id:"三、-函数与函数式编程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#三、-函数与函数式编程"}},[t._v("#")]),t._v(" 三、 函数与函数式编程")]),t._v(" "),s("h3",{attrs:{id:"_3-1-什么是函数式编程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-什么是函数式编程"}},[t._v("#")]),t._v(" 3.1 什么是函数式编程")]),t._v(" "),s("p",[t._v('函数式编程是一种"编程范式"（programming paradigm），一种编写程序的方法论')]),t._v(" "),s("p",[t._v("主要的编程范式有三种：命令式编程，声明式编程和函数式编程")]),t._v(" "),s("p",[t._v("相比命令式编程，函数式编程更加强调程序执行的结果而非执行的过程，倡导利用若干简单的执行单元让计算结果不断渐进，逐层推导复杂的运算，而非设计一个复杂的执行过程")]),t._v(" "),s("h3",{attrs:{id:"_3-2-函数式编程的优缺点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-函数式编程的优缺点"}},[t._v("#")]),t._v(" 3.2 函数式编程的优缺点")]),t._v(" "),s("p",[s("strong",[t._v("优点")])]),t._v(" "),s("ul",[s("li",[t._v("更好的管理状态：因为它的宗旨是无状态，或者说更少的状态，能最大化的减少这些未知、优化代码、减少出错情况")]),t._v(" "),s("li",[t._v("更简单的复用：固定输入->固定输出，没有其他外部变量影响，并且无副作用。这样代码复用时，完全不需要考虑它的内部实现和外部影响")]),t._v(" "),s("li",[t._v("更优雅的组合：往大的说，网页是由各个组件组成的。往小的说，一个函数也可能是由多个小函数组成的。更强的复用性，带来更强大的组合性")]),t._v(" "),s("li",[t._v("隐性好处。减少代码量，提高维护性")])]),t._v(" "),s("p",[s("strong",[t._v("缺点")])]),t._v(" "),s("ul",[s("li",[t._v("性能：函数式编程相对于指令式编程，性能绝对是一个短板，因为它往往会对一个方法进行过度包装，从而产生上下文切换的性能开销")]),t._v(" "),s("li",[t._v("资源占用：在 JS 中为了实现对象状态的不可变，往往会创建新的对象，因此，它对垃圾回收所产生的压力远远超过其他编程方式")]),t._v(" "),s("li",[t._v("递归陷阱：在函数式编程中，为了实现迭代，通常会采用递归操作")])]),t._v(" "),s("h3",{attrs:{id:"_3-3-什么是纯函数-它有什么优点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-什么是纯函数-它有什么优点"}},[t._v("#")]),t._v(" 3.3 什么是纯函数，它有什么优点")]),t._v(" "),s("p",[t._v("纯函数是对给定的输入返还相同输出的函数，并且要求你所有的数据都是不可变的，即纯函数=无状态+数据不可变")]),t._v(" "),s("p",[t._v("特性：")]),t._v(" "),s("ul",[s("li",[t._v("函数内部传入指定的值，就会返回确定唯一的值")]),t._v(" "),s("li",[t._v("不会造成超出作用域的变化，例如修改全局变量或引用传递的参数")])]),t._v(" "),s("p",[t._v("优势：")]),t._v(" "),s("ul",[s("li",[t._v("使用纯函数，我们可以产生可测试的代码")]),t._v(" "),s("li",[t._v("不依赖外部环境计算，不会产生副作用，提高函数的复用性")]),t._v(" "),s("li",[t._v("可读性更强 ，函数不管是否是纯函数 都会有一个语义化的名称，更便于阅读")]),t._v(" "),s("li",[t._v("可以组装成复杂任务的可能性。符合模块化概念及单一职责原则")])]),t._v(" "),s("h3",{attrs:{id:"_3-4-什么是组合函数-compose"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-4-什么是组合函数-compose"}},[t._v("#")]),t._v(" 3.4 什么是组合函数 (compose)")]),t._v(" "),s("p",[t._v("在函数式编程中，有一个很重要的概念就是函数组合，实际上就是把处理的函数数据像管道一样连接起来，然后让数据穿过管道连接起来，得到最终的结果。")]),t._v(" "),s("p",[t._v("组合函数，其实大致思想就是将 多个函数组合成一个函数，c(b(a(a(1)))) 这种写法简写为 compose(c, b, a, a)(x) 。但是注意这里如果一个函数都没有传入，那就是传入的是什么就返回什么，并且函数的执行顺序是和传入的顺序相反的。")]),t._v(" "),s("div",{staticClass:"language-ini line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-ini"}},[s("code",[s("span",{pre:!0,attrs:{class:"token key attr-name"}},[t._v("var compose")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token value attr-value"}},[t._v("(...funcs) => {")]),t._v("\n  // funcs(数组)：记录的是所有的函数\n  // 这里其实也是利用了柯里化的思想，函数执行，生成一个闭包，预先把一些信息存储，供下级上下文使用\n "),s("span",{pre:!0,attrs:{class:"token key attr-name"}},[t._v(" return (x)")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token value attr-value"}},[t._v("> {")]),t._v("\n "),s("span",{pre:!0,attrs:{class:"token key attr-name"}},[t._v("   var len")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token value attr-value"}},[t._v("funcs.length;")]),t._v("\n    // 如果没有函数执行，直接返回结果\n "),s("span",{pre:!0,attrs:{class:"token key attr-name"}},[t._v("   if (len")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token value attr-value"}},[t._v("== 0) return x;")]),t._v("\n "),s("span",{pre:!0,attrs:{class:"token key attr-name"}},[t._v("   if (len")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token value attr-value"}},[t._v("== 1) funcs[0](x);")]),t._v("\n "),s("span",{pre:!0,attrs:{class:"token key attr-name"}},[t._v("   return funcs.reduceRight((res, func)")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token value attr-value"}},[t._v("> {")]),t._v("\n      return func(res);\n    }, x);\n  };\n};\n"),s("span",{pre:!0,attrs:{class:"token key attr-name"}},[t._v("var resFn")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token value attr-value"}},[t._v("compose(c, b, a, a);")]),t._v("\nresFn(1);\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br"),s("span",{staticClass:"line-number"},[t._v("10")]),s("br"),s("span",{staticClass:"line-number"},[t._v("11")]),s("br"),s("span",{staticClass:"line-number"},[t._v("12")]),s("br"),s("span",{staticClass:"line-number"},[t._v("13")]),s("br"),s("span",{staticClass:"line-number"},[t._v("14")]),s("br"),s("span",{staticClass:"line-number"},[t._v("15")]),s("br")])]),s("p",[t._v("组合函数的思想，在很多框架中也被使用，例如：redux，实现效果来说是其实和上面的代码等价。")]),t._v(" "),s("h3",{attrs:{id:"_3-5-什么是惰性函数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-5-什么是惰性函数"}},[t._v("#")]),t._v(" 3.5 什么是惰性函数")]),t._v(" "),s("p",[t._v("惰性载入表示函数执行的分支只会在函数第一次掉用的时候执行，在第一次调用过程中，该函数会被覆盖为另一个按照合适方式执行的函数，这样任何对原函数的调用就不用再经过执行的分支了")]),t._v(" "),s("p",[s("strong",[t._v("惰性函数相当于有记忆的功能一样，当它已经判断了一遍的话，第二遍就不会再判断了。")])]),t._v(" "),s("p",[t._v("比如现在要求写一个test函数，这个函数返回首次调用时的new Date().getTime()，注意是首次，而且不允许有全局变量的污染")]),t._v(" "),s("div",{staticClass:"language-javascript line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-javascript"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//一般会这样实现")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" test "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" t "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("t"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" t"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n        t "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Date")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("getTime")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" t"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 用惰性函数实现")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("test")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" t "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Date")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("getTime")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("test")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" t"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("test")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\nconsole"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("test")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nconsole"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("test")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nconsole"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("test")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br"),s("span",{staticClass:"line-number"},[t._v("10")]),s("br"),s("span",{staticClass:"line-number"},[t._v("11")]),s("br"),s("span",{staticClass:"line-number"},[t._v("12")]),s("br"),s("span",{staticClass:"line-number"},[t._v("13")]),s("br"),s("span",{staticClass:"line-number"},[t._v("14")]),s("br"),s("span",{staticClass:"line-number"},[t._v("15")]),s("br"),s("span",{staticClass:"line-number"},[t._v("16")]),s("br"),s("span",{staticClass:"line-number"},[t._v("17")]),s("br"),s("span",{staticClass:"line-number"},[t._v("18")]),s("br"),s("span",{staticClass:"line-number"},[t._v("19")]),s("br"),s("span",{staticClass:"line-number"},[t._v("20")]),s("br"),s("span",{staticClass:"line-number"},[t._v("21")]),s("br"),s("span",{staticClass:"line-number"},[t._v("22")]),s("br")])]),s("h3",{attrs:{id:"_3-6-什么是高阶函数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-6-什么是高阶函数"}},[t._v("#")]),t._v(" 3.6 什么是高阶函数")]),t._v(" "),s("p",[t._v("高阶函数是指使用其他函数作为参数、或者返回一个函数作为结果的函数。")]),t._v(" "),s("h3",{attrs:{id:"_3-7-说说你对函数柯里化的理解"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-7-说说你对函数柯里化的理解"}},[t._v("#")]),t._v(" 3.7 说说你对函数柯里化的理解")]),t._v(" "),s("p",[t._v("柯里化（Currying）是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数且返回结果的新函数的技术。")]),t._v(" "),s("p",[t._v("函数柯里化的好处：")]),t._v(" "),s("p",[t._v("（1）参数复用：需要输入多个参数，最终只需输入一个，其余通过 arguments 来获取")]),t._v(" "),s("p",[t._v("（2）提前确认：避免重复去判断某一条件是否符合，不符合则 return 不再继续执行下面的操作")]),t._v(" "),s("p",[t._v("（3）延迟运行：避免重复的去执行程序，等真正需要结果的时候再执行")]),t._v(" "),s("div",{staticClass:"language-js line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("curry")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("fn")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("curried")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("...")]),t._v("args")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("args"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("length "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">=")]),t._v(" fn"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("length"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("fn")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("...")]),t._v("args"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 接受完所有参数，直接执行")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("else")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("...")]),t._v("args2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 未接收完参数")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("curried")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("...")]),t._v("args"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("...")]),t._v("args2"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br"),s("span",{staticClass:"line-number"},[t._v("10")]),s("br"),s("span",{staticClass:"line-number"},[t._v("11")]),s("br"),s("span",{staticClass:"line-number"},[t._v("12")]),s("br")])]),s("h3",{attrs:{id:"_3-8-什么是箭头函数-有什么特征"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-8-什么是箭头函数-有什么特征"}},[t._v("#")]),t._v(" 3.8 什么是箭头函数，有什么特征")]),t._v(" "),s("p",[t._v('使用 "箭头" ( => ) 来定义函数. 箭头函数相当于匿名函数, 并且简化了函数定义')]),t._v(" "),s("p",[s("strong",[t._v("箭头函数的特征:")])]),t._v(" "),s("ul",[s("li",[t._v("箭头函数没有this, this指向定义箭头函数所处的外部环境")]),t._v(" "),s("li",[t._v("箭头函数的this永远不会变，call、apply、bind也无法改变")]),t._v(" "),s("li",[t._v("箭头函数只能声明成"),s("strong",[t._v("匿名函数")]),t._v("，但可以通过表达式的方式让箭头函数具名")]),t._v(" "),s("li",[t._v("箭头函数没有原型prototype")]),t._v(" "),s("li",[t._v("箭头函数不能当做一个构造函数 因为 this 的指向问题")]),t._v(" "),s("li",[t._v("箭头函数没有 arguments 在箭头函数内部访问这个变量访问的是外部环境的arguments, 可以使用 ...代替")])]),t._v(" "),s("h3",{attrs:{id:"_3-9-说说你对递归函数的理解"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-9-说说你对递归函数的理解"}},[t._v("#")]),t._v(" 3.9 说说你对递归函数的理解")]),t._v(" "),s("p",[t._v("如果一个函数在内部调用自身本身，这个函数就是递归函数")]),t._v(" "),s("p",[t._v("其核心思想是把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解")]),t._v(" "),s("p",[t._v("一般来说，递归需要有边界条件、递归前进阶段和递归返回阶段。当边界条件不满足时，递归前进；当边界条件满足时，递归返回")]),t._v(" "),s("p",[s("strong",[t._v("优点")]),t._v("：结构清晰、可读性强")]),t._v(" "),s("p",[s("strong",[t._v("缺点")]),t._v("：效率低、调用栈可能会溢出，其实每一次函数调用会在内存栈中分配空间，而每个进程的栈的容量是有限的，当调用的层次太多时，就会超出栈的容量，从而导致栈溢出。")]),t._v(" "),s("h3",{attrs:{id:"_3-10-什么是尾递归"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-10-什么是尾递归"}},[t._v("#")]),t._v(" 3.10 什么是尾递归")]),t._v(" "),s("p",[t._v("尾递归，即在函数尾位置调用自身（或是一个尾调用本身的其他函数等等）。")]),t._v(" "),s("p",[t._v("在递归调用的过程当中系统为每一层的返回点、局部量等开辟了栈来存储，递归次数过多容易造成栈溢出")]),t._v(" "),s("p",[t._v('这时候，我们就可以使用尾递归，即一个函数中所有递归形式的调用都出现在函数的末尾，对于尾递归来说，由于只存在一个调用记录，所以永远不会发生"栈溢出"错误')]),t._v(" "),s("h3",{attrs:{id:"_3-11-函数传参-传递复杂数据类型和简单数据类型有什么区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-11-函数传参-传递复杂数据类型和简单数据类型有什么区别"}},[t._v("#")]),t._v(" 3.11 函数传参，传递复杂数据类型和简单数据类型有什么区别")]),t._v(" "),s("p",[t._v("传递复杂数据类型传递的是引用的地址，修改会改变")]),t._v(" "),s("p",[t._v("简单数据类型传递的是具体的值，不会相互影响")]),t._v(" "),s("div",{staticClass:"language-ini line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-ini"}},[s("code",[s("span",{pre:!0,attrs:{class:"token key attr-name"}},[t._v("/* let a")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token value attr-value"}},[t._v("8")]),t._v("\n    function fn(a) {\n "),s("span",{pre:!0,attrs:{class:"token key attr-name"}},[t._v("     a")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token value attr-value"}},[t._v("9")]),t._v("\n    }\n    fn(a)\n    console.log(a) // 8 */\n​\n "),s("span",{pre:!0,attrs:{class:"token key attr-name"}},[t._v("   let a")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token value attr-value"}},[t._v("{ age: 8 }")]),t._v("\n    function fn(a) {\n "),s("span",{pre:!0,attrs:{class:"token key attr-name"}},[t._v("     a.age")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token value attr-value"}},[t._v("9")]),t._v("\n    }\n    fn(a)\n    console.log(a.age) // 9\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br"),s("span",{staticClass:"line-number"},[t._v("10")]),s("br"),s("span",{staticClass:"line-number"},[t._v("11")]),s("br"),s("span",{staticClass:"line-number"},[t._v("12")]),s("br"),s("span",{staticClass:"line-number"},[t._v("13")]),s("br")])]),s("h3",{attrs:{id:"_3-12-函数声明与函数表达式的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-12-函数声明与函数表达式的区别"}},[t._v("#")]),t._v(" 3.12 函数声明与函数表达式的区别")]),t._v(" "),s("p",[s("strong",[t._v("函数声明：")]),t._v(" funtion开头，有函数提升")]),t._v(" "),s("p",[s("strong",[t._v("函数表达式")]),t._v(": 不是funtion开头，没有函数提升")]),t._v(" "),s("h3",{attrs:{id:"_3-13-什么是函数缓存-如何实现"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-13-什么是函数缓存-如何实现"}},[t._v("#")]),t._v(" 3.13 什么是函数缓存，如何实现？")]),t._v(" "),s("p",[s("strong",[t._v("概念")])]),t._v(" "),s("p",[t._v("函数缓存，就是将函数运算过的结果进行缓存")]),t._v(" "),s("p",[t._v("本质上就是用空间（缓存存储）换时间（计算过程）")]),t._v(" "),s("p",[t._v("常用于缓存数据计算结果和缓存对象")]),t._v(" "),s("p",[s("strong",[t._v("如何实现")])]),t._v(" "),s("p",[t._v("实现函数缓存主要依靠闭包、柯里化、高阶函数")]),t._v(" "),s("p",[s("strong",[t._v("应用场景")])]),t._v(" "),s("ul",[s("li",[t._v("对于昂贵的函数调用，执行复杂计算的函数")]),t._v(" "),s("li",[t._v("对于具有有限且高度重复输入范围的函数")]),t._v(" "),s("li",[t._v("对于具有重复输入值的递归函数")]),t._v(" "),s("li",[t._v("对于纯函数，即每次使用特定输入调用时返回相同输出的函数")])]),t._v(" "),s("h3",{attrs:{id:"_3-14-call、apply、bind三者的异同"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-14-call、apply、bind三者的异同"}},[t._v("#")]),t._v(" 3.14 call、apply、bind三者的异同")]),t._v(" "),s("p",[s("strong",[t._v("共同点")]),t._v(" :")]),t._v(" "),s("ul",[s("li",[t._v("都可以改变this指向;")]),t._v(" "),s("li",[t._v("三者第一个参数都是"),s("code",[t._v("this")]),t._v("要指向的对象，如果如果没有这个参数或参数为"),s("code",[t._v("undefined")]),t._v("或"),s("code",[t._v("null")]),t._v("，则默认指向全局"),s("code",[t._v("window")])])]),t._v(" "),s("p",[s("strong",[t._v("不同点")]),t._v(":")]),t._v(" "),s("ul",[s("li",[t._v("call 和 apply 会调用函数, 并且改变函数内部this指向.")]),t._v(" "),s("li",[t._v("call 和 apply传递的参数不一样,call传递参数使用逗号隔开,apply使用数组传递，且"),s("code",[t._v("apply")]),t._v("和"),s("code",[t._v("call")]),t._v("是一次性传入参数，而"),s("code",[t._v("bind")]),t._v("可以分为多次传入")]),t._v(" "),s("li",[s("code",[t._v("bind")]),t._v("是返回绑定this之后的函数")])]),t._v(" "),s("p",[s("strong",[t._v("应用场景")])]),t._v(" "),s("ol",{attrs:{start:"0"}},[s("li",[t._v("call 经常做继承.")]),t._v(" "),s("li",[t._v("apply经常跟数组有关系. 比如借助于数学对象实现数组最大值最小值")]),t._v(" "),s("li",[t._v("bind 不调用函数,但是还想改变this指向. 比如改变定时器内部的this指向")])])])}),[],!1,null,null,null);s.default=e.exports}}]);