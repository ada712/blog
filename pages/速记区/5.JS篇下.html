<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>四、原型与继承 | 奇思妙想</title>
    <meta name="generator" content="VuePress 1.9.7">
    
    <meta name="description" content="随心记">
    
    <link rel="preload" href="/blog/assets/css/0.styles.27cf9bcb.css" as="style"><link rel="preload" href="/blog/assets/js/app.1bd983b1.js" as="script"><link rel="preload" href="/blog/assets/js/4.84f2b8c1.js" as="script"><link rel="preload" href="/blog/assets/js/1.2f8de4ad.js" as="script"><link rel="preload" href="/blog/assets/js/83.6d1bebc4.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.e3564c7f.js"><link rel="prefetch" href="/blog/assets/js/100.da2c7a93.js"><link rel="prefetch" href="/blog/assets/js/101.8d6941b2.js"><link rel="prefetch" href="/blog/assets/js/102.c4731a0a.js"><link rel="prefetch" href="/blog/assets/js/103.c894c3b0.js"><link rel="prefetch" href="/blog/assets/js/104.492f8c34.js"><link rel="prefetch" href="/blog/assets/js/105.1beb466f.js"><link rel="prefetch" href="/blog/assets/js/106.eb47fcd4.js"><link rel="prefetch" href="/blog/assets/js/107.8dd72565.js"><link rel="prefetch" href="/blog/assets/js/108.13884e30.js"><link rel="prefetch" href="/blog/assets/js/109.b79ae5c2.js"><link rel="prefetch" href="/blog/assets/js/11.d653ea51.js"><link rel="prefetch" href="/blog/assets/js/110.e8cb6402.js"><link rel="prefetch" href="/blog/assets/js/111.962a254c.js"><link rel="prefetch" href="/blog/assets/js/112.1c865e0e.js"><link rel="prefetch" href="/blog/assets/js/113.abbcf4e0.js"><link rel="prefetch" href="/blog/assets/js/114.eace49f6.js"><link rel="prefetch" href="/blog/assets/js/115.ded270e4.js"><link rel="prefetch" href="/blog/assets/js/116.fc3bd5ac.js"><link rel="prefetch" href="/blog/assets/js/117.e8d0d7ce.js"><link rel="prefetch" href="/blog/assets/js/118.554e87be.js"><link rel="prefetch" href="/blog/assets/js/119.a6e0f846.js"><link rel="prefetch" href="/blog/assets/js/12.ec8dec5c.js"><link rel="prefetch" href="/blog/assets/js/120.629c24c0.js"><link rel="prefetch" href="/blog/assets/js/121.9cf099d3.js"><link rel="prefetch" href="/blog/assets/js/122.c44b5a8b.js"><link rel="prefetch" href="/blog/assets/js/123.cb5860e9.js"><link rel="prefetch" href="/blog/assets/js/124.71ba35ed.js"><link rel="prefetch" href="/blog/assets/js/125.12963b8e.js"><link rel="prefetch" href="/blog/assets/js/126.35e48a82.js"><link rel="prefetch" href="/blog/assets/js/127.a0d4401c.js"><link rel="prefetch" href="/blog/assets/js/128.46d5629f.js"><link rel="prefetch" href="/blog/assets/js/129.0b322fa7.js"><link rel="prefetch" href="/blog/assets/js/13.04fd3b25.js"><link rel="prefetch" href="/blog/assets/js/130.0e756258.js"><link rel="prefetch" href="/blog/assets/js/131.5c13115f.js"><link rel="prefetch" href="/blog/assets/js/132.efa5f359.js"><link rel="prefetch" href="/blog/assets/js/133.e0ab4ea7.js"><link rel="prefetch" href="/blog/assets/js/134.cba85fad.js"><link rel="prefetch" href="/blog/assets/js/135.6bbb71c4.js"><link rel="prefetch" href="/blog/assets/js/136.065ff011.js"><link rel="prefetch" href="/blog/assets/js/137.5f3247c7.js"><link rel="prefetch" href="/blog/assets/js/138.21a89930.js"><link rel="prefetch" href="/blog/assets/js/139.c3e1e298.js"><link rel="prefetch" href="/blog/assets/js/14.512024d1.js"><link rel="prefetch" href="/blog/assets/js/140.2d13327f.js"><link rel="prefetch" href="/blog/assets/js/141.523c4963.js"><link rel="prefetch" href="/blog/assets/js/142.060fb625.js"><link rel="prefetch" href="/blog/assets/js/143.c4130ee2.js"><link rel="prefetch" href="/blog/assets/js/144.3b65d25c.js"><link rel="prefetch" href="/blog/assets/js/145.cd8f1d9a.js"><link rel="prefetch" href="/blog/assets/js/146.6e61a1ac.js"><link rel="prefetch" href="/blog/assets/js/147.50eedcef.js"><link rel="prefetch" href="/blog/assets/js/148.f4d013fc.js"><link rel="prefetch" href="/blog/assets/js/149.96c51a81.js"><link rel="prefetch" href="/blog/assets/js/15.347f8e9e.js"><link rel="prefetch" href="/blog/assets/js/150.48c25cb5.js"><link rel="prefetch" href="/blog/assets/js/151.32183bbd.js"><link rel="prefetch" href="/blog/assets/js/152.e8f9ef49.js"><link rel="prefetch" href="/blog/assets/js/153.4ca217cc.js"><link rel="prefetch" href="/blog/assets/js/154.fa34241c.js"><link rel="prefetch" href="/blog/assets/js/155.6aedc925.js"><link rel="prefetch" href="/blog/assets/js/156.eec27cdb.js"><link rel="prefetch" href="/blog/assets/js/157.1e9a38a9.js"><link rel="prefetch" href="/blog/assets/js/158.63a52773.js"><link rel="prefetch" href="/blog/assets/js/159.62c31f27.js"><link rel="prefetch" href="/blog/assets/js/16.94336931.js"><link rel="prefetch" href="/blog/assets/js/160.12da0ac3.js"><link rel="prefetch" href="/blog/assets/js/161.208cb6ea.js"><link rel="prefetch" href="/blog/assets/js/162.fedac5b9.js"><link rel="prefetch" href="/blog/assets/js/17.8bfb9698.js"><link rel="prefetch" href="/blog/assets/js/18.9e59c1ef.js"><link rel="prefetch" href="/blog/assets/js/19.abe7feb2.js"><link rel="prefetch" href="/blog/assets/js/20.4133ae84.js"><link rel="prefetch" href="/blog/assets/js/21.28c7284d.js"><link rel="prefetch" href="/blog/assets/js/22.2cb902fc.js"><link rel="prefetch" href="/blog/assets/js/23.1d8b8783.js"><link rel="prefetch" href="/blog/assets/js/24.ea221f36.js"><link rel="prefetch" href="/blog/assets/js/25.b6feae6a.js"><link rel="prefetch" href="/blog/assets/js/26.15268f36.js"><link rel="prefetch" href="/blog/assets/js/27.e50504b9.js"><link rel="prefetch" href="/blog/assets/js/28.6e459449.js"><link rel="prefetch" href="/blog/assets/js/29.575e182a.js"><link rel="prefetch" href="/blog/assets/js/3.25d40e75.js"><link rel="prefetch" href="/blog/assets/js/30.09b906bb.js"><link rel="prefetch" href="/blog/assets/js/31.614f49aa.js"><link rel="prefetch" href="/blog/assets/js/32.01916c47.js"><link rel="prefetch" href="/blog/assets/js/33.60afe153.js"><link rel="prefetch" href="/blog/assets/js/34.fe38c378.js"><link rel="prefetch" href="/blog/assets/js/35.753fd3bb.js"><link rel="prefetch" href="/blog/assets/js/36.95e4a317.js"><link rel="prefetch" href="/blog/assets/js/37.0c810791.js"><link rel="prefetch" href="/blog/assets/js/38.7a384aa3.js"><link rel="prefetch" href="/blog/assets/js/39.13163e35.js"><link rel="prefetch" href="/blog/assets/js/40.5765271a.js"><link rel="prefetch" href="/blog/assets/js/41.c6dbf392.js"><link rel="prefetch" href="/blog/assets/js/42.91e813ba.js"><link rel="prefetch" href="/blog/assets/js/43.6376ff7e.js"><link rel="prefetch" href="/blog/assets/js/44.6820546f.js"><link rel="prefetch" href="/blog/assets/js/45.b3a3883f.js"><link rel="prefetch" href="/blog/assets/js/46.9c82af46.js"><link rel="prefetch" href="/blog/assets/js/47.73e25062.js"><link rel="prefetch" href="/blog/assets/js/48.e1798374.js"><link rel="prefetch" href="/blog/assets/js/49.71fa8240.js"><link rel="prefetch" href="/blog/assets/js/5.e7815cdd.js"><link rel="prefetch" href="/blog/assets/js/50.f2b22a8d.js"><link rel="prefetch" href="/blog/assets/js/51.d0dbf841.js"><link rel="prefetch" href="/blog/assets/js/52.1eace587.js"><link rel="prefetch" href="/blog/assets/js/53.8748edb6.js"><link rel="prefetch" href="/blog/assets/js/54.afb5d894.js"><link rel="prefetch" href="/blog/assets/js/55.44867631.js"><link rel="prefetch" href="/blog/assets/js/56.2c8cb6f2.js"><link rel="prefetch" href="/blog/assets/js/57.59bb6d4b.js"><link rel="prefetch" href="/blog/assets/js/58.7348b44e.js"><link rel="prefetch" href="/blog/assets/js/59.c97550a4.js"><link rel="prefetch" href="/blog/assets/js/6.ec4b49eb.js"><link rel="prefetch" href="/blog/assets/js/60.3560be9e.js"><link rel="prefetch" href="/blog/assets/js/61.526e2e80.js"><link rel="prefetch" href="/blog/assets/js/62.9b2add52.js"><link rel="prefetch" href="/blog/assets/js/63.3a596d76.js"><link rel="prefetch" href="/blog/assets/js/64.f6f0218b.js"><link rel="prefetch" href="/blog/assets/js/65.400ec059.js"><link rel="prefetch" href="/blog/assets/js/66.aa5a020c.js"><link rel="prefetch" href="/blog/assets/js/67.72fd7564.js"><link rel="prefetch" href="/blog/assets/js/68.43296045.js"><link rel="prefetch" href="/blog/assets/js/69.f062d617.js"><link rel="prefetch" href="/blog/assets/js/7.9c595647.js"><link rel="prefetch" href="/blog/assets/js/70.cca521a9.js"><link rel="prefetch" href="/blog/assets/js/71.310cf1a3.js"><link rel="prefetch" href="/blog/assets/js/72.3fa3c700.js"><link rel="prefetch" href="/blog/assets/js/73.5c8ac80b.js"><link rel="prefetch" href="/blog/assets/js/74.571a5a81.js"><link rel="prefetch" href="/blog/assets/js/75.1cdf9c31.js"><link rel="prefetch" href="/blog/assets/js/76.8db9741a.js"><link rel="prefetch" href="/blog/assets/js/77.849eccbe.js"><link rel="prefetch" href="/blog/assets/js/78.ff4ee1a0.js"><link rel="prefetch" href="/blog/assets/js/79.2b117068.js"><link rel="prefetch" href="/blog/assets/js/8.0d248455.js"><link rel="prefetch" href="/blog/assets/js/80.e70c425c.js"><link rel="prefetch" href="/blog/assets/js/81.f4ca5975.js"><link rel="prefetch" href="/blog/assets/js/82.f4885b0b.js"><link rel="prefetch" href="/blog/assets/js/84.d215f359.js"><link rel="prefetch" href="/blog/assets/js/85.984e348f.js"><link rel="prefetch" href="/blog/assets/js/86.6d06f102.js"><link rel="prefetch" href="/blog/assets/js/87.17724b24.js"><link rel="prefetch" href="/blog/assets/js/88.8d9d4fc2.js"><link rel="prefetch" href="/blog/assets/js/89.d3ee79d2.js"><link rel="prefetch" href="/blog/assets/js/9.53f6c3bd.js"><link rel="prefetch" href="/blog/assets/js/90.11bbd96a.js"><link rel="prefetch" href="/blog/assets/js/91.636ea7d5.js"><link rel="prefetch" href="/blog/assets/js/92.c3cd1516.js"><link rel="prefetch" href="/blog/assets/js/93.18ea5c72.js"><link rel="prefetch" href="/blog/assets/js/94.80f0ed34.js"><link rel="prefetch" href="/blog/assets/js/95.ae3aabc3.js"><link rel="prefetch" href="/blog/assets/js/96.2c8c4fc6.js"><link rel="prefetch" href="/blog/assets/js/97.e4bd33b0.js"><link rel="prefetch" href="/blog/assets/js/98.cead715c.js"><link rel="prefetch" href="/blog/assets/js/99.8577644c.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.27cf9bcb.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container" data-v-7dd95ae2><div data-v-7dd95ae2><div class="password-shadow password-wrapper-out" style="display:none;" data-v-59e6cb88 data-v-7dd95ae2 data-v-7dd95ae2><h3 class="title" data-v-59e6cb88>奇思妙想</h3> <p class="description" data-v-59e6cb88>随心记</p> <label id="box" class="inputBox" data-v-59e6cb88><input type="password" value="" data-v-59e6cb88> <span data-v-59e6cb88>Konck! Knock!</span> <button data-v-59e6cb88>OK</button></label> <div class="footer" data-v-59e6cb88><span data-v-59e6cb88><i class="iconfont reco-theme" data-v-59e6cb88></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-59e6cb88>vuePress-theme-reco</a></span> <span data-v-59e6cb88><i class="iconfont reco-copyright" data-v-59e6cb88></i> <a data-v-59e6cb88><!---->
          
        <!---->
        2024
      </a></span></div></div> <div class="hide" data-v-7dd95ae2><header class="navbar" data-v-7dd95ae2><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><img src="/blog/avator.jpg" alt="奇思妙想" class="logo"> <span class="site-name">奇思妙想</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><i class="iconfont reco-search"></i> <input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/" class="nav-link"><i class="undefined"></i>
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      博客
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/categories/面试/" class="nav-link"><i class="undefined"></i>
  面试
</a></li><li class="dropdown-item"><!----> <a href="/blog/categories/vue/" class="nav-link"><i class="undefined"></i>
  vue
</a></li><li class="dropdown-item"><!----> <a href="/blog/categories/工具/" class="nav-link"><i class="undefined"></i>
  工具
</a></li><li class="dropdown-item"><!----> <a href="/blog/categories/算法/" class="nav-link"><i class="undefined"></i>
  算法
</a></li><li class="dropdown-item"><!----> <a href="/blog/categories/八股文速记/" class="nav-link"><i class="undefined"></i>
  八股文速记
</a></li><li class="dropdown-item"><!----> <a href="/blog/categories/虾皮/" class="nav-link"><i class="undefined"></i>
  虾皮
</a></li></ul></div></div><div class="nav-item"><a href="/blog/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  Tag
</a></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-7dd95ae2></div> <aside class="sidebar" data-v-7dd95ae2><div class="personal-info-wrapper" data-v-1fad0c41 data-v-7dd95ae2><img src="/blog/avator.jpg" alt="author-avatar" class="personal-img" data-v-1fad0c41> <!----> <div class="num" data-v-1fad0c41><div data-v-1fad0c41><h3 data-v-1fad0c41>100</h3> <h6 data-v-1fad0c41>文章</h6></div> <div data-v-1fad0c41><h3 data-v-1fad0c41>5</h3> <h6 data-v-1fad0c41>标签</h6></div></div> <ul class="social-links" data-v-1fad0c41></ul> <hr data-v-1fad0c41></div> <nav class="nav-links"><div class="nav-item"><a href="/blog/" class="nav-link"><i class="undefined"></i>
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      博客
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/categories/面试/" class="nav-link"><i class="undefined"></i>
  面试
</a></li><li class="dropdown-item"><!----> <a href="/blog/categories/vue/" class="nav-link"><i class="undefined"></i>
  vue
</a></li><li class="dropdown-item"><!----> <a href="/blog/categories/工具/" class="nav-link"><i class="undefined"></i>
  工具
</a></li><li class="dropdown-item"><!----> <a href="/blog/categories/算法/" class="nav-link"><i class="undefined"></i>
  算法
</a></li><li class="dropdown-item"><!----> <a href="/blog/categories/八股文速记/" class="nav-link"><i class="undefined"></i>
  八股文速记
</a></li><li class="dropdown-item"><!----> <a href="/blog/categories/虾皮/" class="nav-link"><i class="undefined"></i>
  虾皮
</a></li></ul></div></div><div class="nav-item"><a href="/blog/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  Tag
</a></div> <!----></nav> <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><a href="/blog/pages/css%E5%B8%B8%E8%A7%81%E9%9A%BE%E7%82%B9%E8%80%83%E7%82%B9/1.%E9%98%B2%E6%AD%A2%E9%AB%98%E5%BA%A6%E5%9D%8D%E5%A1%8C" class="sidebar-heading clickable"><span>css常见难点考点</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/pages/css常见难点考点/1.防止高度坍塌.html" class="sidebar-link">1.防止高度坍塌</a></li><li><a href="/blog/pages/css常见难点考点/2.BFC专题.html" class="sidebar-link">2.BFC专题</a></li><li><a href="/blog/pages/css常见难点考点/3.文字溢出省略号.html" class="sidebar-link">3.文字溢出省略号</a></li><li><a href="/blog/pages/css常见难点考点/4.css变量.html" class="sidebar-link">4.css变量</a></li><li><a href="/blog/pages/css常见难点考点/5.css伪类三角形.html" class="sidebar-link">5.css伪类三角形</a></li><li><a href="/blog/pages/css常见难点考点/6.媒体查询.html" class="sidebar-link">6.媒体查询</a></li><li><a href="/blog/pages/css常见难点考点/7.渐变.html" class="sidebar-link">7.渐变</a></li></ul></section></li><li><section class="sidebar-group depth-0"><a href="/blog/pages/git%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/%E5%A4%87%E5%BF%98git%E6%80%BB%E7%BB%93" class="sidebar-heading clickable"><span>git使用总结</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/pages/git使用总结/备忘git总结.html" class="sidebar-link">备忘git总结</a></li><li><a href="/blog/pages/git使用总结/工作常用git注意事项.html" class="sidebar-link">工作常用git注意事项</a></li></ul></section></li><li><section class="sidebar-group depth-0"><a href="/blog/pages/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF%E6%A0%88/TypeScript%E6%9E%81%E9%80%9F%E6%A2%B3%E7%90%86" class="sidebar-heading clickable"><span>前端技术栈</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/pages/前端技术栈/TypeScript极速梳理.html" class="sidebar-link">TypeScript极速梳理</a></li><li><a href="/blog/pages/前端技术栈/Vue3快速上手.html" class="sidebar-link">Vue3快速上手</a></li><li><a href="/blog/pages/前端技术栈/vue深入理解.html" class="sidebar-link">vue深入理解</a></li><li><a href="/blog/pages/前端技术栈/webpack.html" class="sidebar-link">webpack</a></li><li><a href="/blog/pages/前端技术栈/脚手架那些事.html" class="sidebar-link">脚手架那些事</a></li></ul></section></li><li><section class="sidebar-group depth-0"><a href="/blog/pages/%E5%B0%8F%E7%A8%8B%E5%BA%8F/event-store%E6%95%B0%E6%8D%AE%E5%85%B1%E4%BA%AB%E8%BD%BB%E9%87%8F%E5%BA%93" class="sidebar-heading clickable"><span>小程序</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/pages/小程序/event-store数据共享轻量库.html" class="sidebar-link">event-store数据共享轻量库</a></li><li><a href="/blog/pages/小程序/event-store结合项目的解说.html" class="sidebar-link">event-store结合项目的解说</a></li></ul></section></li><li><section class="sidebar-group depth-0"><a href="/blog/pages/%E5%B7%A5%E4%BD%9C%E5%BF%85%E5%A4%87%E5%88%A9%E5%99%A8/%E5%89%8D%E7%AB%AF%E8%B0%83%E8%AF%95%E5%88%A9%E5%99%A8whistle" class="sidebar-heading clickable"><span>工作必备利器</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/pages/工作必备利器/前端调试利器whistle.html" class="sidebar-link">前端调试利器whistle</a></li><li><a href="/blog/pages/工作必备利器/工具.html" class="sidebar-link">工具</a></li></ul></section></li><li><section class="sidebar-group depth-0"><a href="/blog/pages/%E5%B7%A5%E4%BD%9C%E6%80%9D%E8%80%83/%E5%A4%8D%E7%9B%98%E5%88%86%E6%9E%90" class="sidebar-heading clickable"><span>工作思考</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/pages/工作思考/复盘分析.html" class="sidebar-link">复盘分析</a></li><li><a href="/blog/pages/工作思考/如何提升客户使用质量.html" class="sidebar-link">如何提升客户使用质量</a></li><li><a href="/blog/pages/工作思考/客户成功.html" class="sidebar-link">客户成功</a></li><li><a href="/blog/pages/工作思考/降本增效.html" class="sidebar-link">降本增效</a></li></ul></section></li><li><section class="sidebar-group depth-0"><a href="/blog/pages/%E5%B7%A5%E4%BD%9C%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/0.%E4%BB%A3%E7%A0%81%E6%8F%90%E4%BA%A4%E8%A7%84%E8%8C%83" class="sidebar-heading clickable"><span>工作问题总结</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/pages/工作问题总结/0.代码提交规范.html" class="sidebar-link">0.代码提交规范</a></li><li><a href="/blog/pages/工作问题总结/1.说说filter这个css属性.html" class="sidebar-link">1.说说filter这个css属性</a></li><li><a href="/blog/pages/工作问题总结/2.table数据更新却不渲染.html" class="sidebar-link">2.table数据更新却不渲染</a></li><li><a href="/blog/pages/工作问题总结/4.IE兼容那些事.html" class="sidebar-link">4.IE兼容那些事</a></li><li><a href="/blog/pages/工作问题总结/5.关于使用border-image后,border-radius无效的问题.html" class="sidebar-link">5.关于使用border-image后,border-radius无效的问题</a></li><li><a href="/blog/pages/工作问题总结/6.可拖拽滑动的进度条.html" class="sidebar-link">6.可拖拽滑动的进度条</a></li><li><a href="/blog/pages/工作问题总结/7.页面停留时间+滚动百分比+滑动次数.html" class="sidebar-link">7.页面停留时间+滚动百分比+滑动次数</a></li><li><a href="/blog/pages/工作问题总结/8.JavaScript 常用工具方法.html" class="sidebar-link">8.JavaScript 常用工具方法</a></li><li><a href="/blog/pages/工作问题总结/9.对象数组去重.html" class="sidebar-link">9.对象数组去重</a></li><li><a href="/blog/pages/工作问题总结/10.文件流导出.html" class="sidebar-link">10.文件流导出</a></li><li><a href="/blog/pages/工作问题总结/11.防抖&amp;节流可直接挂指令上.html" class="sidebar-link">11.防抖&amp;节流可直接挂指令上</a></li><li><a href="/blog/pages/工作问题总结/12.关于try-catch.html" class="sidebar-link">12.关于try-catch</a></li></ul></section></li><li><section class="sidebar-group depth-0"><a href="/blog/pages/%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F/%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F" class="sidebar-heading clickable"><span>常见排序</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/pages/常见排序/经典排序.html" class="sidebar-link">经典排序</a></li></ul></section></li><li><section class="sidebar-group depth-0"><a href="/blog/pages/%E6%8E%98%E9%87%91%E6%94%B6%E8%97%8F/0.%E5%85%B3%E4%BA%8E%E7%99%BB%E5%BD%95%E6%80%81" class="sidebar-heading clickable"><span>掘金收藏</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/pages/掘金收藏/0.关于登录态.html" class="sidebar-link">0.关于登录态</a></li><li><a href="/blog/pages/掘金收藏/1.ms包熟.html" class="sidebar-link">1.ms包熟</a></li><li><a href="/blog/pages/掘金收藏/2.vue.html" class="sidebar-link">2.vue</a></li><li><a href="/blog/pages/掘金收藏/3.http协议.html" class="sidebar-link">3.http协议</a></li><li><a href="/blog/pages/掘金收藏/4.40道ES6 Promise实战练习题，助你快速理解Promise.html" class="sidebar-link">4.40道ES6 Promise实战练习题，助你快速理解Promise</a></li><li><a href="/blog/pages/掘金收藏/5.从浏览器地址栏输入 url 到请求返回发生了什么.html" class="sidebar-link">5.从浏览器地址栏输入 url 到请求返回发生了什么</a></li></ul></section></li><li><section class="sidebar-group depth-0"><a href="/blog/pages/%E7%AE%97%E6%B3%95/0.%E9%AB%98%E9%A2%91100%E9%81%93%E9%A2%98" class="sidebar-heading clickable"><span>算法</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/pages/算法/0.高频100道题.html" class="sidebar-link">0.高频100道题</a></li><li><a href="/blog/pages/算法/3.最长回文子串.html" class="sidebar-link">3.最长回文子串</a></li><li><a href="/blog/pages/算法/5.删除排序链表中的重复元素.html" class="sidebar-link">5.删除排序链表中的重复元素</a></li><li><a href="/blog/pages/算法/6.字符串相加.html" class="sidebar-link">6.字符串相加</a></li><li><a href="/blog/pages/算法/7.最多可以参加的会议数目.html" class="sidebar-link">7.最多可以参加的会议数目</a></li><li><a href="/blog/pages/算法/8.用最少数量的箭引爆气球.html" class="sidebar-link">8.用最少数量的箭引爆气球</a></li><li><a href="/blog/pages/算法/9.旋转链表.html" class="sidebar-link">9.旋转链表</a></li><li><section class="sidebar-group is-sub-group depth-1"><a href="/blog/pages/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91/%E5%AE%9E%E8%B7%B5" class="sidebar-heading clickable"><span>二叉树</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/pages/算法/二叉树/实践.html" class="sidebar-link">实践</a></li><li><a href="/blog/pages/算法/二叉树/框架解释.html" class="sidebar-link">框架解释</a></li></ul></section></li><li><a href="/blog/pages/算法/大厂算法刷题.html" class="sidebar-link">大厂算法刷题</a></li><li><section class="sidebar-group is-sub-group depth-1"><a href="/blog/pages/%E7%AE%97%E6%B3%95/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/%E6%A8%A1%E6%9D%BF" class="sidebar-heading clickable"><span>滑动窗口</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/pages/算法/滑动窗口/模板.html" class="sidebar-link">模板</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><a href="/blog/pages/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/19.%20%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC%20N%20%E4%B8%AA%E7%BB%93%E7%82%B9" class="sidebar-heading clickable"><span>链表</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/pages/算法/链表/19. 删除链表的倒数第 N 个结点.html" class="sidebar-link">19. 删除链表的倒数第 N 个结点</a></li><li><a href="/blog/pages/算法/链表/21. 合并两个有序链表.html" class="sidebar-link">21. 合并两个有序链表</a></li><li><a href="/blog/pages/算法/链表/82.分隔链表.html" class="sidebar-link">82.分隔链表</a></li><li><a href="/blog/pages/算法/链表/82.删除排序链表中的重复元素 II.html" class="sidebar-link">82.删除排序链表中的重复元素 II</a></li><li><a href="/blog/pages/算法/链表/83.删除排序链表中的重复元素.html" class="sidebar-link">83.删除排序链表中的重复元素</a></li><li><a href="/blog/pages/算法/链表/92.反转链表II.html" class="sidebar-link">92.反转链表II</a></li><li><a href="/blog/pages/算法/链表/141. 环形链表.html" class="sidebar-link">141. 环形链表</a></li><li><a href="/blog/pages/算法/链表/142. 环形链表 II.html" class="sidebar-link">142. 环形链表 II</a></li><li><a href="/blog/pages/算法/链表/160. 相交链表.html" class="sidebar-link">160. 相交链表</a></li><li><a href="/blog/pages/算法/链表/206. 反转链表.html" class="sidebar-link">206. 反转链表</a></li></ul></section></li></ul></section></li><li><section class="sidebar-group depth-0"><a href="/blog/pages/%E9%80%9A%E7%94%A8%E7%AE%80%E5%8E%86/common" class="sidebar-heading clickable"><span>通用简历</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/pages/通用简历/common.html" class="sidebar-link">common</a></li></ul></section></li><li><section class="sidebar-group depth-0"><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/0.resume" class="sidebar-heading clickable open"><span>速记区</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/pages/速记区/0.resume.html" class="sidebar-link">0.resume</a></li><li><a href="/blog/pages/速记区/1.浏览器网络篇.html" class="sidebar-link">1.浏览器网络篇</a></li><li><a href="/blog/pages/速记区/2.CSS篇.html" class="sidebar-link">2.CSS篇</a></li><li><a href="/blog/pages/速记区/3.HTML篇.html" class="sidebar-link">3.HTML篇</a></li><li><a href="/blog/pages/速记区/4.JS篇上.html" class="sidebar-link">4.JS篇上</a></li><li><a href="/blog/pages/速记区/5.JS篇下.html" class="active sidebar-link">5.JS篇下</a></li><li><a href="/blog/pages/速记区/6.代码篇.html" class="sidebar-link">6.代码篇</a></li><li><a href="/blog/pages/速记区/7.VUE上.html" class="sidebar-link">7.VUE上</a></li><li><a href="/blog/pages/速记区/8.VUE下.html" class="sidebar-link">8.VUE下</a></li><li><a href="/blog/pages/速记区/9.VUE3+TS.html" class="sidebar-link">9.VUE3+TS</a></li><li><a href="/blog/pages/速记区/10.node+webpack+性能优化.html" class="sidebar-link">10.node+webpack+性能优化</a></li><li><a href="/blog/pages/速记区/11.小程序+git.html" class="sidebar-link">11.小程序+git</a></li><li><a href="/blog/pages/速记区/12.大前端.html" class="sidebar-link">12.大前端</a></li></ul></section></li><li><section class="sidebar-group depth-0"><a href="/blog/pages/%E9%A1%B9%E7%9B%AE%E9%9A%BE%E7%82%B9%E4%BA%AE%E7%82%B9/1.%E5%89%8D%E7%AB%AF%E5%AF%BC%E5%87%BAExcel%E6%96%87%E4%BB%B6%E8%BF%87%E4%BA%8E%E5%BA%9E%E5%A4%A7%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86" class="sidebar-heading clickable"><span>项目难点亮点</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/pages/项目难点亮点/1.前端导出Excel文件过于庞大怎么处理.html" class="sidebar-link">1.前端导出Excel文件过于庞大怎么处理</a></li><li><a href="/blog/pages/项目难点亮点/2.表单的批量校验.html" class="sidebar-link">2.表单的批量校验</a></li><li><a href="/blog/pages/项目难点亮点/3.前端项目线上出现紧急的bug怎么处理.html" class="sidebar-link">3.前端项目线上出现紧急的bug怎么处理</a></li><li><a href="/blog/pages/项目难点亮点/4.vue刷新当前页面.html" class="sidebar-link">4.vue刷新当前页面</a></li><li><a href="/blog/pages/项目难点亮点/5.vue页面缓存控制.html" class="sidebar-link">5.vue页面缓存控制</a></li><li><a href="/blog/pages/项目难点亮点/6.vue阻止重复请求.html" class="sidebar-link">6.vue阻止重复请求</a></li><li><a href="/blog/pages/项目难点亮点/7.vue表格列拖拽.html" class="sidebar-link">7.vue表格列拖拽</a></li><li><a href="/blog/pages/项目难点亮点/8.动态显示提示语.html" class="sidebar-link">8.动态显示提示语</a></li><li><a href="/blog/pages/项目难点亮点/9.宽度不确定的文本省略号.html" class="sidebar-link">9.宽度不确定的文本省略号</a></li><li><a href="/blog/pages/项目难点亮点/10.SSE和websocket.html" class="sidebar-link">10.SSE和websocket</a></li></ul></section></li></ul> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-59e6cb88 data-v-7dd95ae2><h3 class="title" data-v-59e6cb88></h3> <!----> <label id="box" class="inputBox" data-v-59e6cb88><input type="password" value="" data-v-59e6cb88> <span data-v-59e6cb88>Konck! Knock!</span> <button data-v-59e6cb88>OK</button></label> <div class="footer" data-v-59e6cb88><span data-v-59e6cb88><i class="iconfont reco-theme" data-v-59e6cb88></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-59e6cb88>vuePress-theme-reco</a></span> <span data-v-59e6cb88><i class="iconfont reco-copyright" data-v-59e6cb88></i> <a data-v-59e6cb88><!---->
          
        <!---->
        2024
      </a></span></div></div> <div data-v-7dd95ae2><div data-v-7dd95ae2><main class="page"><section style="display:;"><div class="page-title"><h1 class="title">四、原型与继承</h1> <div data-v-8a445198><!----> <!----> <!----> <!----></div></div> <div class="theme-reco-content content__default"><h2 id="四、原型与继承"><a href="#四、原型与继承" class="header-anchor">#</a> 四、原型与继承</h2> <h2 id="_4-1-说说面向对象的特性与特点"><a href="#_4-1-说说面向对象的特性与特点" class="header-anchor">#</a> 4.1 说说面向对象的特性与特点</h2> <ul><li>封装性</li> <li>继承性</li> <li>多态性</li></ul> <p>面向对象编程具有灵活、代码可复用、容易维护和开发的有点、更适合多人合作的大型软件项目</p> <h2 id="_4-2-说说你对工厂模式的理解"><a href="#_4-2-说说你对工厂模式的理解" class="header-anchor">#</a> 4.2 说说你对工厂模式的理解</h2> <p>工厂模式是用来创建对象的一种最常用的设计模式，不暴露创建对象的具体逻辑，而是将将逻辑封装在一个函数中，那么这个函数就可以被视为一个工厂</p> <p>其就像工厂一样重复的产生类似的产品，工厂模式只需要我们传入正确的参数，就能生产类似的产品</p> <h2 id="_4-3-创建对象有哪几种方式"><a href="#_4-3-创建对象有哪几种方式" class="header-anchor">#</a> 4.3 创建对象有哪几种方式？</h2> <ol><li><p>字面量的形式直接创建对象</p></li> <li><p>函数方法</p> <ol start="0"><li><strong>工厂模式</strong>，工厂模式的主要工作原理是用函数来封装创建对象的细节，从而通过调用函数来达到复用的目的。</li> <li><strong>构造函数模式</strong></li> <li><strong>原型模式</strong></li> <li><strong>构造函数模式+原型模式</strong>，这是创建自定义类型的最常见方式。</li> <li><strong>动态原型模式</strong></li> <li><strong>寄生构造函数模式</strong></li></ol></li> <li><p>class 创建</p></li></ol> <h2 id="_4-4-js-宿主对象和原生对象的区别"><a href="#_4-4-js-宿主对象和原生对象的区别" class="header-anchor">#</a> 4.4 JS 宿主对象和原生对象的区别</h2> <p><code>原生对象</code></p> <p>“<code>独立于宿主环境的 ECMAScript 实现提供的对象</code>”</p> <p>包含：Object、Function、Array、String、Boolean、Number、Date、RegExp、Error、EvalError、RangeError、ReferenceError、SyntaxError、TypeError、URIError</p> <p><code>内置对象</code></p> <p>开发者不必明确实例化内置对象，它已被内部实例化了</p> <p>同样是“独立于宿主环境”。而 ECMA-262 只定义了两个内置对象，即 Global 和 Math</p> <p><code>宿主对象</code></p> <p>BOM 和 DOM 都是宿主对象。因为其对于不同的“宿主”环境所展示的内容不同。其实说白了就是，ECMAScript 官方未定义的对象都属于宿主对象，因为其未定义的对象大多数是自己通过 ECMAScript 程序创建的对象</p> <h2 id="_4-5-javascript-内置的常用对象有哪些-并列举该对象常用的方法"><a href="#_4-5-javascript-内置的常用对象有哪些-并列举该对象常用的方法" class="header-anchor">#</a> 4.5 JavaScript 内置的常用对象有哪些？并列举该对象常用的方法？</h2> <p><strong>Number 数值对象，数值常用方法</strong></p> <ul><li>Number.toFixed( ) 采用定点计数法格式化数字</li> <li>Number.toString( ) 将—个数字转换成字符串</li> <li>Number.valueOf( ) 返回原始数值</li></ul> <p><strong>String 字符串对象，字符串常用方法</strong></p> <ul><li>Length 获取字符串的长度</li> <li>split()将一个字符串切割数组</li> <li>concat() 连接字符串</li> <li>indexOf()返回一个子字符串在原始字符串中的索引值。如果没有找到，则返回固定值 -1</li> <li>lastIndexOf() 从后向前检索一个字符串</li> <li>slice() 抽取一个子串</li></ul> <p><strong>Boolean 布尔对象，布尔常用方法</strong></p> <ul><li>Boolean.toString() 将布尔值转换成字符串</li> <li>Boolean.valueOf() Boolean 对象的原始值的布尔值</li></ul> <p><strong>Array 数组对象，数组常用方法</strong></p> <ul><li>join() 将一个数组转成字符串。返回一个字符串</li> <li>reverse() 将数组中各元素颠倒顺序</li> <li>delete 运算符只能删除数组元素的值，而所占空间还在，总长度没变(arr.length)</li> <li>shift()删除数组中第一个元素，返回删除的那个值，并将长度减 1</li> <li>pop()删除数组中最后一个元素，返回删除的那个值，并将长度减 1</li> <li>unshift() 往数组前面添加一个或多个数组元素，长度会改变</li> <li>push() 往数组结尾添加一个或多个数组元素，长度会改变</li> <li>concat() 连接数组</li> <li>slice() 切割数组，返回数组的一部分</li> <li>splice()插入、删除或替换数组的元素</li> <li>toLocaleString() 把数组转换成局部字符串</li> <li>toString()将数组转换成一个字符串</li> <li>forEach()遍历所有元素</li> <li>every()判断所有元素是否都符合条件</li> <li>sort()对数组元素进行排序</li> <li>map()对元素重新组装，生成新数组</li> <li>filter()过滤符合条件的元素</li> <li>find() 查找 返回满足提供的测试函数的第一个元素的值。否则返回 undefined。</li> <li>some() 判断是否有一个满足条件 ，返回布尔值</li> <li>fill() 填充数组</li> <li>flat() 数组扁平化</li></ul> <p><strong>Function 函数对象，函数常用方法</strong></p> <ul><li>Function.arguments 传递给函数的参数</li> <li>Function.apply() 将函数作为一个对象的方法调用</li> <li>Function.call() 将函数作为对象的方法调用</li> <li>Function.caller 调用当前函数的函数</li> <li>Function.length 已声明的参数的个数</li> <li>Function.prototype 对象类的原型</li> <li>Function.toString() 把函数转换成字符串</li></ul> <p><strong>Object 基础对象，对象常用方法</strong></p> <ul><li>Object 含有所有 JavaScript 对象的特性的超类</li> <li>Object.constructor 对象的构造函数</li> <li>Object.hasOwnProperty( ) 检查属性是否被继承</li> <li>Object.isPrototypeOf( ) 一个对象是否是另一个对象的原型</li> <li>Object.propertyIsEnumerable( ) 是否可以通过 for/in 循环看到属性</li> <li>Object.toLocaleString( ) 返回对象的本地字符串表示</li> <li>Object.toString( ) 定义一个对象的字符串表示</li> <li>Object.valueOf( ) 指定对象的原始值</li></ul> <p><strong>Date 日期时间对象，日期常用方法</strong></p> <ul><li>Date.getFullYear() 返回 Date 对象的年份字段</li> <li>Date.getMonth() 返回 Date 对象的月份字段</li> <li>Date.getDate() 返回一个月中的某一天</li> <li>Date.getDay() 返回一周中的某一天</li> <li>Date.getHours() 返回 Date 对象的小时字段</li> <li>Date.getMinutes() 返回 Date 对象的分钟字段</li> <li>Date.getSeconds() 返回 Date 对象的秒字段</li> <li>Date.getMilliseconds() 返回 Date 对象的毫秒字段</li> <li>Date.getTime() 返回 Date 对象的毫秒表示</li></ul> <p><strong>Math 数学对象，数学常用方法</strong></p> <ul><li>Math 对象是一个<code>静态对象</code></li> <li>Math.PI 圆周率</li> <li>Math.abs() 绝对值</li> <li>Math.ceil() 向上取整(整数加 1，小数去掉)</li> <li>Math.floor() 向下取整(直接去掉小数)</li> <li>Math.round() 四舍五入</li> <li>Math.pow(x，y) 求 x 的 y 次方</li> <li>Math.sqrt() 求平方根</li></ul> <p><strong>RegExp 正则表达式对象，正则常用方法</strong></p> <ul><li>RegExp.exec() 检索字符串中指定的值。返回找到的值，并确定其位置。</li> <li>RegExp.test( ) 检索字符串中指定的值。返回 true 或 false。</li> <li>RegExp.toString( ) 把正则表达式转换成字符串</li> <li>RegExp.globa 判断是否设置了 &quot;g&quot; 修饰符</li> <li>RegExp.ignoreCase 判断是否设置了 &quot;i&quot; 修饰符</li> <li>RegExp.lastIndex 用于规定下次匹配的起始位置</li> <li>RegExp.source 返回正则表达式的匹配模式</li></ul> <p><strong>Error 异常对象</strong></p> <ul><li>Error.message 设置或返回一个错误信息(字符串)</li> <li>Error.name 设置或返回一个错误名</li> <li>Error.toString( ) 把 Error 对象转换成字符串</li></ul> <h2 id="_4-6-说一下-hasownproperty、instanceof-方法"><a href="#_4-6-说一下-hasownproperty、instanceof-方法" class="header-anchor">#</a> 4.6 说一下 hasOwnProperty、instanceof 方法</h2> <p><strong>hasOwnProperty()</strong> 方法会返回一个布尔值，指示对象自身属性中是否具有指定的属性（也就是，是否有指定的键）。</p> <p><strong>instanceof</strong> <strong>运算符</strong>用于检测构造函数的 <code>prototype</code> 属性是否出现在某个实例对象的原型链上。</p> <h2 id="_4-7-什么是原型对象-说说对它的理解"><a href="#_4-7-什么是原型对象-说说对它的理解" class="header-anchor">#</a> 4.7 什么是原型对象，说说对它的理解</h2> <p><strong>构造函数的内部的 prototype 属性指向的对象，就是构造函数的原型对象。</strong></p> <p>原型对象包含了可以由该构造函数的所有实例共享的属性和方法。当使用构造函数新建一个实例对象后，在这个对象的内部将包含一个指针(*<strong>*proto**</strong>)，这个指针指向构造函数的 原型对象，在 ES5 中这个指针被称为对象的原型。</p> <h2 id="_4-8-什么是原型链"><a href="#_4-8-什么是原型链" class="header-anchor">#</a> 4.8 什么是原型链</h2> <p><strong>原型链是一种查找规则</strong></p> <p>当访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象又会有自己的原型，于是就这样一直找下去，这种链式查找过程称之为原型链</p> <h2 id="_4-9-原型链的终点是什么"><a href="#_4-9-原型链的终点是什么" class="header-anchor">#</a> 4.9 原型链的终点是什么？</h2> <p>原型链的尽头是 null。也就是**Object.prototype.**proto****</p> <h2 id="_4-10-基于-js-原型链-实现继承"><a href="#_4-10-基于-js-原型链-实现继承" class="header-anchor">#</a> 4.10 基于 JS 原型链 实现继承</h2> <h3 id="_1-原型链继承"><a href="#_1-原型链继承" class="header-anchor">#</a> 1.原型链继承</h3> <p><strong>关键：子类构造函数的原型为父类构造函数的实例对象</strong></p> <p><strong>缺点</strong>：</p> <ul><li><p>1、子类构造函数无法向父类构造函数传参。</p></li> <li><p>2、所有的子类实例共享着一个原型对象，一旦原型对象的属性发生改变，所有子类的实例对象都会收影响</p></li> <li><p>3、如果要给子类的原型上添加方法，必须放在 Son.prototype = new Father()语句后面</p></li></ul> <div class="language-javascript line-numbers-mode"><div class="highlight-lines"><br><br><br><br><br><br><br><br><br><div class="highlighted"> </div><br><div class="highlighted"> </div><br><br><br><br><br><br><br><br><br><br><br><br></div><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Father</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token class-name">Father</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">showName</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">Son</span><span class="token punctuation">(</span><span class="token parameter">age</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 原型链继承,将子函数的原型绑定到父函数的实例上,子函数可以通过原型链查找到复函数的原型,实现继承</span>
<span class="token class-name">Son</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Father</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 将Son原型的构造函数指回Son, 否则Son实例的constructor会指向Father</span>
<span class="token class-name">Son</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> Son<span class="token punctuation">;</span>

<span class="token class-name">Son</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">showAge</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> son <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Son</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">,</span> <span class="token string">'刘逍'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 无法向父构造函数里传参</span>
<span class="token comment">// 子类构造函数的实例继承了父类构造函数原型的属性,所以可以访问到父类构造函数原型里的showName方法</span>
<span class="token comment">// 子类构造函数的实例继承了父类构造函数的属性,但是无法传参赋值,所以是this.name是undefined</span>
son<span class="token punctuation">.</span><span class="token function">showName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// undefined</span>
son<span class="token punctuation">.</span><span class="token function">showAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 20</span>
</code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br></div></div><h3 id="_2-借用构造函数继承"><a href="#_2-借用构造函数继承" class="header-anchor">#</a> 2.借用构造函数继承</h3> <p><strong>关键：用 .call() 和 .apply()方法,在子类构造函数中,调用父类构造函数</strong></p> <p><strong>缺点</strong>：1、只继承了父类构造函数的属性，没有继承父类原型的属性。</p> <p>2、无法实现函数复用，如果父类构造函数里面有一个方法，会导致每一个子类实例上面都有相同的方法。</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Father</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token class-name">Father</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">showName</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">Son</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">Father</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 在Son中借用了Father函数,只继承了父类构造函数的属性，没有继承父类原型的属性。 // 相当于 this.name = name</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Son</span><span class="token punctuation">(</span><span class="token string">'刘逍'</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 可以给父构造函数传参</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// '刘逍'</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>showName<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// undefined</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><h3 id="_3-组合继承"><a href="#_3-组合继承" class="header-anchor">#</a> 3.组合继承</h3> <p><strong>关键：原型链继承+借用构造函数继承</strong></p> <p><strong>缺点</strong>：1、使用组合继承时，父类构造函数会被调用两次，子类实例对象与子类的原型上会有相同的方法与属性，浪费内存。</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Father</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function-variable function">say</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'hello,world'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token class-name">Father</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">showName</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">Son</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">Father</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//借用构造函数继承</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token comment">// 原型链继承</span>
<span class="token class-name">Son</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Father</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Son实例的原型上,会有同样的属性,父类构造函数相当于调用了两次 // 将Son原型的构造函数指回Son, 否则Son实例的constructor会指向Father</span>
<span class="token class-name">Son</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> Son<span class="token punctuation">;</span>
<span class="token class-name">Son</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">showAge</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Son</span><span class="token punctuation">(</span><span class="token string">'刘逍'</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 可以向父构造函数里传参 // 也继承了父函数原型上的方法</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
p<span class="token punctuation">.</span><span class="token function">showName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// '刘逍'</span>
p<span class="token punctuation">.</span><span class="token function">showAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 20</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><h3 id="_4-原型式继承"><a href="#_4-原型式继承" class="header-anchor">#</a> 4.原型式继承</h3> <p><strong>关键：创建一个函数，将要继承的对象通过参数传递给这个函数，最终返回一个对象，它的隐式原型指向传入的对象。</strong> (<strong><em>Object.create()方法的底层就是原型式继承</em></strong>)</p> <p><strong>缺点</strong>：只能继承父类函数原型对象上的属性和方法，无法给父类构造函数传参</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">createObj</span><span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">function</span> <span class="token constant">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">// 声明一个构造函数</span>
  <span class="token class-name">F</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> obj<span class="token punctuation">;</span> <span class="token comment">//将这个构造函数的原型指向传入的对象</span>
  <span class="token class-name">F</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>construct <span class="token operator">=</span> <span class="token constant">F</span><span class="token punctuation">;</span> <span class="token comment">// construct属性指回子类构造函数</span>
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 返回子类构造函数的实例</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">Father</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'刘逍'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token class-name">Father</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">showName</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> son <span class="token operator">=</span> <span class="token function">createObj</span><span class="token punctuation">(</span><span class="token class-name">Father</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>
son<span class="token punctuation">.</span><span class="token function">showName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// undefined  继承了原型上的方法,但是没有继承构造函数里的name属性</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><h3 id="_5-寄生式继承"><a href="#_5-寄生式继承" class="header-anchor">#</a> 5.寄生式继承</h3> <p><strong>关键：在原型式继承的函数里，给继承的对象上添加属性和方法，增强这个对象</strong></p> <p><strong>缺点</strong>：只能继承父类函数原型对象上的属性和方法，无法给父类构造函数传参</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">createObj</span><span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">function</span> <span class="token constant">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token class-name">F</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> obj<span class="token punctuation">;</span>
  <span class="token class-name">F</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>construct <span class="token operator">=</span> <span class="token constant">F</span><span class="token punctuation">;</span>
  <span class="token class-name">F</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span> <span class="token comment">// 给F函数的原型添加属性和方法,增强对象</span>
  <span class="token class-name">F</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">showAge</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">Father</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'刘逍'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token class-name">Father</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">showName</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> son <span class="token operator">=</span> <span class="token function">createObj</span><span class="token punctuation">(</span><span class="token class-name">Father</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>
son<span class="token punctuation">.</span><span class="token function">showName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// undefined</span>
son<span class="token punctuation">.</span><span class="token function">showAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 20</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><h3 id="_6-寄生组合继承"><a href="#_6-寄生组合继承" class="header-anchor">#</a> 6.寄生组合继承</h3> <p><strong>关键：原型式继承 + 构造函数继承</strong></p> <p><strong>Js 最佳的继承方式，只调用了一次父类构造函数</strong></p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Father</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function-variable function">say</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'hello,world'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token class-name">Father</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">showName</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">Son</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">Father</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token class-name">Son</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token class-name">Father</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Object.create方法返回一个对象，它的隐式原型指向传入的对象。</span>
<span class="token class-name">Son</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> Son<span class="token punctuation">;</span>
<span class="token keyword">const</span> son <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Son</span><span class="token punctuation">(</span><span class="token string">'刘逍'</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>son<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 原型上已经没有name属性了,所以这里会报错</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><h3 id="_7-混入继承"><a href="#_7-混入继承" class="header-anchor">#</a> 7.混入继承</h3> <p><strong>关键：利用 Object.assign 的方法多个父类函数的原型拷贝给子类原型</strong></p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code>  <span class="token keyword">function</span> <span class="token function">Father</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name
    <span class="token punctuation">}</span>
    Father<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">showName</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
​
    <span class="token keyword">function</span> <span class="token function">Mather</span><span class="token punctuation">(</span><span class="token parameter">color</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>color <span class="token operator">=</span> color
    <span class="token punctuation">}</span>
    Mather<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">showColor</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>color<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
​
    <span class="token keyword">function</span> <span class="token function">Son</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> color<span class="token punctuation">,</span> age</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 调用两个父类函数</span>
      <span class="token function">Father</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span>
      <span class="token function">Mather</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> color<span class="token punctuation">)</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age
    <span class="token punctuation">}</span>
    Son<span class="token punctuation">.</span>prototype <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token class-name">Father</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span>
    Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span><span class="token class-name">Son</span><span class="token punctuation">.</span>prototype<span class="token punctuation">,</span> <span class="token class-name">Mather</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span>  <span class="token comment">// 将Mather父类函数的原型拷贝给子类函数</span>
    <span class="token keyword">const</span> son <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Son</span><span class="token punctuation">(</span><span class="token string">'刘逍'</span><span class="token punctuation">,</span> <span class="token string">'red'</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span>
    son<span class="token punctuation">.</span><span class="token function">showColor</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">// red</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br></div></div><h3 id="_8-class-继承"><a href="#_8-class-继承" class="header-anchor">#</a> 8. class 继承</h3> <p><strong>关键：class 里的 extends 和 super 关键字，继承效果与寄生组合继承一样</strong></p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">class</span> <span class="token class-name">Father</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">showName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">Son</span> <span class="token keyword">extends</span> <span class="token class-name">Father</span> <span class="token punctuation">{</span>
  <span class="token comment">// 子类通过extends继承父类</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 调用父类里的constructor函数,等同于Father.call(this,name)</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">showAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> son <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Son</span><span class="token punctuation">(</span><span class="token string">'刘逍'</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
son<span class="token punctuation">.</span><span class="token function">showName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// '刘逍'</span>
son<span class="token punctuation">.</span><span class="token function">showAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 20</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><h2 id="五、异步与事件循环"><a href="#五、异步与事件循环" class="header-anchor">#</a> 五、异步与事件循环</h2> <h2 id="_5-1-异步编程的实现方式"><a href="#_5-1-异步编程的实现方式" class="header-anchor">#</a> 5.1. 异步编程的实现方式?</h2> <p>JavaScript 中的异步机制可以分为以下几种：</p> <ul><li><strong>回调函数</strong> 的方式，使用回调函数的方式有一个缺点是，多个回调函数嵌套的时候会造成回调函数地狱，上下两层的回调函数间的代码耦合度太高，不利于代码的可维护。</li> <li><strong>Promise</strong> 的方式，使用 Promise 的方式可以将嵌套的回调函数作为链式调用。但是使用这种方法，有时会造成多个 then 的链式调用，可能会造成代码的语义不够明确。</li> <li><strong>generator</strong> 的方式，它可以在函数的执行过程中，将函数的执行权转移出去，在函数外部还可以将执行权转移回来。当遇到异步函数执行的时候，将函数执行权转移出去，当异步函数执行完毕时再将执行权给转移回来。因此在 generator 内部对于异步操作的方式，可以以同步的顺序来书写。使用这种方式需要考虑的问题是何时将函数的控制权转移回来，因此需要有一个自动执行 generator 的机制，比如说 co 模块等方式来实现 generator 的自动执行。</li> <li><strong>async 函数</strong> 的方式，async 函数是 generator 和 promise 实现的一个自动执行的语法糖，它内部自带执行器，当函数内部执行到一个 await 语句的时候，如果语句返回一个 promise 对象，那么函数将会等待 promise 对象的状态变为 resolve 后再继续向下执行。因此可以将异步逻辑，转化为同步的顺序来书写，并且这个函数可以自动执行。</li></ul> <h2 id="_5-2-并发与并行的区别"><a href="#_5-2-并发与并行的区别" class="header-anchor">#</a> 5.2 并发与并行的区别？</h2> <ul><li>并发是宏观概念，我分别有任务 A 和任务 B，在一段时间内通过任务间的切换完成了这两个任务，这种情况就可以称之为并发。</li> <li>并行是微观概念，假设 CPU 中存在两个核心，那么我就可以同时完成任务 A、B。同时完成多个任务的情况就可以称之为并行。</li></ul> <h2 id="_5-3-settimeout、setinterval、requestanimationframe-的区别"><a href="#_5-3-settimeout、setinterval、requestanimationframe-的区别" class="header-anchor">#</a> 5.3 setTimeout、setInterval、requestAnimationFrame 的区别</h2> <ul><li><strong>setTimeout</strong></li></ul> <p>执行该语句时，是立即把当前定时器代码推入事件队列，当定时器在事件列表中满足设置的时间值时将传入的函数加入任务队列，之后的执行就交给任务队列负责。但是如果此时任务队列不为空，则需等待，所以执行定时器内代码的时间可能会大于设置的时间。</p> <p>返回值<code>timeoutID</code>是一个正整数，表示定时器的编号。这个值可以传递给<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/clearTimeout" title="https://developer.mozilla.org/zh-CN/docs/Web/API/clearTimeout" target="_blank" rel="noopener noreferrer"><code>clearTimeout()</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>来取消该定时器。</p> <ul><li><strong>setInterval</strong></li></ul> <p>重复调用一个函数或执行一个代码片段，每次都精确的隔一段时间推入一个事件（但是，事件的执行时间不一定就不准确，还有可能是这个事件还没执行完毕，下一个事件就来了）。它返回一个 <code>interval ID</code>，该 ID 唯一地标识时间间隔，因此你可以稍后通过调用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/clearInterval" title="https://developer.mozilla.org/zh-CN/docs/Web/API/clearInterval" target="_blank" rel="noopener noreferrer"><code>clearInterval()</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 来移除定时器。</p> <p><strong>技术上，<code>clearTimeout()</code> 和 <code>clearInterval()</code>可以互换。但是，为了避免混淆，不要混用取消定时函数。</strong></p> <ul><li><strong>requestAnimationFrame</strong></li></ul> <p>是 JS 实现动画的一种方式，它告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行</p> <h2 id="_5-4-什么是回调地狱-回调地狱会带来什么问题"><a href="#_5-4-什么是回调地狱-回调地狱会带来什么问题" class="header-anchor">#</a> 5.4. 什么是回调地狱？回调地狱会带来什么问题？</h2> <p>回调函数的层层嵌套，就叫做回调地狱。回调地狱会造成代码可复用性不强，可阅读性差，可维护性(迭代性差)，扩展性差等等问题。</p> <h2 id="promise-语法"><a href="#promise-语法" class="header-anchor">#</a> Promise 语法</h2> <h2 id="_5-5-promise-是什么"><a href="#_5-5-promise-是什么" class="header-anchor">#</a> 5.5. Promise 是什么</h2> <p>Promise 是异步编程的一种解决方案，它是一个对象，可以获取异步操作的消息，他的出现大大改善了异步编程的困境，避免了地狱回调，它比传统的解决方案回调函数和事件更合理和更强大。</p> <p><strong>promise 本身只是一个容器,真正异步的是它的两个回调 resolve()和 reject()</strong></p> <p><strong>promise 本质 不是控制 异步代码的执行顺序（无法控制） ， 而是控制异步代码结果处理的顺序</strong></p> <h2 id="_5-6-promise-实例有哪些状态-怎么改变状态"><a href="#_5-6-promise-实例有哪些状态-怎么改变状态" class="header-anchor">#</a> 5.6 promise 实例有哪些状态，怎么改变状态</h2> <p>（1）Promise 的实例有<strong>三个状态</strong>:</p> <ul><li>Pending（进行中）</li> <li>Resolved（已完成）</li> <li>Rejected（已拒绝）</li></ul> <p>当把一件事情交给 promise 时，它的状态就是 Pending，任务完成了状态就变成了 Resolved、没有完成失败了就变成了 Rejected。</p> <p><strong>如何改变 promise 的状态</strong></p> <ul><li>resolve(value): 如果当前是 pending 就会变为 resolved</li> <li>reject(error): 如果当前是 pending 就会变为 rejected</li> <li>抛出异常: 如果当前是 pending 就会变为 rejected</li></ul> <p>注意：一旦从进行状态变成为其他状态就永远不能更改状态了。</p> <h2 id="_5-7-创建-promise-实例有哪些方法"><a href="#_5-7-创建-promise-实例有哪些方法" class="header-anchor">#</a> 5.7 创建 Promise 实例有哪些方法</h2> <ul><li><strong>new Promise((resolve,reject)=&gt;{</strong> ... <strong>})</strong></li></ul> <p><strong>一般情况下都会使用</strong><code>new Promise()</code><strong>来创建 promise 对象，但是也可以使用</strong><code>promise.resolve</code><strong>和</strong><code>promise.reject</code><strong>这两个方法：</strong></p> <ul><li><strong>Promise.resolve</strong></li></ul> <p><code>Promise.resolve(value)</code>的返回值也是一个 promise 对象，可以对返回值进行.then 调用，代码如下：</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code>Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 打印出11</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><ul><li><strong>Promise.reject</strong></li></ul> <p><code>Promise.reject</code> 也是<code>new Promise</code>的快捷形式，也创建一个 promise 对象。代码如下：</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code>Promise<span class="token punctuation">.</span><span class="token function">reject</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span>“出错了！！”<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="_5-8-promise-有哪些实例方法"><a href="#_5-8-promise-有哪些实例方法" class="header-anchor">#</a> 5.8 Promise 有哪些实例方法</h2> <p><strong>then</strong></p> <p><code>then</code>方法可以接受两个回调函数作为参数。第一个回调函数是 Promise 对象的状态变为<code>resolved</code>时调用，第二个回调函数是 Promise 对象的状态变为<code>rejected</code>时调用。其中第二个参数可以省略。 <code>then</code>方法返回的是一个新的 Promise 实例（不是原来那个 Promise 实例）。因此可以采用链式写法，即<code>then</code>方法后面再调用另一个 then 方法。</p> <p><strong>catch</strong></p> <p>该方法相当于<code>then</code>方法的第二个参数，指向<code>reject</code>的回调函数。不过<code>catch</code>方法还有一个作用，就是在执行<code>resolve</code>回调函数时，如果出现错误，抛出异常，不会停止运行，而是进入<code>catch</code>方法中。</p> <p><strong>finally</strong></p> <p><code>finally</code>方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的。</p> <p>下面是一个例子，服务器使用 Promise 处理请求，然后使用<code>finally</code>方法关掉服务器。</p> <div class="language-scss line-numbers-mode"><pre class="language-scss"><code>server.<span class="token function">listen</span><span class="token punctuation">(</span>port<span class="token punctuation">)</span>
  .<span class="token function">then</span><span class="token punctuation">(</span>function <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  .<span class="token function">finally</span><span class="token punctuation">(</span>server.stop<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p><code>finally</code>方法的回调函数不接受任何参数，这意味着没有办法知道，前面的 Promise 状态到底是<code>fulfilled</code>还是<code>rejected</code>。这表明，<code>finally</code>方法里面的操作，应该是与状态无关的，不依赖于 Promise 的执行结果。</p> <h2 id="_5-9-promise-有哪些静态方法"><a href="#_5-9-promise-有哪些静态方法" class="header-anchor">#</a> 5.9 Promise 有哪些静态方法</h2> <p><strong>all</strong></p> <p><code>all</code>方法可以完成并发任务， 它接收一个数组，数组的每一项都是一个<code>promise</code>对象，返回一个<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise" title="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank" rel="noopener noreferrer"><code>Promise</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>实例。当数组中所有的<code>promise</code>的状态都达到<code>resolved</code>的时候，<code>all</code>方法的状态就会变成<code>resolved</code>，如果有一个状态变成了<code>rejected</code>，那么<code>all</code>方法的状态就会变成<code>rejected</code>。</p> <p><strong>race</strong></p> <p><code>race</code>方法和<code>all</code>一样，接受的参数是一个每项都是<code>promise</code>的数组，但是与<code>all</code>不同的是，当最先执行完的事件执行完之后，就直接返回该<code>promise</code>对象的值。如果第一个<code>promise</code>对象状态变成<code>resolved</code>，那自身的状态变成了<code>resolved</code>；反之第一个<code>promise</code>变成<code>rejected</code>，那自身状态就会变成<code>rejected</code>。</p> <p><strong>any</strong></p> <p>它接收一个数组，数组的每一项都是一个<code>promise</code>对象，该方法会返回一个新的 <code>promise</code>，数组内的任意一个 <code>promise</code> 变成了<code>resolved</code>状态，那么由该方法所返回的 <code>promise</code> 就会变成<code>resolved</code>状态。如果数组内的 <code>promise</code> 状态都是<code>rejected</code>，那么该方法所返回的 <code>promise</code> 就会变成<code>rejected</code>状态，</p> <p><strong>resolve、reject</strong></p> <p>用来生成对应状态的 Promise 实例</p> <h2 id="_5-10-promise-all、promise-race、promise-any-的区别"><a href="#_5-10-promise-all、promise-race、promise-any-的区别" class="header-anchor">#</a> 5.10 Promise.all、Promise.race、Promise.any 的区别</h2> <p><strong>all：</strong> 成功的时候返回的是<strong>一个结果数组</strong>，而失败的时候则返回<strong>最先被 reject 失败状态的值</strong>。</p> <p><strong>race：</strong> 哪个结果获得的快，就返回那个结果，不管结果本身是成功状态还是失败状态。</p> <p><strong>any：</strong> 返回最快的成功结果，如果全部失败就返回失败结果。</p> <h2 id="_5-11-一个-promise-指定多个回调函数-都会调用吗"><a href="#_5-11-一个-promise-指定多个回调函数-都会调用吗" class="header-anchor">#</a> 5.11 一个 promise 指定多个回调函数, 都会调用吗?</h2> <p>都会调用，成功状态放在 then 的第一个参数里调用</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">let</span> p2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
p2<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'第一个'</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
p2<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'第二个'</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>失败状态放在 then 的第二个参数里调用</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">let</span> p3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token function">reject</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
p3<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>
  <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'第一个'</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
p3<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>
  <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'第二个'</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><h2 id="_5-12-改变-promise-状态和指定回调函数谁先谁后"><a href="#_5-12-改变-promise-状态和指定回调函数谁先谁后" class="header-anchor">#</a> 5.12 改变 promise 状态和指定回调函数谁先谁后?</h2> <ol><li><p>都有可能, 正常情况下是先指定回调再改变状态, 但也可以先改状态再指定回调</p></li> <li><p>如何先改状态再指定回调?</p> <ul><li>在执行器中直接调用 resolve()/reject()</li> <li>延迟更长时间才调用 then()</li></ul></li> <li><p>什么时候才能得到数据?</p> <ul><li>如果先指定的回调, 那当状态发生改变时, 回调函数就会调用, 得到数据</li> <li>如果先改变的状态, 那当指定回调时, 回调函数就会调用, 得到数据</li></ul></li></ol> <h2 id="_5-13-promise-then-返回的新-promise-的结果状态由什么决定"><a href="#_5-13-promise-then-返回的新-promise-的结果状态由什么决定" class="header-anchor">#</a> 5.13 promise.then()返回的新 promise 的结果状态由什么决定?</h2> <ol start="0"><li><p>简单表达: 由 then()指定的回调函数执行的结果决定</p></li> <li><p>详细表达:</p> <ul><li>如果抛出异常, 新 promise 变为 rejected, 参数为抛出的异常</li> <li>如果返回的是非 promise 的任意值, 新 promise 变为 resolved, value 为返回的值</li> <li>如果返回的是另一个新 promise, 此 promise 的结果就会成为新 promise 的结果</li></ul></li></ol> <h2 id="_5-14-promise-如何串连多个操作任务"><a href="#_5-14-promise-如何串连多个操作任务" class="header-anchor">#</a> 5.14 promise 如何串连多个操作任务?</h2> <ul><li>promise 的 then()返回一个新的 promise, 可以开成 then()的链式调用</li> <li>通过 then 的链式调用串连多个同步/异步任务</li></ul> <h2 id="_5-15-promise-异常传透是什么"><a href="#_5-15-promise-异常传透是什么" class="header-anchor">#</a> 5.15 promise 异常传透是什么?</h2> <p>Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个<code>catch</code>语句捕获。</p> <ul><li>当使用 promise 的 then 链式调用时, 可以在最后指定失败的回调,</li> <li>前面任何操作出了异常, 都会传到最后失败的回调中处理</li></ul> <h2 id="_5-16-如何中断-promise-链"><a href="#_5-16-如何中断-promise-链" class="header-anchor">#</a> 5.16 如何中断 promise 链?</h2> <ul><li>当使用 promise 的 then 链式调用时, 在中间中断, 不再调用后面的回调函数。 在回调函数中返回一个 pendding 状态的 promise 对象</li></ul> <h2 id="_5-17-promise-有什么缺点"><a href="#_5-17-promise-有什么缺点" class="header-anchor">#</a> 5.17 promise 有什么缺点</h2> <p><strong>代码层面</strong></p> <ul><li>无法取消 Promise，一旦新建它就会立即执行，无法中途取消。</li> <li>如果不设置回调函数，Promise 内部抛出的错误，不会反应到外部。</li> <li>当处于 pending 状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</li></ul> <p><strong>语法层面</strong></p> <ul><li>Promise 虽然摆脱了回调地狱，但是 then 的链式调⽤也会带来额外的阅读负担</li> <li>Promise 传递中间值⾮常麻烦</li> <li>Promise 的调试很差，由于没有代码块，你不能在⼀个返回表达式的箭头函数中设置断点，如果你在⼀个.then 代码块中使⽤调试器的步进(step-over)功能，调试器并不会进⼊后续的.then 代码块，因为调试器只能跟踪同步代码的每⼀步。</li></ul> <h2 id="async-await-语法"><a href="#async-await-语法" class="header-anchor">#</a> async/await 语法</h2> <h2 id="_5-18-async-函数是什么"><a href="#_5-18-async-函数是什么" class="header-anchor">#</a> 5.18 async 函数是什么</h2> <ul><li>一句话概括： 它就是 Generator 函数的语法糖，也就是处理异步操作的另一种<code>高级写法</code></li></ul> <h2 id="_5-19-async-函数的实现原理"><a href="#_5-19-async-函数的实现原理" class="header-anchor">#</a> 5.19 async 函数的实现原理</h2> <p>async 函数的实现原理，就是将 Generator 函数和自动执行器，包装在一个函数里。</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token parameter">args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
​
<span class="token comment">// 等同于</span>
​
<span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token parameter">args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token function">spawn</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token operator">*</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// spawn函数就是自动执行器</span>
    <span class="token comment">// ...</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h2 id="_5-20-async-函数的返回值"><a href="#_5-20-async-函数的返回值" class="header-anchor">#</a> 5.20 async 函数的返回值</h2> <p><code>async</code>函数返回一个 Promise 对象。</p> <p><code>async</code>函数内部<code>return</code>语句返回的值，会成为<code>then</code>方法回调函数的参数。</p> <p><code>async</code>函数内部抛出错误，会导致返回的 Promise 对象变为<code>reject</code>状态。抛出的错误对象会被<code>catch</code>方法回调函数接收到。</p> <h2 id="_5-21-await-到底在等待什么"><a href="#_5-21-await-到底在等待什么" class="header-anchor">#</a> 5.21 await 到底在等待什么?</h2> <p>await 等待的是一个表达式，这个表达式的计算结果是 Promise 对象或者其它值（换句话说，就是没有特殊限定）。await 不仅仅用于等 Promise 对象，它可以等任意表达式的结果，所以，await 后面实际是可以接普通函数调用或者直接量的。</p> <p>await 表达式的运算结果取决于它等的是什么。</p> <ul><li>如果它等到的不是一个 Promise 对象，那 await 表达式的运算结果就是它等到的东西。</li> <li>如果它等到的是一个 Promise 对象，await 就忙起来了，它会阻塞后面的代码，等着 Promise 对象 resolve，然后得到 resolve 的值，作为 await 表达式的运算结果。</li></ul> <h2 id="_5-22-什么是顶层-await"><a href="#_5-22-什么是顶层-await" class="header-anchor">#</a> 5.22 什么是顶层 await？</h2> <p>从 ES2022 开始，允许在模块的顶层独立使用<code>await</code>命令，使得上面那行代码不会报错了。它的主要目的是使用<code>await</code><strong>解决模块异步加载的问题。</strong></p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> AsyncFun <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'module'</span><span class="token punctuation">;</span>
<span class="token keyword">await</span> <span class="token function">AsyncFun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h2 id="_5-23-如何用-await-让程序停顿指定的时间-休眠效果"><a href="#_5-23-如何用-await-让程序停顿指定的时间-休眠效果" class="header-anchor">#</a> 5.23 如何用 await 让程序停顿指定的时间(休眠效果)</h2> <p>JavaScript 一直没有休眠的语法，但是借助<code>await</code>命令就可以让程序停顿指定的时间</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token parameter">interval</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token parameter">resolve</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> interval<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
​
<span class="token comment">// 用法</span>
<span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">one2FiveInAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">await</span> <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
​
<span class="token function">one2FiveInAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><h2 id="_5-24-await-的使用注意点"><a href="#_5-24-await-的使用注意点" class="header-anchor">#</a> 5.24 await 的使用注意点</h2> <ol start="0"><li><code>await</code>命令后面的<code>Promise</code>对象，运行结果可能是<code>rejected</code>，所以最好把<code>await</code>命令放在<code>try...catch</code>代码块中。</li> <li>多个<code>await</code>命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。</li> <li><code>await</code>命令只能用在<code>async</code>函数之中，如果用在普通函数，就会报错。</li> <li>async 函数可以保留运行堆栈。</li></ol> <h2 id="_5-25-async-语法怎么捕获异常"><a href="#_5-25-async-语法怎么捕获异常" class="header-anchor">#</a> 5.25 async 语法怎么捕获异常</h2> <p><code>async</code>函数内部的异常可以通过 <code>.catch()</code>或者 <code>try</code>/<code>catch</code>来捕获,区别是</p> <ul><li>try/catch 能捕获所有异常,try 语句抛出错误后会执行 catch 语句，try 语句内后面的内容不会执行</li> <li>catch（）只能捕获异步方法中 reject 错误，并且 catch 语句之后的语句会继续执行</li></ul> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">async</span>函数错误捕获，以登录功能为例
      <span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">getCatch</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">await</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token function">reject</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'登录失败'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token parameter">error</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
          console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span>  <span class="token comment">// .catch（）能捕获到错误信息</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'登录成功'</span><span class="token punctuation">)</span> <span class="token comment">//  但是成功信息也会执行</span>
      <span class="token punctuation">}</span>
      
     <span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">getCatch</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
          <span class="token keyword">await</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">reject</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'登录失败'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
          <span class="token punctuation">}</span><span class="token punctuation">)</span>
          console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'登录成功'</span><span class="token punctuation">)</span>  <span class="token comment">// try抛出错误之后，就不会执行这条语句</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span>  <span class="token comment">//  catch语句能捕获到错误信息</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><h2 id="_5-26-async-await-对比-promise-的优势"><a href="#_5-26-async-await-对比-promise-的优势" class="header-anchor">#</a> 5.26 async/await 对比 Promise 的优势</h2> <ul><li>代码读起来更加同步，Promise 虽然摆脱了回调地狱，但是 then 的链式调⽤也会带来额外的阅读负担</li> <li>Promise 传递中间值⾮常麻烦，⽽ async/await ⼏乎是同步的写法，⾮常优雅</li> <li>错误处理友好，async/await 可以⽤成熟的 try/catch，Promise 的错误捕获⾮常冗余</li> <li>调试友好，Promise 的调试很差，由于没有代码块，你不能在⼀个返回表达式的箭头函数中设置断点，如果你在⼀个.then 代码块中使⽤调试器的步进(step-over)功能，调试器并不会进⼊后续的.then 代码块，因为调试器只能跟踪同步代码的每⼀步。</li></ul> <h2 id="事件循环-event-loop"><a href="#事件循环-event-loop" class="header-anchor">#</a> 事件循环 Event Loop</h2> <h2 id="_5-27-js-的执行机制-同步任务、异步任务"><a href="#_5-27-js-的执行机制-同步任务、异步任务" class="header-anchor">#</a> 5.27 JS 的执行机制(同步任务、异步任务)</h2> <p>JS 是一门单线程语言，单线程就意味着，所有的任务需要排队，前一个任务结束，才会执行下一个任务。这样所导致的问题是：如果 JS 执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的觉。为了解决这个问题，JS 中出现了同步和异步。</p> <p><strong>同步任务</strong>：即主线程上的任务，按照顺序由上⾄下依次执⾏，当前⼀个任务执⾏完毕后，才能执⾏下⼀个任务。</p> <p><strong>异步任务</strong>：不进⼊主线程，⽽是进⼊任务队列的任务，执行完毕之后会产生一个回调函数,并且通知主线程。当主线程上的任务执行完后，就会调取最早通知自己的回调函数，使其进入主线程中执行。</p> <h2 id="_5-28-什么是-event-loop"><a href="#_5-28-什么是-event-loop" class="header-anchor">#</a> 5.28 什么是 Event Loop</h2> <ul><li>事件循环 Event Loop 又叫事件队列，两者是一个概念</li></ul> <p>事件循环指的是 js 代码所在运行环境（浏览器、nodejs）编译器的一种解析执行规则。事件循环不属于 js 代码本身的范畴，而是属于 js 编译器的范畴，在 js 中讨论事件循环是没有意义的。换句话说，js 代码可以理解为是一个人在公司中具体做的事情， 而 事件循环 相当于是公司的一种规章制度。 两者不是一个层面的概念。</p> <h2 id="_5-29-宏任务与微任务的概念与区别"><a href="#_5-29-宏任务与微任务的概念与区别" class="header-anchor">#</a> 5.29 宏任务与微任务的概念与区别</h2> <p>为了协调任务有条不紊地在主线程上执行，页面进程引入了 <strong>消息队列</strong> 和 <strong>事件循环机制</strong>，渲染进程内部也会维护多个消息队列，比如延迟执行队列和普通的消息队列。然后主线程采用一个 <code>for</code> 循环，不断地从这些任务队列中取出任务并执行任务。这些消息队列中的任务就称为 <strong>宏任务</strong>。</p> <p><strong>微任务</strong>是一个需要异步执行的回调函数，执行时机是在主函数执行结束之后、当前宏任务结束之前。当 JS 执行一段脚本（一个宏任务）的时候，V8 会为其创建一个全局执行上下文，在创建全局执行上下文的同时，V8 引擎也会在内部创建一个 <strong>微任务队列</strong>。也就是说 <strong>每个宏任务都关联了一个微任务队列</strong>。</p> <h2 id="_5-30-常见的宏任务与微任务分别有哪些"><a href="#_5-30-常见的宏任务与微任务分别有哪些" class="header-anchor">#</a> 5.30 常见的宏任务与微任务分别有哪些</h2> <table><thead><tr><th>任务（代码）</th> <th>宏/微 任务</th> <th>环境</th></tr></thead> <tbody><tr><td></td> <td>宏任务</td> <td>浏览器</td></tr> <tr><td>事件</td> <td>宏任务</td> <td>浏览器</td></tr> <tr><td>网络请求（Ajax）</td> <td>宏任务</td> <td>浏览器</td></tr> <tr><td>setTimeout() 定时器</td> <td>宏任务</td> <td>浏览器/Node</td></tr> <tr><td>fs.readFile() 读取文件</td> <td>宏任务</td> <td>Node</td></tr> <tr><td>Promise.then()</td> <td>微任务</td> <td>浏览器/Node</td></tr> <tr><td>async/await</td> <td>微任务</td> <td>浏览器/Node</td></tr></tbody></table> <h2 id="_5-31-事件循环-event-loop-执行机制"><a href="#_5-31-事件循环-event-loop-执行机制" class="header-anchor">#</a> 5.31 事件循环 Event Loop 执行机制</h2> <p>1.进入到 script 标签,就进入到了第一次事件循环.</p> <p>2.遇到同步代码，立即执行</p> <p>3.遇到宏任务,放入到宏任务队列里.</p> <p>4.遇到微任务,放入到微任务队列里.</p> <p>5.执行完所有同步代码</p> <p>6.执行微任务代码</p> <p>7.微任务代码执行完毕，本次队列清空</p> <p>8.寻找下一个宏任务，重复步骤 1</p> <h2 id="_5-32-为什么-js-是单线程"><a href="#_5-32-为什么-js-是单线程" class="header-anchor">#</a> 5.32 为什么 Js 是单线程？</h2> <p>Js 是单线程，但是浏览器是多线程。单线程是为了避免 UI 操作混乱，所有和 UI 操作相关的开发语言都应该是单线程。</p> <h2 id="_5-33-代码题易考点"><a href="#_5-33-代码题易考点" class="header-anchor">#</a> 5.33 代码题易考点</h2> <ol><li>promise 本身是一个同步的代码，只有它后面调用的 then()方法里面的回调才是微任务</li> <li>then 方法需要 Promise 里的 resolve 传值才会执行</li> <li>await 右边的表达式还是会立即执行,表达式之后的代码才是微任务, await 微任务可以转换成等价的 promise 微任务分析</li> <li>script 标签本身是一个<code>宏任务</code>， 当页面出现多个 script 标签的时候，浏览器会把 script 标签作为宏任务来解析</li></ol> <h2 id="六、-es6-es2022-新语法"><a href="#六、-es6-es2022-新语法" class="header-anchor">#</a> 六、 ES6-ES2022 新语法</h2> <h2 id="_6-1-es6-es2015"><a href="#_6-1-es6-es2015" class="header-anchor">#</a> 6.1 ES6(ES2015)</h2> <h3 id="_1-说说-let-和-const"><a href="#_1-说说-let-和-const" class="header-anchor">#</a> 1. 说说 let 和 const</h3> <p><strong>let:</strong></p> <ul><li>声明变量</li> <li>没有变量提升</li> <li>不可重复声明</li> <li>具有块级作用域</li> <li>声明变量后可以在使用时赋值</li></ul> <p><strong>const:</strong></p> <ul><li>只读常量</li> <li>没有变量提升</li> <li>不可重复声明</li> <li>具有块级作用域</li> <li>声明变量后必须立马赋值</li></ul> <h3 id="_2-let、const、var-的区别"><a href="#_2-let、const、var-的区别" class="header-anchor">#</a> 2. let、const、var 的区别</h3> <p><strong>（1）块级作用域：</strong> 块作用域由 <code>{ }</code>包括，let 和 const 具有块级作用域，var 不存在块级作用域。块级作用域解决了 ES5 中的两个问题：</p> <ul><li>内层变量可能覆盖外层变量</li> <li>用来计数的循环变量泄露为全局变量</li></ul> <p><strong>（2）变量提升：</strong> var 存在变量提升，let 和 const 不存在变量提升，即在变量只能在声明之后使用，否在会报错。</p> <p><strong>（3）给全局添加属性：</strong> 浏览器的全局对象是 window，Node 的全局对象是 global。var 声明的变量为全局变量，并且会将该变量添加为全局对象的属性，但是 let 和 const 不会。</p> <p><strong>（4）重复声明：</strong> var 声明变量时，可以重复声明变量，后声明的同名变量会覆盖之前声明的遍历。const 和 let 不允许重复声明变量。</p> <p><strong>（5）暂时性死区：</strong> 在使用 let、const 命令声明变量之前，该变量都是不可用的。这在语法上，称为<strong>暂时性死区</strong>。使用 var 声明的变量不存在暂时性死区。</p> <p><strong>（6）初始值设置：</strong> 在变量声明时，var 和 let 可以不用设置初始值。而 const 声明变量必须设置初始值。</p> <p><strong>（7）指针指向：</strong> let 和 const 都是 ES6 新增的用于创建变量的语法。 let 创建的变量是可以更改指针指向（可以重新赋值）。但 const 声明的变量是不允许改变指针的指向。</p> <table><thead><tr><th><strong>区别</strong></th> <th><strong>var</strong></th> <th><strong>let</strong></th> <th><strong>const</strong></th></tr></thead> <tbody><tr><td>是否有块级作用域</td> <td>×</td> <td>✔️</td> <td>✔️</td></tr> <tr><td>是否存在变量提升</td> <td>✔️</td> <td>×</td> <td>×</td></tr> <tr><td>是否添加全局属性</td> <td>✔️</td> <td>×</td> <td>×</td></tr> <tr><td>能否重复声明变量</td> <td>✔️</td> <td>×</td> <td>×</td></tr> <tr><td>是否存在暂时性死区</td> <td>×</td> <td>✔️</td> <td>✔️</td></tr> <tr><td>是否必须设置初始值</td> <td>×</td> <td>×</td> <td>✔️</td></tr> <tr><td>能否改变指针指向</td> <td>✔️</td> <td>✔️</td> <td>×</td></tr></tbody></table> <h3 id="_3-解构赋值"><a href="#_3-解构赋值" class="header-anchor">#</a> 3. 解构赋值</h3> <p><strong>对象解构</strong></p> <ul><li>形式：<code>const { x, y } = { x: 1, y: 2 }</code></li> <li>默认：<code>const { x, y = 2 } = { x: 1 }</code></li> <li>改名：<code>const { x, y: z } = { x: 1, y: 2 }</code></li></ul> <p><strong>数组解构</strong></p> <ul><li>规则：数据结构具有<code>Iterator接口</code>可采用数组形式的解构赋值</li> <li>形式：<code>const [x, y] = [1, 2]</code></li> <li>默认：<code>const [x, y = 2] = [1]</code></li></ul> <p><strong>函数参数解构</strong></p> <ul><li>数组解构：<code>function Func([x = 0, y = 1]) {}</code></li> <li>对象解构：<code>function Func({ x = 0, y = 1 } = {}) {}</code></li></ul> <p><strong>应用场景:</strong></p> <ul><li>交换变量值：<code>[x, y] = [y, x]</code></li> <li>返回函数多个值：<code>const [x, y, z] = Func()</code></li> <li>定义函数参数：<code>Func([1, 2])</code></li> <li>提取 JSON 数据：<code>const { name, version } = packageJson</code></li> <li>定义函数参数默认值：<code>function Func({ x = 1, y = 2 } = {}) {}</code></li> <li>遍历 Map 结构：<code>for (let [k, v] of Map) {}</code></li> <li>输入模块指定属性和方法：<code>const { readFile, writeFile } = require(&quot;fs&quot;)</code></li></ul> <p><strong>注意点</strong></p> <ul><li>匹配模式：只要等号两边的模式相同，左边的变量就会被赋予对应的值</li> <li>解构赋值规则：只要等号右边的值不是对象或数组，就先将其转为对象</li> <li>解构默认值生效条件：属性值严格等于<code>undefined</code></li> <li>解构遵循匹配模式</li> <li>解构不成功时变量的值等于<code>undefined</code></li> <li><code>undefined</code>和<code>null</code>无法转为对象，因此无法进行解构</li></ul> <h3 id="_4-字符串的新增方法"><a href="#_4-字符串的新增方法" class="header-anchor">#</a> 4. 字符串的新增方法</h3> <p><strong>includes</strong></p> <p>返回布尔值，表示是否找到了参数字符串。</p> <p><strong>startsWith</strong></p> <p>返回布尔值，表示参数字符串是否在原字符串的头部。</p> <p><strong>endsWith</strong></p> <p>返回布尔值，表示参数字符串是否在原字符串的尾部。</p> <p><strong>repeat</strong></p> <p><code>repeat</code>方法返回一个新字符串，表示将原字符串重复<code>n</code>次</p> <h3 id="_5-展开运算符"><a href="#_5-展开运算符" class="header-anchor">#</a> 5. 展开运算符</h3> <p><strong>（2）数组扩展运算符</strong></p> <p>数组的扩展运算符可以将一个数组转为用逗号分隔的参数序列，且每次只能展开一层数组。</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> newArr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span>arr<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 复制数组</span>
<span class="token keyword">const</span> arr1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'two'</span><span class="token punctuation">,</span> <span class="token string">'three'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> arr2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'one'</span><span class="token punctuation">,</span> <span class="token operator">...</span>arr1<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 合并数组</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token operator">...</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将数组中的每一项作为参数使用</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>** (3) rest(剩余)参数**</p> <p>扩展运算符被用在函数形参上时，<strong>它还可以把一个分离的参数序列整合成一个数组</strong>：</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">mutiple</span><span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> val <span class="token keyword">of</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    result <span class="token operator">*=</span> val<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">mutiple</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 24</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h3 id="_6-数组新增的方法"><a href="#_6-数组新增的方法" class="header-anchor">#</a> 6. 数组新增的方法</h3> <p><strong>Array.from()</strong></p> <p>将类数组或者可迭代对象创建为一个新的数组，不改变原数组并返回这个新数组</p> <p><strong>Array.of()</strong></p> <p><strong>创建一个具有可变数量参数的新数组实例</strong>，示例代码如下：</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code>Array<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [1]</span>
Array<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'刘逍'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [true, 1, '刘逍']</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p><strong>findIndex</strong></p> <p>根据给定的回调函数，找到匹配的第一个元素的索引，找不到返回-1</p> <p><strong>find</strong></p> <p>根据给定的回调函数，找到匹配的第一个元素，找不到返回 undefined</p> <p><strong>fill</strong></p> <p>将给定值填充数组，示例代码如下：</p> <div class="language-arduino line-numbers-mode"><pre class="language-arduino"><code>const arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span>
<span class="token comment">// 将给定值填充索引1-3</span>
arr<span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span><span class="token char">'逍'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token comment">// [ 1, '逍', '逍', 4 ]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><strong>keys</strong></p> <p>返回一个可迭代的对象，其内容为数组的 key，示例代码如下：</p> <div class="language-arduino line-numbers-mode"><pre class="language-arduino"><code>const arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token char">'逍'</span><span class="token punctuation">]</span>
const keys <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span>const i of keys<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token comment">// 遍历结果 0 1 2</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p><strong>values</strong></p> <p>返回一个可迭代的对象，其内容为数组的 valu*，示例代码如下：</p> <div class="language-arduino line-numbers-mode"><pre class="language-arduino"><code>const arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token char">'逍'</span><span class="token punctuation">]</span>
const values <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span>const i of values<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token comment">// 遍历结果 1 true 逍</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p><strong>entries</strong></p> <p>返回一个可迭代的对象，其内容是一个数组，索引 0 为原数组的元素，1 为原数组该位置的值，示例代码如下：</p> <div class="language-ini line-numbers-mode"><pre class="language-ini"><code><span class="token key attr-name">const arr</span> <span class="token punctuation">=</span> <span class="token value attr-value">[1, true, '逍']</span>
​
<span class="token key attr-name">const iterator</span> <span class="token punctuation">=</span> <span class="token value attr-value">arr.entries()</span>
console.log(Array.from(iterator)) // [ [ 0, 1 ], [ 1, true ], [ 2, '逍' ] ]
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h3 id="_7-对象新增方法"><a href="#_7-对象新增方法" class="header-anchor">#</a> 7. 对象新增方法</h3> <p><strong>Object.is() (用于解决 NaN ≠= NaN，+0 === -0 的问题)</strong></p> <p>用于比较两个值是否相等，用于解决 NaN ≠= NaN，+0 === -0 的问题，示例代码如下：</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">NaN</span> <span class="token operator">===</span> <span class="token number">NaN</span><span class="token punctuation">)</span> <span class="token comment">// false</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token operator">+</span><span class="token number">0</span> <span class="token operator">===</span> <span class="token operator">-</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// true</span>
​
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token function">is</span><span class="token punctuation">(</span><span class="token number">NaN</span><span class="token punctuation">,</span> <span class="token number">NaN</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token function">is</span><span class="token punctuation">(</span><span class="token operator">+</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// false</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p><strong>Object.assign()</strong></p> <p>将<strong>所有可枚举属性的值从一个或多个源对象复制到目标对象，并返回目标对象</strong>，示例代码如下：</p> <div class="language-css line-numbers-mode"><pre class="language-css"><code><span class="token selector">const person = Object.assign(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token selector">,</span> <span class="token punctuation">{</span> <span class="token property">name</span><span class="token punctuation">:</span> <span class="token string">'刘逍'</span> <span class="token punctuation">}</span><span class="token selector">,</span> <span class="token punctuation">{</span> <span class="token property">age</span><span class="token punctuation">:</span> 18 <span class="token punctuation">}</span><span class="token selector">)
console.log(person) //</span> <span class="token punctuation">{</span> <span class="token property">name</span><span class="token punctuation">:</span> <span class="token string">'刘逍'</span><span class="token punctuation">,</span> <span class="token property">age</span><span class="token punctuation">:</span> 18 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p><strong>Object.getPrototypeOf()</strong></p> <p>获取原型对象；</p> <p><strong>Object.setPrototypeOf()</strong></p> <p>设置原型对象。</p> <h3 id="_8-class-类"><a href="#_8-class-类" class="header-anchor">#</a> 8.class 类</h3> <p>JS 里的类就是构造函数的语法糖</p> <p><strong>基本用法</strong></p> <ol><li>类里面有个 constructor 函数,可以接收传递过来的参数,同时返回实例对象</li> <li>constructor 函数只要 new 生成实例时,就会自动调用这个函数,如果我们不写这个函数,类也会自动生成这个函数</li> <li>公共属性放在 constructor 中，公共方法直接在类里面写函数声明,会自动添加至原型对象中</li> <li>class 类没有变量提升,所以必须先定义类,才能通过类实例化对象</li> <li>super()调用父类里的 constructor 方法,可以向里面传参,就等于 Father.call(this,x,y)，super 必须在子类的 this 前面调用</li> <li>class 里面的方法的 this 指向的是调用者,如果调用者不是类的实例,就需要改变 this 的指向</li></ol> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">age</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 属性</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>myName <span class="token operator">=</span> <span class="token string">'刘逍'</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token comment">// 静态方法</span>
  <span class="token keyword">static</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token comment">// 访问器</span>
  <span class="token keyword">get</span> <span class="token function">myName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'getter'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>myName<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">set</span> <span class="token function">myName</span><span class="token punctuation">(</span><span class="token parameter">v</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'setter'</span> <span class="token operator">+</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">setName</span><span class="token punctuation">(</span><span class="token parameter">v</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>myName <span class="token operator">=</span> v<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><p><strong>关键词</strong></p> <p><strong>constructor</strong></p> <p><code>constructor()</code>方法是类的默认方法，通过<code>new</code>命令生成对象实例时，自动调用该方法。一个类必须有<code>constructor()</code>方法，如果没有显式定义，一个空的<code>constructor()</code>方法会被默认添加。</p> <p><strong>super</strong></p> <p><code>super</code>这个关键字，既可以当作函数使用，也可以当作对象使用。</p> <p><code>super</code>作为函数调用时，代表父类的构造函数。子类的构造函数必须执行一次<code>super</code>函数。<code>super</code>虽然代表了父类<code>A</code>的构造函数，<strong>但是返回的是子类<code>B</code>的实例</strong></p> <p><code>super</code>作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。</p> <p><strong>getter、setter</strong></p> <p>在“类”的内部可以使用<code>get</code>和<code>set</code>关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。</p> <p><strong>static</strong></p> <p>如果在一个方法前，加上<code>static</code>关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。</p> <p><strong># 私有属性</strong></p> <p><code>ES2022</code>正式为<code>class</code>添加了私有属性，方法是在属性名之前使用<code>#</code>表示。私有属性只能在类的内部使用（<code>this.#count</code>）。如果在类的外部使用，就会报错。</p> <h3 id="_9-模块化"><a href="#_9-模块化" class="header-anchor">#</a> 9. 模块化</h3> <p>ES6<strong>中允许我们使用 export 导出模块，使用 import 引入模块</strong></p> <h3 id="_10-symbol"><a href="#_10-symbol" class="header-anchor">#</a> 10. Symbol</h3> <p>ES6 引入了一种新的原始数据类型<code>Symbol</code>，表示独一无二的值。它属于 JavaScript 语言的原生数据类型之一</p> <p>Symbol 值通过<code>Symbol()</code>函数生成。这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的 Symbol 类型。凡是属性名属于 Symbol 类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。</p> <h3 id="_11-iterator"><a href="#_11-iterator" class="header-anchor">#</a> 11. Iterator</h3> <p>Iterator 即迭代器，它是一种接口，为各种不同的数据结构提供了统一的访问机制，换句话说，只要有任何数据结构部署了迭代接口，就可以使用统一的方式的来遍历它。</p> <p>实现可迭代接口的数据结构，一般都自身实现或继承了以<code>Symbol.iterator</code>属性的，就属于可迭代对象。<code>Symbol.iterator</code>属性本身是一个函数，就是当前数据结构默认的遍历器生成函数。</p> <p>一个包含<code>next()</code>方法的对象，才可以称为一个迭代对象。<code>next()</code>对象的会有返回一个对象，对象中包含两个值，如下所示：</p> <ul><li><code>value</code>：迭代器返回的任何<code>JavaScript</code>值。<code>done</code>为<code>true</code>时可省略。</li> <li><code>done</code>：一个布尔值，为<code>false</code>时表示迭代未停止，为<code>true</code>时立即停止迭代器，且可以省略<code>value</code>的值。</li></ul> <p>Iterator 的作用有三个：</p> <ol start="0"><li>为各种数据结构，提供一个统一的、简便的访问接口；</li> <li>使得数据结构的成员能够按某种次序排列；</li> <li>ES6 创造了一种新的遍历命令<code>for...of</code>循环，Iterator 接口主要供<code>for...of</code>消费。</li></ol> <h3 id="_12-for-of-循环"><a href="#_12-for-of-循环" class="header-anchor">#</a> 12. for...of..循环</h3> <p><code>for...of</code>循环，作为遍历所有数据结构的统一的方法。</p> <p>一个数据结构只要部署了<code>Symbol.iterator</code>属性，就被视为具有 iterator 接口，就可以用<code>for...of</code>循环遍历它的成员。也就是说，<code>for...of</code>循环内部调用的是数据结构的<code>Symbol.iterator</code>方法。</p> <p><code>for...of</code>循环可以使用的范围包括数组、Set 和 Map 结构、某些类似数组的对象（比如<code>arguments</code>对象、DOM NodeList 对象）、后文的 Generator 对象，以及字符串。</p> <h3 id="_13-generator"><a href="#_13-generator" class="header-anchor">#</a> 13. Generator</h3> <p>Generator 是 ES2015 中提供的一种异步编程解决方案，定义 Generator 函数在<code>function</code>关键字和函数名中间使用<code>*</code>星号，函数内部使用<code>yield</code>关键字定义不同的状态。</p> <p>async 的底层就是 Generator 函数</p> <h3 id="_14-proxy-和-reffect"><a href="#_14-proxy-和-reffect" class="header-anchor">#</a> 14. Proxy 和 Reffect</h3> <p>Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。</p> <p>Proxy 对象用于创建一个代理对象，从而实现基本操作的拦截和自定义，基本操作包含 13 种，如下表所示：</p> <table><thead><tr><th>拦截 ⽅法</th> <th>触发⽅式</th></tr></thead> <tbody><tr><td><code>get(target, propKey, receiver)</code></td> <td>读取某个属性</td></tr> <tr><td><code>set(target, propKey, value, receiver)</code></td> <td>写⼊某个属性</td></tr> <tr><td><code>has(target, propKey)</code></td> <td><code>in</code>操作符</td></tr> <tr><td><code>deleteProperty(target, propKey)</code></td> <td><code>delete</code>操作符</td></tr> <tr><td><code>getPrototypeOf(target)</code></td> <td><code>Object.getPropertypeOf()</code></td></tr> <tr><td><code>setPrototypeOf(target, proto)</code></td> <td><code>Object.setPrototypeOf()</code></td></tr> <tr><td><code>isExtensible(target)</code></td> <td><code>Object.isExtensible()</code></td></tr> <tr><td><code>preventExtensions(target)</code></td> <td><code>Object.preventExtensions()</code></td></tr> <tr><td><code>getOwnPropertyDescriptor(target, propKey)</code></td> <td><code>Object.getOwnPropertyDescriptor()</code></td></tr> <tr><td><code>defineProperty(target, propKey, propDesc)</code></td> <td><code>Object.defineProperty()</code></td></tr> <tr><td><code>ownKeys(target)</code></td> <td><code>Object.keys()</code> 、<code>Object.getOwnPropertyNames()</code>、<code>Object.getOwnPropertySymbols()</code></td></tr> <tr><td><code>apply(target, thisArg, args)</code></td> <td>调⽤⼀个函数</td></tr> <tr><td><code>construct(target, args)</code></td> <td>⽤ new 调⽤⼀个函数</td></tr></tbody></table> <p>Vue3 就是基于<code>Proxy</code>进行编写的</p> <p><strong>Reflect</strong>是 ECMAScript2015 提供的一个对象，它提供了一些拦截 JavaScript 操作的静态方法，这些方法与 Proxy 中的<code>handlers</code>中的方法一致。</p> <p>Reflect 并不是一个构造函数，也就是说它不能够被实例化。</p> <p><code>Proxy</code>对象中的每一个拦截操作（例如：<code>get</code>、<code>delete</code>等）,内部都对应的调用了<code>Reflect</code>的方法。它提供的静态方法与 Proxy 中的<code>handlers</code>中的方法名称都一致</p> <h3 id="_15-set、map、weakset、weakmap"><a href="#_15-set、map、weakset、weakmap" class="header-anchor">#</a> 15. Set、Map、WeakSet、WeakMap</h3> <p><code>Set</code>、<code>Map</code>、<code>WeakSet</code>、<code>WeakMap</code>是 ES2015 中新增的几个对象：</p> <p><strong>set</strong>类似于数组，但是成员的值都是唯一的，没有重复的值。</p> <p><code>Set</code>本身是一个构造函数，用来生成 Set 数据结构。</p> <p><code>Set</code>和<code>WeakSet</code>与数组类似，准确的它他们是集合，这两者的区别就是<code>Set</code>可以存储任何数据类型，而<code>WeakSet</code>只能存储对象的引用，而且是弱引用；</p> <p><code>Set</code>对象在实际开发中最常见的就是实现数据去重，示例代码如下：</p> <div class="language-arduino line-numbers-mode"><pre class="language-arduino"><code>const arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span>
const set <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Set</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span>
<span class="token comment">// set对象可以使用 ... 展开 所有项</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>set<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">// [ 1, 2, 3, 4, 5 ]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p><strong>map</strong>类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。</p> <p><code>Map</code>和<code>WeakMap</code>与对象类似，存储方式是键值对形式的，这两者的区别<code>Map</code>的键值对都是可以是任意的而<code>WeakMap</code>键必须是对象的引用而值可以是任意类型的。</p> <h2 id="_6-2-es2016"><a href="#_6-2-es2016" class="header-anchor">#</a> 6.2 ES2016</h2> <h3 id="_1-指数运算符"><a href="#_1-指数运算符" class="header-anchor">#</a> 1. 指数运算符</h3> <p>ES2016 中新增指数<code>**</code>，也叫幂运算符，与 Math.pow()有着一样的功能，示例代码如下：</p> <div class="language-arduino line-numbers-mode"><pre class="language-arduino"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span><span class="token operator">*</span> <span class="token number">10</span> <span class="token operator">==</span><span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">pow</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// true</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h3 id="_2-array-prototype-includes-方法"><a href="#_2-array-prototype-includes-方法" class="header-anchor">#</a> 2. Array.prototype.includes()方法</h3> <p>在 ES2016 中在数组原型上增加了<code>includes()</code>方法，该方法用于判断一个数组中是否包含指定的值，返回一个布尔值，示例代码如下：</p> <div class="language-arduino line-numbers-mode"><pre class="language-arduino"><code>const arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> NaN<span class="token punctuation">]</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>NaN<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// -1</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span>NaN<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// true</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>值得注意的是使用<code>includes()</code>时<code>NaN</code>与<code>NaN</code>、<code>+0</code>与<code>-0</code>是相等的。</p> <h2 id="_6-3-es2017"><a href="#_6-3-es2017" class="header-anchor">#</a> 6.3 ES2017</h2> <h3 id="_1-对象新增方法"><a href="#_1-对象新增方法" class="header-anchor">#</a> 1. 对象新增方法</h3> <ul><li><code>Object.values()</code>：返回一个给定对象自身的所有可枚举属性值的数组；</li> <li><code>Object.entries()</code>：返回一个给定对象自身可枚举属性的键值对数组；</li> <li><code>Object.getOwnPropertyDescriptors()</code>：返回给定对象所有自有属性的属性描述符。</li></ul> <h3 id="_2-字符串新增方法"><a href="#_2-字符串新增方法" class="header-anchor">#</a> 2. 字符串新增方法</h3> <ul><li><code>padStart()</code>：在字符串开头填充空格；</li> <li><code>padEnd()</code>：在字符串结尾填充空格；</li></ul> <h2 id="_6-4-es2018"><a href="#_6-4-es2018" class="header-anchor">#</a> 6.4 ES2018</h2> <h3 id="_1-异步迭代"><a href="#_1-异步迭代" class="header-anchor">#</a> 1. 异步迭代</h3> <p>在 ES2018 中新增了<code>for await...of</code>语句，该用于可以遍历异步可迭代对象</p> <h3 id="_2-对象扩展运算符"><a href="#_2-对象扩展运算符" class="header-anchor">#</a> 2.<strong>对象扩展运算符</strong></h3> <p>对象的扩展运算符(...)用于取出参数对象中的所有可遍历属性，拷贝到当前对象之中。</p> <div class="language-ini line-numbers-mode"><pre class="language-ini"><code><span class="token key attr-name">let bar</span> <span class="token punctuation">=</span> <span class="token value attr-value">{ a: 1, b: 2 };</span>
<span class="token key attr-name">let baz</span> <span class="token punctuation">=</span> <span class="token value attr-value">{ ...bar }; // { a: 1, b: 2 }</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>上述方法实际上等价于:</p> <div class="language-ini line-numbers-mode"><pre class="language-ini"><code><span class="token key attr-name">let bar</span> <span class="token punctuation">=</span> <span class="token value attr-value">{ a: 1, b: 2 };</span>
<span class="token key attr-name">let baz</span> <span class="token punctuation">=</span> <span class="token value attr-value">Object.assign({}, bar); // { a: 1, b: 2 }</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><code>Object.assign</code>方法用于对象的合并，将源对象<code>（source）</code>的所有可枚举属性，复制到目标对象<code>（target）</code>。<code>Object.assign</code>方法的第一个参数是目标对象，后面的参数都是源对象。(<strong>如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性</strong>)</p> <h3 id="_3-promise-prototype-finally"><a href="#_3-promise-prototype-finally" class="header-anchor">#</a> 3. Promise.prototype.finally</h3> <p><code>finally()</code>方法会返回一个<code>Promise</code>对象，当 promise 的状态变更，不管是变成<code>rejected</code>或者<code>fulfilled</code>，最终都会执行<code>finally()</code>的回调。</p> <h2 id="_6-5-es2019"><a href="#_6-5-es2019" class="header-anchor">#</a> 6.5 ES2019</h2> <h3 id="_1-try-catch-语句中的catch允许不使用参数"><a href="#_1-try-catch-语句中的catch允许不使用参数" class="header-anchor">#</a> 1. <code>try...catch</code>：语句中的<code>catch</code>允许不使用参数</h3> <h3 id="_2-trimstart、trimleft、trimend、trimright"><a href="#_2-trimstart、trimleft、trimend、trimright" class="header-anchor">#</a> 2. trimStart、trimLeft、trimEnd、trimRight</h3> <ul><li><code>String.prototype.trimStart</code>：用于去除字符串左边的空格；</li> <li><code>String.prototype.trimLeft</code>：它是<code>trimStart</code>的别名</li> <li><code>String.prototype.trimEnd</code>：用于去除字符串右边的空格；</li> <li><code>String.prototype.trimRight</code>：它是<code>trimEnd</code>的别名</li></ul> <h3 id="_3-object-fromentries"><a href="#_3-object-fromentries" class="header-anchor">#</a> 3. Object.fromEntries</h3> <p><code>Object.fromEntries()</code>方法把键值对列表转换为一个对象，是<code>Object.entries()</code>方法的反操作</p> <h2 id="_6-6-es2020"><a href="#_6-6-es2020" class="header-anchor">#</a> 6.6 ES2020</h2> <h3 id="_1-动态导入"><a href="#_1-动态导入" class="header-anchor">#</a> 1. 动态导入</h3> <p>动态导入，也就是我们需要该模块的时候才会进行加载，这可以减少开销和页面加载时间，示例代码如下：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">import</span><span class="token punctuation">(</span>'<span class="token operator">/</span>modules<span class="token operator">/</span>my<span class="token operator">-</span><span class="token keyword">module</span><span class="token punctuation">.</span>js'<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">module</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">// Do something with the module.</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>动态导入使用<code>import()</code>方法，它返回一个 Promise。</p> <p>在 ES2020 中，还为<code>import</code>增加一个<code>meta</code>对象，该对象给 JavaScript 模块暴露了特定上下文的元数据属性的对象。</p> <h3 id="_2-bigint-数据类型"><a href="#_2-bigint-数据类型" class="header-anchor">#</a> 2. BigInt 数据类型</h3> <p>BigInt 的出现时解决 JavaScript 中允许的最大数字是<code>2**53-1</code>的问题，<code>BigInt</code> 可以表示任意大的整数。</p> <h3 id="_3-空值合并运算符"><a href="#_3-空值合并运算符" class="header-anchor">#</a> 3. 空值合并运算符 ??</h3> <p>该运算符与逻辑或运算符类似。其计算规则为，只要左运算元为<code>null</code>或者<code>undefined</code>，则返回右运算元，否则返回左运算元。而逻辑或运算符只有左运算元转换为<code>boolean</code>类型后为<code>false</code>，就返回右运算元。</p> <h3 id="_4-可选链操作符"><a href="#_4-可选链操作符" class="header-anchor">#</a> 4. 可选链操作符 ?.</h3> <p><code>?.</code> 操作符的功能类似于 <code>.</code> 链式操作符，不同之处在于，在引用为空 (<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Nullish" title="https://developer.mozilla.org/zh-CN/docs/Glossary/Nullish" target="_blank" rel="noopener noreferrer">nullish<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> ) (<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/null" title="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/null" target="_blank" rel="noopener noreferrer"><code>null</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 或者 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined" title="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined" target="_blank" rel="noopener noreferrer"><code>undefined</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>) 的情况下不会引起错误，该表达式短路返回值是 <code>undefined</code>。</p> <p>当我们访问某个属性时，只要有一处不存在，就会返回<code>undefind</code>，不会报错。</p> <div class="language-css line-numbers-mode"><pre class="language-css"><code><span class="token selector">var A =</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
​
// console.<span class="token function">log</span><span class="token punctuation">(</span>A.a.b<span class="token punctuation">)</span> // 报错
​
console.<span class="token function">log</span><span class="token punctuation">(</span>A.a?.b<span class="token punctuation">)</span> // undefined

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>可选链操作符也可用于对象下方法的调用，示例代码如下：</p> <div class="language-kotlin line-numbers-mode"><pre class="language-kotlin"><code><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
​
<span class="token comment">// 如果存在 obj.fun() 这个方法，下面则会直接调用，如果不存在则会返回undefined</span>
obj<span class="token punctuation">.</span>fun<span class="token operator">?</span><span class="token punctuation">.</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h2 id="_6-7-es2021"><a href="#_6-7-es2021" class="header-anchor">#</a> 6.7 ES2021</h2> <h3 id="_1-string-prototype-replaceall"><a href="#_1-string-prototype-replaceall" class="header-anchor">#</a> 1. String.prototype.replaceAll</h3> <p><code>replaceAll()</code>方法返回一个新字符串，新字符串的内容是经过替换的，实例代码如下：</p> <div class="language-arduino line-numbers-mode"><pre class="language-arduino"><code>const str <span class="token operator">=</span> <span class="token char">'刘逍'</span>
const newStr <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">replaceAll</span><span class="token punctuation">(</span><span class="token char">'逍'</span><span class="token punctuation">,</span> <span class="token char">'小'</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>newStr<span class="token punctuation">)</span> <span class="token comment">// 刘小</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="_2-数值分隔符"><a href="#_2-数值分隔符" class="header-anchor">#</a> 2. 数值分隔符 _</h3> <p>严格意义上讲数值分隔符(<code>_</code>)并不属于一个运算符，其作用就是使数字更加利于阅读，例如下面的代码</p> <div class="language-arduino line-numbers-mode"><pre class="language-arduino"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span>_0000_0000<span class="token punctuation">)</span> <span class="token comment">// 100000000</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h3 id="_3-promise-any"><a href="#_3-promise-any" class="header-anchor">#</a> 3. Promise.any()</h3> <p>ES2021 中新增的<code>Promise.any()</code>方法，它接受的参数和与<code>promise.all()</code>是一致的，唯一不同的是，<code>Promise.any()</code>方法接受的可迭代对象中没有一个 promise 成功（即所有的 promises 都失败/拒绝），就返回一个失败的 promise 和 AggregateError 类型的实例。</p> <h3 id="_4-逻辑赋值操作符-、-、"><a href="#_4-逻辑赋值操作符-、-、" class="header-anchor">#</a> 4. 逻辑赋值操作符 &amp;&amp;= 、||= 、？？=</h3> <div class="language-python line-numbers-mode"><pre class="language-python"><code>const <span class="token punctuation">[</span>f1<span class="token punctuation">,</span> f2<span class="token punctuation">,</span> f3<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span>true<span class="token punctuation">,</span> false<span class="token punctuation">]</span>
f1 <span class="token operator">&amp;</span><span class="token operator">&amp;</span><span class="token operator">=</span> <span class="token string">'逍'</span> <span class="token operator">//</span> 等同于 <span class="token builtin">str</span> <span class="token operator">=</span> <span class="token builtin">str</span> <span class="token operator">&amp;</span><span class="token operator">&amp;</span> <span class="token string">'逍'</span>
f2 <span class="token operator">|</span><span class="token operator">|</span><span class="token operator">=</span> <span class="token string">'逍'</span> <span class="token operator">//</span> 等同于 <span class="token builtin">str</span> <span class="token operator">=</span> <span class="token builtin">str</span> <span class="token operator">|</span><span class="token operator">|</span> <span class="token string">'逍'</span>
f3 ??<span class="token operator">=</span> <span class="token string">'逍'</span> <span class="token operator">//</span> 等同于 <span class="token builtin">str</span> <span class="token operator">=</span> <span class="token builtin">str</span> ?? <span class="token string">'逍'</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h2 id="_6-8-es2022"><a href="#_6-8-es2022" class="header-anchor">#</a> 6.8 ES2022</h2> <h3 id="_1-class-的扩展"><a href="#_1-class-的扩展" class="header-anchor">#</a> 1. class 的扩展</h3> <p>在 ES2022 中允许我们并不在<code>constructor</code>中定义类的成员，示例代码如下：</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">class</span> <span class="token class-name">C</span> <span class="token punctuation">{</span>
  myName <span class="token operator">=</span> <span class="token string">'刘逍'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">/* 两者是一致的 */</span>
<span class="token keyword">class</span> <span class="token class-name">C</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    myName <span class="token operator">=</span> <span class="token string">'刘逍'</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>ES2022 中允许我们使用<code>#</code>开头命名的变量作为类的私有成员</p> <h3 id="_2-await-在顶层使用"><a href="#_2-await-在顶层使用" class="header-anchor">#</a> 2. await 在顶层使用</h3> <p>在 ES2022 中新增了允许在顶层使用<code>await</code>，在顶层可以不适用<code>async</code>函数进行包裹，示例代码如下：</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> AsyncFun <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'module'</span><span class="token punctuation">;</span>
<span class="token keyword">await</span> <span class="token function">AsyncFun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="_3-object-hasown"><a href="#_3-object-hasown" class="header-anchor">#</a> 3. Object.hasOwn()</h3> <p><code>Object.hasOwn()</code>方法用于判断某个对象上是否具有某个属性，示例代码如下：</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> person <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'刘逍'</span><span class="token punctuation">,</span>
  <span class="token literal-property property">age</span><span class="token operator">:</span> <span class="token number">18</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token function">hasOwn</span><span class="token punctuation">(</span>person<span class="token punctuation">,</span> <span class="token string">'name'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token function">hasOwn</span><span class="token punctuation">(</span>person<span class="token punctuation">,</span> <span class="token string">'sex'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h3 id="_4-array-prototype-at"><a href="#_4-array-prototype-at" class="header-anchor">#</a> 4. Array.prototype.at()</h3> <p>ES2022 中新增的<code>at()</code>方法，它的作用是获取数组中的某个成员，它的参数是数组的索引，与直接使用索引的方式不同，它允许我们传递负值，等同于从后面倒数，示例代码如下：</p> <div class="language-arduino line-numbers-mode"><pre class="language-arduino"><code>const arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span><span class="token function">at</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 6</span>
<span class="token comment">// 等同于 arr[arr.length - 1]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h2 id="七、-dom"><a href="#七、-dom" class="header-anchor">#</a> 七、 DOM</h2> <h2 id="_7-1-说一下-dom-事件流"><a href="#_7-1-说一下-dom-事件流" class="header-anchor">#</a> 7.1 说一下 DOM 事件流</h2> <p>⼜称为事件传播，是⻚⾯中接收事件的顺序。DOM2 级事件规定的事件流包括了 3 个阶段：</p> <ul><li>事件捕获阶段（capture phase）</li> <li>处于⽬标阶段（target phase）</li> <li>事件冒泡阶段（bubbling phase）</li></ul> <p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/152eeaa11c2c4ca9a93de8a484295bcd~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image?" alt="Snipaste_2022-08-22_18-26-46.jpg"></p> <p>如上图所示，事件流的触发顺序是：</p> <ol><li>事件捕获阶段，为截获事件提供了机会</li> <li>实际的⽬标元素接收到事件</li> <li>事件冒泡阶段，可在这个阶段对事件做出响应</li></ol> <h2 id="_7-2-什么是事件冒泡-event-bubbling"><a href="#_7-2-什么是事件冒泡-event-bubbling" class="header-anchor">#</a> 7.2 什么是事件冒泡（Event Bubbling）</h2> <p>事件开始由最具体的元素（⽂档中嵌套层次最深的那个节点）接收到后，开始逐级向上传播到较为不具体的节点。</p> <div class="language-xml line-numbers-mode"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">&gt;</span></span>
  
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>Document<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span>
  
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span><span class="token punctuation">&gt;</span></span>按钮<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span>
  
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>如果点击了上面页面代码中的 <code>&lt;button&gt;</code> 按钮，那么该 <code>click</code> 点击事件会沿着 DOM 树向上逐级传播，在途经的每个节点上都会发生，具体顺序如下：</p> <ol><li>button 元素</li> <li>body 元素</li> <li>html 元素</li> <li>document 对象</li></ol> <h2 id="_7-3-什么是事件捕获-event-capturing"><a href="#_7-3-什么是事件捕获-event-capturing" class="header-anchor">#</a> 7.3 什么是事件捕获（Event Capturing）</h2> <p>事件开始由较为不具体的节点接收后，然后开始逐级向下传播到最具体的元素上。</p> <p>事件捕获的最大作用在于：事件在到达预定⽬标之前就可以捕获到它。</p> <p>如果仍以上面那段 HTML 代码为例，当点击按钮后，在事件捕获的过程中，document 对象会首先接收到这个 <code>click</code> 事件，然后再沿着 DOM 树依次向下，直到 <code>&lt;button&gt;</code>。具体顺序如下：</p> <ol><li>document 对象</li> <li>html 元素</li> <li>body 元素</li> <li>button 元素</li></ol> <h2 id="_7-4-什么是事件委托"><a href="#_7-4-什么是事件委托" class="header-anchor">#</a> 7.4 什么是事件委托</h2> <p>事件委托，就是利用了事件冒泡的机制，在较上层位置的元素上添加一个事件监听函数，来管理该元素及其所有子孙元素上的某一类的所有事件。</p> <p>适用场景：在绑定大量事件的时候，可以选择事件委托</p> <p><strong>优点</strong></p> <ul><li>事件委托可以减少事件注册数量，节省内存占⽤!</li> <li>当新增⼦元素时，⽆需再次做事件绑定，因此非常适合动态添加元素 (vue 解析模板时, 会对新创建的元素, 额外进行绑定的)</li></ul> <h2 id="_7-5-什么是-dom"><a href="#_7-5-什么是-dom" class="header-anchor">#</a> 7.5 什么是 DOM</h2> <p>DOM 就是文档对象模型 ，是用来呈现以及与任意 <code>HTML</code> 和或<code>XML</code> 文档交互的 API</p> <p>它提供了对文档的结构化的表述，并定义了一种方式可以使从程序中对该结构进行访问，从而改变文档的结构，样式和内容</p> <h2 id="_7-6-dom-的常用操作"><a href="#_7-6-dom-的常用操作" class="header-anchor">#</a> 7.6 DOM 的常用操作</h2> <h3 id="_1-创建节点"><a href="#_1-创建节点" class="header-anchor">#</a> (1)创建节点</h3> <p><strong>createElement</strong></p> <p>创建新元素，接受一个参数，即要创建元素的标签名</p> <div class="language-ini line-numbers-mode"><pre class="language-ini"><code><span class="token key attr-name">const divEl</span> <span class="token punctuation">=</span> <span class="token value attr-value">document.createElement(&quot;div&quot;);</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><strong>createTextNode</strong></p> <p>创建一个文本节点</p> <div class="language-ini line-numbers-mode"><pre class="language-ini"><code><span class="token key attr-name">const textEl</span> <span class="token punctuation">=</span> <span class="token value attr-value">document.createTextNode(&quot;content&quot;);</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><strong>createDocumentFragment</strong></p> <p>用来创建一个文档碎片，它表示一种轻量级的文档，主要是用来存储临时节点，然后把文档碎片的内容一次性添加到<code>DOM</code>中</p> <div class="language-ini line-numbers-mode"><pre class="language-ini"><code><span class="token key attr-name">const fragment</span> <span class="token punctuation">=</span> <span class="token value attr-value">document.createDocumentFragment();</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>当请求把一个<code>DocumentFragment</code> 节点插入文档树时，插入的不是 <code>DocumentFragment</code>自身，而是它的所有子孙节点</p> <p><strong>createAttribute</strong></p> <p>创建属性节点，可以是自定义属性</p> <div class="language-ini line-numbers-mode"><pre class="language-ini"><code><span class="token key attr-name">const dataAttribute</span> <span class="token punctuation">=</span> <span class="token value attr-value">document.createAttribute('custom');</span>
consle.log(dataAttribute);
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h3 id="_2-获取节点"><a href="#_2-获取节点" class="header-anchor">#</a> (2)获取节点</h3> <p><strong>querySelector</strong></p> <p>传入任何有效的<code>css</code> 选择器，即可选中单个 <code>DOM</code>元素（首个）：</p> <div class="language-dart line-numbers-mode"><pre class="language-dart"><code>document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">'.element'</span></span><span class="token punctuation">)</span>
document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">'#element'</span></span><span class="token punctuation">)</span>
document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">'div'</span></span><span class="token punctuation">)</span>
document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">'[name=&quot;username&quot;]'</span></span><span class="token punctuation">)</span>
document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">'div + p &gt; span'</span></span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>如果页面上没有指定的元素时，返回 <code>null</code></p> <p><strong>querySelectorAll</strong></p> <p>返回一个包含节点子树内所有与之相匹配的<code>Element</code>节点列表，如果没有相匹配的，则返回一个空节点列表</p> <div class="language-ini line-numbers-mode"><pre class="language-ini"><code><span class="token key attr-name">const notLive</span> <span class="token punctuation">=</span> <span class="token value attr-value">document.querySelectorAll(&quot;p&quot;);</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>需要注意的是，该方法返回的是一个 <code>NodeList</code>的静态实例，它是一个静态的“快照”，而非“实时”的查询</p> <p>关于获取<code>DOM</code>元素的方法还有如下，就不一一述说</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code>document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'id属性值'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
返回拥有指定id的对象的引用<span class="token punctuation">;</span>
document<span class="token punctuation">.</span><span class="token function">getElementsByClassName</span><span class="token punctuation">(</span><span class="token string">'class属性值'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
返回拥有指定<span class="token keyword">class</span>的对象集合<span class="token punctuation">;</span>
document<span class="token punctuation">.</span><span class="token function">getElementsByTagName</span><span class="token punctuation">(</span><span class="token string">'标签名'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
返回拥有指定标签名的对象集合<span class="token punctuation">;</span>
document<span class="token punctuation">.</span><span class="token function">getElementsByName</span><span class="token punctuation">(</span><span class="token string">'name属性值'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
返回拥有指定名称的对象结合<span class="token punctuation">;</span>
document <span class="token operator">/</span> element<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'CSS选择器'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
仅返回第一个匹配的元素<span class="token punctuation">;</span>
document <span class="token operator">/</span> element<span class="token punctuation">.</span><span class="token function">querySelectorAll</span><span class="token punctuation">(</span><span class="token string">'CSS选择器'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
返回所有匹配的元素<span class="token punctuation">;</span>
document<span class="token punctuation">.</span>documentElement<span class="token punctuation">;</span>
获取页面中的<span class="token constant">HTML</span>标签<span class="token punctuation">;</span>
document<span class="token punctuation">.</span>body<span class="token punctuation">;</span>
获取页面中的<span class="token constant">BODY</span>标签<span class="token punctuation">;</span>
document<span class="token punctuation">.</span>all<span class="token punctuation">[</span><span class="token string">''</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
获取页面中的所有元素节点的对象集合型<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><h3 id="_3-更新节点"><a href="#_3-更新节点" class="header-anchor">#</a> (3)更新节点</h3> <p><strong>innerHTML</strong></p> <p>不但可以修改一个<code>DOM</code>节点的文本内容，还可以直接通过<code>HTML</code>片段修改<code>DOM</code>节点内部的子树</p> <div class="language-css line-numbers-mode"><pre class="language-css"><code>// 获取&lt;p id=<span class="token string">&quot;p&quot;</span>&gt;...&lt;/p &gt;
var p = document.<span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'p'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
// <span class="token property">设置文本为abc</span><span class="token punctuation">:</span>
p.innerHTML = <span class="token string">'ABC'</span><span class="token punctuation">;</span> // &lt;p id=<span class="token string">&quot;p&quot;</span>&gt;ABC&lt;/p &gt;
// <span class="token property">设置HTML</span><span class="token punctuation">:</span>
p.innerHTML = <span class="token string">'ABC &lt;span style=&quot;color:red&quot;&gt;RED&lt;/span&gt; XYZ'</span><span class="token punctuation">;</span>
// &lt;p&gt;...&lt;/p &gt;的内部结构已修改
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p><strong>innerText、textContent</strong></p> <p>自动对字符串进行<code>HTML</code>编码，保证无法设置任何<code>HTML</code>标签</p> <div class="language-ini line-numbers-mode"><pre class="language-ini"><code><span class="token key attr-name">// 获取&lt;p id</span><span class="token punctuation">=</span><span class="token value attr-value">&quot;p-id&quot;&gt;...&lt;/p &gt;</span>
<span class="token key attr-name">var p</span> <span class="token punctuation">=</span> <span class="token value attr-value">document.getElementById('p-id');</span>
// 设置文本:
<span class="token key attr-name">p.innerText</span> <span class="token punctuation">=</span> <span class="token value attr-value">'&lt;script&gt;alert(&quot;Hi&quot;)&lt;/script&gt;';</span>
// HTML被自动编码，无法设置一个&lt;script&gt;节点:
<span class="token key attr-name">// &lt;p id</span><span class="token punctuation">=</span><span class="token value attr-value">&quot;p-id&quot;&gt;&amp;lt;script&amp;gt;alert(&quot;Hi&quot;)&amp;lt;/script&amp;gt;&lt;/p &gt;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>两者的区别在于读取属性时，<code>innerText</code>不返回隐藏元素的文本，而<code>textContent</code>返回所有文本</p> <p><strong>style</strong></p> <p><code>DOM</code>节点的<code>style</code>属性对应所有的<code>CSS</code>，可以直接获取或设置。遇到<code>-</code>需要转化为驼峰命名</p> <div class="language-ini line-numbers-mode"><pre class="language-ini"><code><span class="token key attr-name">// 获取&lt;p id</span><span class="token punctuation">=</span><span class="token value attr-value">&quot;p-id&quot;&gt;...&lt;/p &gt;</span>
<span class="token key attr-name">const p</span> <span class="token punctuation">=</span> <span class="token value attr-value">document.getElementById('p-id');</span>
// 设置CSS:
<span class="token key attr-name">p.style.color</span> <span class="token punctuation">=</span> <span class="token value attr-value">'#ff0000';</span>
<span class="token key attr-name">p.style.fontSize</span> <span class="token punctuation">=</span> <span class="token value attr-value">'20px'; // 驼峰命名</span>
<span class="token key attr-name">p.style.paddingTop</span> <span class="token punctuation">=</span> <span class="token value attr-value">'2em';</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h3 id="_4-添加节点"><a href="#_4-添加节点" class="header-anchor">#</a> (4)添加节点</h3> <p><strong>innerHTML</strong></p> <p>如果这个 DOM 节点是空的，例如，<code>&lt;div&gt;&lt;/div&gt;</code>，那么，直接使用<code>innerHTML = '&lt;span&gt;child&lt;/span&gt;'</code>就可以修改<code>DOM</code>节点的内容，相当于添加了新的<code>DOM</code>节点</p> <p>如果这个 DOM 节点不是空的，那就不能这么做，因为<code>innerHTML</code>会直接替换掉原来的所有子节点</p> <p><strong>appendChild</strong></p> <p>把一个子节点添加到父节点的最后一个子节点</p> <p>如果是获取<code>DOM</code>元素后再进行添加操作，这个<code>js</code>节点是已经存在当前文档树中，因此这个节点首先会从原先的位置删除，再插入到新的位置</p> <p>如果动态添加新的节点，则先创建一个新的节点，然后插入到指定的位置</p> <p><strong>insertBefore</strong></p> <p>把子节点插入到指定的位置，使用方法如下：</p> <div class="language-scss line-numbers-mode"><pre class="language-scss"><code>parentElement.<span class="token function">insertBefore</span><span class="token punctuation">(</span>newElement<span class="token punctuation">,</span> referenceElement<span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>子节点会插入到<code>referenceElement</code>之前</p> <p><strong>setAttribute</strong></p> <p>添加一个属性节点，如果元素中已有该属性改变属性值</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> div <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'id'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
div<span class="token punctuation">.</span><span class="token function">setAttribute</span><span class="token punctuation">(</span><span class="token string">'class'</span><span class="token punctuation">,</span> <span class="token string">'white'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//第一个参数属性名，第二个参数属性值。</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h3 id="_5-删除节点"><a href="#_5-删除节点" class="header-anchor">#</a> (5)删除节点</h3> <p><strong>removeChild</strong></p> <p>删除一个节点，首先要获得该节点本身以及它的父节点，然后，调用父节点的<code>removeChild</code>把自己删掉</p> <div class="language-ini line-numbers-mode"><pre class="language-ini"><code>// 拿到待删除节点:
<span class="token key attr-name">const self</span> <span class="token punctuation">=</span> <span class="token value attr-value">document.getElementById('to-be-removed');</span>
// 拿到父节点:
<span class="token key attr-name">const parent</span> <span class="token punctuation">=</span> <span class="token value attr-value">self.parentElement;</span>
// 删除:
<span class="token key attr-name">const removed</span> <span class="token punctuation">=</span> <span class="token value attr-value">parent.removeChild(self);</span>
<span class="token key attr-name">removed</span> <span class="token punctuation">=</span><span class="token value attr-value">== self; // true</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>删除后的节点虽然不在文档树中了，但其实它还在内存中，可以随时再次被添加到别的位置</p> <h2 id="_7-7-什么是-dom-树"><a href="#_7-7-什么是-dom-树" class="header-anchor">#</a> 7.7 什么是 DOM 树</h2> <p>以 HTMLDocument 为根节点，其余节点为子节点，组织成一个树的数据结构的表示就是 DOM 树。</p> <p>DOM 树直接体现了标签与标签之间的关系</p> <h2 id="_7-8-什么是-dom-对象-什么是-document-对象"><a href="#_7-8-什么是-dom-对象-什么是-document-对象" class="header-anchor">#</a> 7.8 什么是 DOM 对象，什么是 document 对象</h2> <p>DOM 对象是浏览器根据 html 标签生成的 Js 对象</p> <p>docement 对象是 DOM 里提供的一个对象，它提供的属性和方法都是用来访问和操作网页内容的</p> <h2 id="_7-9-l0-和-l2-注册事件的区别"><a href="#_7-9-l0-和-l2-注册事件的区别" class="header-anchor">#</a> 7.9 L0 和 L2 注册事件的区别</h2> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4328d62ad5e54a66b4aed311f2c2d954~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image?" alt="Snipaste_2022-08-22_18-46-17.jpg"></p> <h2 id="_7-10-怎么解绑事件"><a href="#_7-10-怎么解绑事件" class="header-anchor">#</a> 7.10 怎么解绑事件</h2> <p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d9c245425aef478b907f84c84f331c70~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image?" alt="Snipaste_2022-08-22_18-47-08.jpg"></p> <h2 id="_7-11-addeventlistener-的第三个参数有什么用"><a href="#_7-11-addeventlistener-的第三个参数有什么用" class="header-anchor">#</a> 7.11 addEventListener 的第三个参数有什么用</h2> <p>addEventListener 有三个参数：</p> <div class="language-vbnet line-numbers-mode"><pre class="language-vbnet"><code> element.addEventListener<span class="token punctuation">(</span><span class="token keyword">event</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">,</span> useCapture<span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><table><thead><tr><th>参数</th> <th>描述</th></tr></thead> <tbody><tr><td>event</td> <td>必须。字符串，指定事件名。 <strong>注意:</strong> 不要使用 &quot;on&quot; 前缀。 例如，使用 &quot;click&quot; ,而不是使用 &quot;onclick&quot;。 <strong>提示：</strong> 所有 HTML DOM 事件，可以查看我们完整的 <a href="http://www.runoob.com/jsref/dom-obj-event.html" title="https://link.juejin.cn?target=http%3A%2F%2Fwww.runoob.com%2Fjsref%2Fdom-obj-event.html" target="_blank" rel="noopener noreferrer">HTML DOM Event 对象参考手册<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。</td></tr> <tr><td>function</td> <td>必须。指定要事件触发时执行的函数。 当事件对象会作为第一个参数传入函数。 事件对象的类型取决于特定的事件。例如， &quot;click&quot; 事件属于 MouseEvent(鼠标事件) 对象。</td></tr> <tr><td>useCapture</td> <td>可选。布尔值，指定事件是否在捕获或冒泡阶段执行。 可能值:true - 事件句柄在捕获阶段执行（即在事件捕获阶段调用处理函数）false- false- 默认。事件句柄在冒泡阶段执行（即表示在事件冒泡的阶段调用事件处理函数）</td></tr></tbody></table> <h2 id="_7-12-常用-dom-事件"><a href="#_7-12-常用-dom-事件" class="header-anchor">#</a> 7.12 常用 DOM 事件</h2> <ul><li><p>鼠标事件</p> <ul><li><p>鼠标单击 click</p></li> <li><p>鼠标双击 dblclick</p></li> <li><p>鼠标移入/移出</p> <ul><li>mouseover/mouseout : 支持冒泡</li> <li>mouseenter/mouseleave： 不支持冒泡</li></ul></li> <li><p>鼠标移动 mousemove</p></li> <li><p>鼠标按下 mousedown</p></li> <li><p>鼠标松开 mouseup</p></li></ul></li> <li><p>键盘事件</p> <ul><li>input : 键盘输入</li> <li>keydwon : 键盘按下</li> <li>focus: 成为焦点</li> <li>blur: 失去焦点</li></ul></li> <li><p>页面事件</p> <ul><li>scroll ： 页面滚动</li> <li>resize：页面大小变化</li></ul></li></ul> <h2 id="_7-13-怎么阻止事件冒泡、阻止默认事件"><a href="#_7-13-怎么阻止事件冒泡、阻止默认事件" class="header-anchor">#</a> 7.13 怎么阻止事件冒泡、阻止默认事件？</h2> <p><strong>阻止事件冒泡</strong></p> <p>e.stopPropagation**()</p> <p><strong>阻止默认事件,3 种方式</strong></p> <div class="language-csharp line-numbers-mode"><pre class="language-csharp"><code>e<span class="token punctuation">.</span><span class="token function">preventDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//谷歌及IE8以上</span>
window<span class="token punctuation">.</span><span class="token keyword">event</span><span class="token punctuation">.</span>returnValue <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">//IE8及以下</span>
<span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">//无兼容问题（但不能用于节点直接onclick绑定函数）</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h2 id="_7-14-dom-的类型有哪几种"><a href="#_7-14-dom-的类型有哪几种" class="header-anchor">#</a> 7.14 DOM 的类型有哪几种？</h2> <p>12 种</p> <div class="language-scss line-numbers-mode"><pre class="language-scss"><code>元素节点            　　Node.ELEMENT_<span class="token function">NODE</span><span class="token punctuation">(</span>1<span class="token punctuation">)</span>
属性节点            　　Node.ATTRIBUTE_<span class="token function">NODE</span><span class="token punctuation">(</span>2<span class="token punctuation">)</span>
文本节点            　　Node.TEXT_<span class="token function">NODE</span><span class="token punctuation">(</span>3<span class="token punctuation">)</span>
CDATA节点             Node.CDATA_SECTION_<span class="token function">NODE</span><span class="token punctuation">(</span>4<span class="token punctuation">)</span>
实体引用名称节点    　　 Node.ENTRY_REFERENCE_<span class="token function">NODE</span><span class="token punctuation">(</span>5<span class="token punctuation">)</span>
实体名称节点        　　Node.ENTITY_<span class="token function">NODE</span><span class="token punctuation">(</span>6<span class="token punctuation">)</span>
处理指令节点        　　Node.PROCESSING_INSTRUCTION_<span class="token function">NODE</span><span class="token punctuation">(</span>7<span class="token punctuation">)</span>
注释节点            　 Node.COMMENT_<span class="token function">NODE</span><span class="token punctuation">(</span>8<span class="token punctuation">)</span>
文档节点            　 Node.DOCUMENT_<span class="token function">NODE</span><span class="token punctuation">(</span>9<span class="token punctuation">)</span>
文档类型节点        　　Node.DOCUMENT_TYPE_<span class="token function">NODE</span><span class="token punctuation">(</span>10<span class="token punctuation">)</span>
文档片段节点        　　Node.DOCUMENT_FRAGMENT_<span class="token function">NODE</span><span class="token punctuation">(</span>11<span class="token punctuation">)</span>
DTD声明节点            Node.NOTATION_<span class="token function">NODE</span><span class="token punctuation">(</span>12<span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><h2 id="_7-15-dom-种获取坐标的属性有哪些-它们有什么不同"><a href="#_7-15-dom-种获取坐标的属性有哪些-它们有什么不同" class="header-anchor">#</a> 7.15 DOM 种获取坐标的属性有哪些，它们有什么不同？</h2> <table><thead><tr><th>属性</th> <th>说明</th> <th>兼容性</th></tr></thead> <tbody><tr><td>offsetX</td> <td>以当前的目标元素左上角为原点，定位 x 轴坐标</td> <td>除 Mozilla 外都兼容</td></tr> <tr><td>offsetY</td> <td>以当前的目标元素左上角为原点，定位 y 轴坐标</td> <td>除 Mozilla 外都兼容</td></tr> <tr><td>clientX</td> <td>以浏览器可视窗口左上角为原点，定位 x 轴坐标</td> <td>都兼容</td></tr> <tr><td>clientY</td> <td>以浏览器可视窗口左上角为原点，定位 y 轴坐标</td> <td>都兼容</td></tr> <tr><td>pageX</td> <td>以 doument 对象左上角为原点，定位 x 轴坐标</td> <td>除 IE 外都兼容</td></tr> <tr><td>pageY</td> <td>以 doument 对象左上角为原点，定位 y 轴坐标</td> <td>除 IE 外都兼容</td></tr> <tr><td>screenX</td> <td>以计算机屏幕左上顶角为原点，定位 x 轴坐标(多屏幕会影响)</td> <td>全兼容</td></tr> <tr><td>screenY</td> <td>以计算机屏幕左上顶角为原点，定位 y 轴坐标</td> <td>全兼容</td></tr> <tr><td>layerX</td> <td>最近的绝对定位的父元素（如果没有，则为 document 对象）左上顶角为元素，定位 x 轴坐标</td> <td>Mozilla 和 Safari</td></tr> <tr><td>layerY</td> <td>最近的绝对定位的父元素（如果没有，则为 document 对象）左上顶角为元素，定位 y 轴坐标</td> <td>Mozilla 和 Safari</td></tr></tbody></table> <h2 id="_7-16-dom-种元素视图尺寸的属性有哪些"><a href="#_7-16-dom-种元素视图尺寸的属性有哪些" class="header-anchor">#</a> 7.16 DOM 种元素视图尺寸的属性有哪些？</h2> <table><thead><tr><th>属性</th> <th>说明</th></tr></thead> <tbody><tr><td>offsetLeft</td> <td>获取当前元素到定位父节点的 left 方向的距离</td></tr> <tr><td>offsetTop</td> <td>获取当前元素到定位父节点的 top 方向的距离</td></tr> <tr><td>offsetWidth</td> <td>获取当前元素 width + 左右 padding + 左右 border-width</td></tr> <tr><td>offsetHeight</td> <td>获取当前元素 height + 上下 padding + 上下 border-width</td></tr> <tr><td>clientWidth</td> <td>获取当前元素 width + 左右 padding</td></tr> <tr><td>clientHeight</td> <td>获取当前元素 height + 上下 padding</td></tr> <tr><td>scrollWidth</td> <td>当前元素内容真实的宽度，内容不超出盒子宽度时为盒子的 clientWidth</td></tr> <tr><td>scrollHeight</td> <td>当前元素内容真实的高度，内容不超出盒子高度时为盒子的 clientHeight</td></tr></tbody></table> <h2 id="_7-17-如何判断元素是否在可视区域"><a href="#_7-17-如何判断元素是否在可视区域" class="header-anchor">#</a> 7.17 如何判断元素是否在可视区域</h2> <h3 id="getboundingclientrect"><a href="#getboundingclientrect" class="header-anchor">#</a> getBoundingClientRect</h3> <p><code>Element.getBoundingClientRect()</code> 方法返回元素的大小及其相对于视口的位置。返回的是一个对象，对象里有这 8 个属性：<code>left，right，top，bottom，width，height，x，y</code></p> <h2 id="_7-18-intersectionobserver"><a href="#_7-18-intersectionobserver" class="header-anchor">#</a> 7.18 IntersectionObserver</h2> <p><code>IntersectionObserver</code><strong>接口</strong> 提供了一种异步观察目标元素与其祖先元素或顶级文档视窗(<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Viewport" title="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FGlossary%2FViewport" target="_blank" rel="noopener noreferrer">viewport<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>)交叉状态的方法。祖先元素与视窗(<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Viewport" title="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FGlossary%2FViewport" target="_blank" rel="noopener noreferrer">viewport<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>)被称为<strong>根(root)</strong></p> <p>通俗点说就是：<code>IntersectionObserver</code>是用来监听<strong>某个元素与视口</strong>的<code>交叉状态</code>的。</p> <h2 id="_7-19-如何遍历输出页面中的所有元素"><a href="#_7-19-如何遍历输出页面中的所有元素" class="header-anchor">#</a> 7.19 如何遍历输出页面中的所有元素</h2> <h3 id="createnodeiterator"><a href="#createnodeiterator" class="header-anchor">#</a> createNodeIterator</h3> <p>使用<code>createNodeIterator</code>对页面中所有元素进行遍历输出呢？</p> <div class="language-ini line-numbers-mode"><pre class="language-ini"><code><span class="token key attr-name">const body</span> <span class="token punctuation">=</span> <span class="token value attr-value">document.getElementsByTagName('body')[0]</span>
 <span class="token key attr-name">   const it</span> <span class="token punctuation">=</span> <span class="token value attr-value">document.createNodeIterator(body)</span>
 <span class="token key attr-name">   let root</span> <span class="token punctuation">=</span> <span class="token value attr-value">it.nextNode()</span>
    while(root) {
        console.log(root)
 <span class="token key attr-name">       root</span> <span class="token punctuation">=</span> <span class="token value attr-value">it.nextNode()</span>
    }
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h2 id="_7-20-什么是-bom-对象"><a href="#_7-20-什么是-bom-对象" class="header-anchor">#</a> 7.20 什么是 BOM 对象</h2> <p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d02d3f7e82ce497eb64f8bb03a02a9cd~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image?" alt="Snipaste_2022-08-22_18-53-44.jpg"></p> <h3 id="_1-location-对象的常用方法"><a href="#_1-location-对象的常用方法" class="header-anchor">#</a> (1) location 对象的常用方法</h3> <p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/afee995fe98e42b983727698a8d4e1ff~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image?" alt="Snipaste_2022-08-22_18-54-33.jpg"></p> <h3 id="_2-navigator-对象-获取浏览器平台和版本数据"><a href="#_2-navigator-对象-获取浏览器平台和版本数据" class="header-anchor">#</a> (2) navigator 对象 (获取浏览器平台和版本数据)</h3> <p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0121daea446e484b87746930d3545777~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image?" alt="Snipaste_2022-08-22_18-55-25.jpg"></p> <h3 id="_3-histroy-对象-管理浏览器历史记录"><a href="#_3-histroy-对象-管理浏览器历史记录" class="header-anchor">#</a> (3) histroy 对象 （管理浏览器历史记录）</h3> <p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/886d847bf7984663b41d1acb8329c509~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image?" alt="Snipaste_2022-08-22_18-57-03.jpg"></p> <h2 id="八、其他类型问题补充"><a href="#八、其他类型问题补充" class="header-anchor">#</a> 八、其他类型问题补充</h2> <h2 id="_8-1-简单说说你对观察者模式的理解"><a href="#_8-1-简单说说你对观察者模式的理解" class="header-anchor">#</a> 8.1 简单说说你对观察者模式的理解</h2> <p>观察者模式定义了对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知，并自动更新</p> <p>观察者模式属于行为型模式，行为型模式关注的是对象之间的通讯，观察者模式就是观察者和被观察者之间的通讯</p> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/455aea9a384646bebf4521ebbbd07d34~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt=""></p> <p>例如生活中，我们可以用报纸期刊的订阅来形象的说明，当你订阅了一份报纸，每天都会有一份最新的报纸送到你手上，有多少人订阅报纸，报社就会发多少份报纸</p> <p>报社和订报纸的客户就形成了一对多的依赖关系</p> <h2 id="_8-2-简单说说你对发布订阅模式的理解"><a href="#_8-2-简单说说你对发布订阅模式的理解" class="header-anchor">#</a> 8.2 简单说说你对发布订阅模式的理解</h2> <p>发布-订阅是一种消息范式，消息的发送者（称为发布者）不会将消息直接发送给特定的接收者（称为订阅者）。而是将发布的消息分为不同的类别，无需了解哪些订阅者（如果有的话）可能存在</p> <p>同样的，订阅者可以表达对一个或多个类别的兴趣，只接收感兴趣的消息，无需了解哪些发布者存在</p> <h2 id="_8-3-观察者模式与发布订阅的区别"><a href="#_8-3-观察者模式与发布订阅的区别" class="header-anchor">#</a> 8.3 观察者模式与发布订阅的区别</h2> <ul><li>在观察者模式中，观察者是知道 Subject 的，Subject 一直保持对观察者进行记录。然而，在发布订阅模式中，发布者和订阅者不知道对方的存在。它们只有通过消息代理进行通信。</li> <li>在发布订阅模式中，组件是松散耦合的，正好和观察者模式相反。</li> <li>观察者模式大多数时候是同步的，比如当事件触发，Subject 就会去调用观察者的方法。而发布-订阅模式大多数时候是异步的（使用消息队列）</li></ul> <h2 id="_8-4-说说你对正则表达式的理解"><a href="#_8-4-说说你对正则表达式的理解" class="header-anchor">#</a> 8.4 说说你对正则表达式的理解</h2> <p>正则表达式是一种用来匹配字符串的强有力的武器</p> <p>它的设计思想是用一种描述性的语言定义一个规则，凡是符合规则的字符串，我们就认为它“匹配”了，否则，该字符串就是不合法的</p> <p>在 <code>JavaScript</code>中，正则表达式也是对象，构建正则表达式有两种方式：</p> <ol start="0"><li>字面量创建，其由包含在斜杠之间的模式组成</li></ol> <div class="language-ini line-numbers-mode"><pre class="language-ini"><code><span class="token key attr-name">const re</span> <span class="token punctuation">=</span> <span class="token value attr-value">/\d+/g;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ol start="0"><li>调用<code>RegExp</code>对象的构造函数</li></ol> <div class="language-ini line-numbers-mode"><pre class="language-ini"><code><span class="token key attr-name">const re</span> <span class="token punctuation">=</span> <span class="token value attr-value">new RegExp(&quot;\d+&quot;,&quot;g&quot;);</span>
​
<span class="token key attr-name">const rul</span> <span class="token punctuation">=</span> <span class="token value attr-value">&quot;<span class="token inner-value">\d+</span>&quot;</span>
<span class="token key attr-name">const re1</span> <span class="token punctuation">=</span> <span class="token value attr-value">new RegExp(rul,&quot;g&quot;);</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>使用构建函数创建，第一个参数可以是一个变量，遇到特殊字符``需要使用<code>\</code>进行转义</p> <h2 id="_8-5-如何判断当前的-js-代码是否在浏览器环境中运行"><a href="#_8-5-如何判断当前的-js-代码是否在浏览器环境中运行" class="header-anchor">#</a> 8.5 如何判断当前的 Js 代码是否在浏览器环境中运行</h2> <p>如果 Javascript 在浏览器环境中运行，则会有一个全局对象：<code>window</code>。因此，可以通过以下方式判断环境：</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code> <span class="token keyword">typeof</span> window<span class="token punctuation">.</span>self ！<span class="token operator">==</span> <span class="token string">&quot;undefined&quot;</span><span class="token punctuation">;</span>
 <span class="token comment">// 在web worker或者sevice worker下是无法获取到windows全局变量， 所以需要通过self变量判断</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div></div></section> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">上次更新: </span> <span class="time">2024/3/14 下午7:51:23</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev"><a href="/blog/pages/速记区/4.JS篇上.html" class="prev">
          4.JS篇上
        </a></span> <span class="next"><a href="/blog/pages/速记区/6.代码篇.html">
          6.代码篇
        </a></span></p></div> <div class="comments-wrapper"><!----></div></main></div> <!----></div> <ul class="sub-sidebar sub-sidebar-wrapper" style="width:12rem;" data-v-b57cc07c data-v-7dd95ae2><li class="level-2" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#四、原型与继承" class="sidebar-link reco-side-四、原型与继承" data-v-b57cc07c>四、原型与继承</a></li><li class="level-2" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#_4-1-说说面向对象的特性与特点" class="sidebar-link reco-side-_4-1-说说面向对象的特性与特点" data-v-b57cc07c>4.1 说说面向对象的特性与特点</a></li><li class="level-2" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#_4-2-说说你对工厂模式的理解" class="sidebar-link reco-side-_4-2-说说你对工厂模式的理解" data-v-b57cc07c>4.2 说说你对工厂模式的理解</a></li><li class="level-2" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#_4-3-创建对象有哪几种方式" class="sidebar-link reco-side-_4-3-创建对象有哪几种方式" data-v-b57cc07c>4.3 创建对象有哪几种方式？</a></li><li class="level-2" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#_4-4-js-宿主对象和原生对象的区别" class="sidebar-link reco-side-_4-4-js-宿主对象和原生对象的区别" data-v-b57cc07c>4.4 JS 宿主对象和原生对象的区别</a></li><li class="level-2" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#_4-5-javascript-内置的常用对象有哪些-并列举该对象常用的方法" class="sidebar-link reco-side-_4-5-javascript-内置的常用对象有哪些-并列举该对象常用的方法" data-v-b57cc07c>4.5 JavaScript 内置的常用对象有哪些？并列举该对象常用的方法？</a></li><li class="level-2" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#_4-6-说一下-hasownproperty、instanceof-方法" class="sidebar-link reco-side-_4-6-说一下-hasownproperty、instanceof-方法" data-v-b57cc07c>4.6 说一下 hasOwnProperty、instanceof 方法</a></li><li class="level-2" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#_4-7-什么是原型对象-说说对它的理解" class="sidebar-link reco-side-_4-7-什么是原型对象-说说对它的理解" data-v-b57cc07c>4.7 什么是原型对象，说说对它的理解</a></li><li class="level-2" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#_4-8-什么是原型链" class="sidebar-link reco-side-_4-8-什么是原型链" data-v-b57cc07c>4.8 什么是原型链</a></li><li class="level-2" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#_4-9-原型链的终点是什么" class="sidebar-link reco-side-_4-9-原型链的终点是什么" data-v-b57cc07c>4.9 原型链的终点是什么？</a></li><li class="level-2" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#_4-10-基于-js-原型链-实现继承" class="sidebar-link reco-side-_4-10-基于-js-原型链-实现继承" data-v-b57cc07c>4.10 基于 JS 原型链 实现继承</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#_1-原型链继承" class="sidebar-link reco-side-_1-原型链继承" data-v-b57cc07c>1.原型链继承</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#_2-借用构造函数继承" class="sidebar-link reco-side-_2-借用构造函数继承" data-v-b57cc07c>2.借用构造函数继承</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#_3-组合继承" class="sidebar-link reco-side-_3-组合继承" data-v-b57cc07c>3.组合继承</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#_4-原型式继承" class="sidebar-link reco-side-_4-原型式继承" data-v-b57cc07c>4.原型式继承</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#_5-寄生式继承" class="sidebar-link reco-side-_5-寄生式继承" data-v-b57cc07c>5.寄生式继承</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#_6-寄生组合继承" class="sidebar-link reco-side-_6-寄生组合继承" data-v-b57cc07c>6.寄生组合继承</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#_7-混入继承" class="sidebar-link reco-side-_7-混入继承" data-v-b57cc07c>7.混入继承</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#_8-class-继承" class="sidebar-link reco-side-_8-class-继承" data-v-b57cc07c>8. class 继承</a></li><li class="level-2" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#五、异步与事件循环" class="sidebar-link reco-side-五、异步与事件循环" data-v-b57cc07c>五、异步与事件循环</a></li><li class="level-2" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#_5-1-异步编程的实现方式" class="sidebar-link reco-side-_5-1-异步编程的实现方式" data-v-b57cc07c>5.1. 异步编程的实现方式?</a></li><li class="level-2" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#_5-2-并发与并行的区别" class="sidebar-link reco-side-_5-2-并发与并行的区别" data-v-b57cc07c>5.2 并发与并行的区别？</a></li><li class="level-2" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#_5-3-settimeout、setinterval、requestanimationframe-的区别" class="sidebar-link reco-side-_5-3-settimeout、setinterval、requestanimationframe-的区别" data-v-b57cc07c>5.3 setTimeout、setInterval、requestAnimationFrame 的区别</a></li><li class="level-2" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#_5-4-什么是回调地狱-回调地狱会带来什么问题" class="sidebar-link reco-side-_5-4-什么是回调地狱-回调地狱会带来什么问题" data-v-b57cc07c>5.4. 什么是回调地狱？回调地狱会带来什么问题？</a></li><li class="level-2" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#promise-语法" class="sidebar-link reco-side-promise-语法" data-v-b57cc07c>Promise 语法</a></li><li class="level-2" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#_5-5-promise-是什么" class="sidebar-link reco-side-_5-5-promise-是什么" data-v-b57cc07c>5.5. Promise 是什么</a></li><li class="level-2" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#_5-6-promise-实例有哪些状态-怎么改变状态" class="sidebar-link reco-side-_5-6-promise-实例有哪些状态-怎么改变状态" data-v-b57cc07c>5.6 promise 实例有哪些状态，怎么改变状态</a></li><li class="level-2" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#_5-7-创建-promise-实例有哪些方法" class="sidebar-link reco-side-_5-7-创建-promise-实例有哪些方法" data-v-b57cc07c>5.7 创建 Promise 实例有哪些方法</a></li><li class="level-2" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#_5-8-promise-有哪些实例方法" class="sidebar-link reco-side-_5-8-promise-有哪些实例方法" data-v-b57cc07c>5.8 Promise 有哪些实例方法</a></li><li class="level-2" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#_5-9-promise-有哪些静态方法" class="sidebar-link reco-side-_5-9-promise-有哪些静态方法" data-v-b57cc07c>5.9 Promise 有哪些静态方法</a></li><li class="level-2" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#_5-10-promise-all、promise-race、promise-any-的区别" class="sidebar-link reco-side-_5-10-promise-all、promise-race、promise-any-的区别" data-v-b57cc07c>5.10 Promise.all、Promise.race、Promise.any 的区别</a></li><li class="level-2" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#_5-11-一个-promise-指定多个回调函数-都会调用吗" class="sidebar-link reco-side-_5-11-一个-promise-指定多个回调函数-都会调用吗" data-v-b57cc07c>5.11 一个 promise 指定多个回调函数, 都会调用吗?</a></li><li class="level-2" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#_5-12-改变-promise-状态和指定回调函数谁先谁后" class="sidebar-link reco-side-_5-12-改变-promise-状态和指定回调函数谁先谁后" data-v-b57cc07c>5.12 改变 promise 状态和指定回调函数谁先谁后?</a></li><li class="level-2" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#_5-13-promise-then-返回的新-promise-的结果状态由什么决定" class="sidebar-link reco-side-_5-13-promise-then-返回的新-promise-的结果状态由什么决定" data-v-b57cc07c>5.13 promise.then()返回的新 promise 的结果状态由什么决定?</a></li><li class="level-2" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#_5-14-promise-如何串连多个操作任务" class="sidebar-link reco-side-_5-14-promise-如何串连多个操作任务" data-v-b57cc07c>5.14 promise 如何串连多个操作任务?</a></li><li class="level-2" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#_5-15-promise-异常传透是什么" class="sidebar-link reco-side-_5-15-promise-异常传透是什么" data-v-b57cc07c>5.15 promise 异常传透是什么?</a></li><li class="level-2" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#_5-16-如何中断-promise-链" class="sidebar-link reco-side-_5-16-如何中断-promise-链" data-v-b57cc07c>5.16 如何中断 promise 链?</a></li><li class="level-2" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#_5-17-promise-有什么缺点" class="sidebar-link reco-side-_5-17-promise-有什么缺点" data-v-b57cc07c>5.17 promise 有什么缺点</a></li><li class="level-2" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#async-await-语法" class="sidebar-link reco-side-async-await-语法" data-v-b57cc07c>async/await 语法</a></li><li class="level-2" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#_5-18-async-函数是什么" class="sidebar-link reco-side-_5-18-async-函数是什么" data-v-b57cc07c>5.18 async 函数是什么</a></li><li class="level-2" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#_5-19-async-函数的实现原理" class="sidebar-link reco-side-_5-19-async-函数的实现原理" data-v-b57cc07c>5.19 async 函数的实现原理</a></li><li class="level-2" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#_5-20-async-函数的返回值" class="sidebar-link reco-side-_5-20-async-函数的返回值" data-v-b57cc07c>5.20 async 函数的返回值</a></li><li class="level-2" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#_5-21-await-到底在等待什么" class="sidebar-link reco-side-_5-21-await-到底在等待什么" data-v-b57cc07c>5.21 await 到底在等待什么?</a></li><li class="level-2" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#_5-22-什么是顶层-await" class="sidebar-link reco-side-_5-22-什么是顶层-await" data-v-b57cc07c>5.22 什么是顶层 await？</a></li><li class="level-2" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#_5-23-如何用-await-让程序停顿指定的时间-休眠效果" class="sidebar-link reco-side-_5-23-如何用-await-让程序停顿指定的时间-休眠效果" data-v-b57cc07c>5.23 如何用 await 让程序停顿指定的时间(休眠效果)</a></li><li class="level-2" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#_5-24-await-的使用注意点" class="sidebar-link reco-side-_5-24-await-的使用注意点" data-v-b57cc07c>5.24 await 的使用注意点</a></li><li class="level-2" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#_5-25-async-语法怎么捕获异常" class="sidebar-link reco-side-_5-25-async-语法怎么捕获异常" data-v-b57cc07c>5.25 async 语法怎么捕获异常</a></li><li class="level-2" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#_5-26-async-await-对比-promise-的优势" class="sidebar-link reco-side-_5-26-async-await-对比-promise-的优势" data-v-b57cc07c>5.26 async/await 对比 Promise 的优势</a></li><li class="level-2" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#事件循环-event-loop" class="sidebar-link reco-side-事件循环-event-loop" data-v-b57cc07c>事件循环 Event Loop</a></li><li class="level-2" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#_5-27-js-的执行机制-同步任务、异步任务" class="sidebar-link reco-side-_5-27-js-的执行机制-同步任务、异步任务" data-v-b57cc07c>5.27 JS 的执行机制(同步任务、异步任务)</a></li><li class="level-2" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#_5-28-什么是-event-loop" class="sidebar-link reco-side-_5-28-什么是-event-loop" data-v-b57cc07c>5.28 什么是 Event Loop</a></li><li class="level-2" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#_5-29-宏任务与微任务的概念与区别" class="sidebar-link reco-side-_5-29-宏任务与微任务的概念与区别" data-v-b57cc07c>5.29 宏任务与微任务的概念与区别</a></li><li class="level-2" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#_5-30-常见的宏任务与微任务分别有哪些" class="sidebar-link reco-side-_5-30-常见的宏任务与微任务分别有哪些" data-v-b57cc07c>5.30 常见的宏任务与微任务分别有哪些</a></li><li class="level-2" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#_5-31-事件循环-event-loop-执行机制" class="sidebar-link reco-side-_5-31-事件循环-event-loop-执行机制" data-v-b57cc07c>5.31 事件循环 Event Loop 执行机制</a></li><li class="level-2" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#_5-32-为什么-js-是单线程" class="sidebar-link reco-side-_5-32-为什么-js-是单线程" data-v-b57cc07c>5.32 为什么 Js 是单线程？</a></li><li class="level-2" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#_5-33-代码题易考点" class="sidebar-link reco-side-_5-33-代码题易考点" data-v-b57cc07c>5.33 代码题易考点</a></li><li class="level-2" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#六、-es6-es2022-新语法" class="sidebar-link reco-side-六、-es6-es2022-新语法" data-v-b57cc07c>六、 ES6-ES2022 新语法</a></li><li class="level-2" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#_6-1-es6-es2015" class="sidebar-link reco-side-_6-1-es6-es2015" data-v-b57cc07c>6.1 ES6(ES2015)</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#_1-说说-let-和-const" class="sidebar-link reco-side-_1-说说-let-和-const" data-v-b57cc07c>1. 说说 let 和 const</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#_2-let、const、var-的区别" class="sidebar-link reco-side-_2-let、const、var-的区别" data-v-b57cc07c>2. let、const、var 的区别</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#_3-解构赋值" class="sidebar-link reco-side-_3-解构赋值" data-v-b57cc07c>3. 解构赋值</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#_4-字符串的新增方法" class="sidebar-link reco-side-_4-字符串的新增方法" data-v-b57cc07c>4. 字符串的新增方法</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#_5-展开运算符" class="sidebar-link reco-side-_5-展开运算符" data-v-b57cc07c>5. 展开运算符</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#_6-数组新增的方法" class="sidebar-link reco-side-_6-数组新增的方法" data-v-b57cc07c>6. 数组新增的方法</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#_7-对象新增方法" class="sidebar-link reco-side-_7-对象新增方法" data-v-b57cc07c>7. 对象新增方法</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#_8-class-类" class="sidebar-link reco-side-_8-class-类" data-v-b57cc07c>8.class 类</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#_9-模块化" class="sidebar-link reco-side-_9-模块化" data-v-b57cc07c>9. 模块化</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#_10-symbol" class="sidebar-link reco-side-_10-symbol" data-v-b57cc07c>10. Symbol</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#_11-iterator" class="sidebar-link reco-side-_11-iterator" data-v-b57cc07c>11. Iterator</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#_12-for-of-循环" class="sidebar-link reco-side-_12-for-of-循环" data-v-b57cc07c>12. for...of..循环</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#_13-generator" class="sidebar-link reco-side-_13-generator" data-v-b57cc07c>13. Generator</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#_14-proxy-和-reffect" class="sidebar-link reco-side-_14-proxy-和-reffect" data-v-b57cc07c>14. Proxy 和 Reffect</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#_15-set、map、weakset、weakmap" class="sidebar-link reco-side-_15-set、map、weakset、weakmap" data-v-b57cc07c>15. Set、Map、WeakSet、WeakMap</a></li><li class="level-2" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#_6-2-es2016" class="sidebar-link reco-side-_6-2-es2016" data-v-b57cc07c>6.2 ES2016</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#_1-指数运算符" class="sidebar-link reco-side-_1-指数运算符" data-v-b57cc07c>1. 指数运算符</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#_2-array-prototype-includes-方法" class="sidebar-link reco-side-_2-array-prototype-includes-方法" data-v-b57cc07c>2. Array.prototype.includes()方法</a></li><li class="level-2" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#_6-3-es2017" class="sidebar-link reco-side-_6-3-es2017" data-v-b57cc07c>6.3 ES2017</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#_1-对象新增方法" class="sidebar-link reco-side-_1-对象新增方法" data-v-b57cc07c>1. 对象新增方法</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#_2-字符串新增方法" class="sidebar-link reco-side-_2-字符串新增方法" data-v-b57cc07c>2. 字符串新增方法</a></li><li class="level-2" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#_6-4-es2018" class="sidebar-link reco-side-_6-4-es2018" data-v-b57cc07c>6.4 ES2018</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#_1-异步迭代" class="sidebar-link reco-side-_1-异步迭代" data-v-b57cc07c>1. 异步迭代</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#_2-对象扩展运算符" class="sidebar-link reco-side-_2-对象扩展运算符" data-v-b57cc07c>2.对象扩展运算符</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#_3-promise-prototype-finally" class="sidebar-link reco-side-_3-promise-prototype-finally" data-v-b57cc07c>3. Promise.prototype.finally</a></li><li class="level-2" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#_6-5-es2019" class="sidebar-link reco-side-_6-5-es2019" data-v-b57cc07c>6.5 ES2019</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#_1-try-catch-语句中的catch允许不使用参数" class="sidebar-link reco-side-_1-try-catch-语句中的catch允许不使用参数" data-v-b57cc07c>1. try...catch：语句中的catch允许不使用参数</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#_2-trimstart、trimleft、trimend、trimright" class="sidebar-link reco-side-_2-trimstart、trimleft、trimend、trimright" data-v-b57cc07c>2. trimStart、trimLeft、trimEnd、trimRight</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#_3-object-fromentries" class="sidebar-link reco-side-_3-object-fromentries" data-v-b57cc07c>3. Object.fromEntries</a></li><li class="level-2" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#_6-6-es2020" class="sidebar-link reco-side-_6-6-es2020" data-v-b57cc07c>6.6 ES2020</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#_1-动态导入" class="sidebar-link reco-side-_1-动态导入" data-v-b57cc07c>1. 动态导入</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#_2-bigint-数据类型" class="sidebar-link reco-side-_2-bigint-数据类型" data-v-b57cc07c>2. BigInt 数据类型</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#_3-空值合并运算符" class="sidebar-link reco-side-_3-空值合并运算符" data-v-b57cc07c>3. 空值合并运算符 ??</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#_4-可选链操作符" class="sidebar-link reco-side-_4-可选链操作符" data-v-b57cc07c>4. 可选链操作符 ?.</a></li><li class="level-2" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#_6-7-es2021" class="sidebar-link reco-side-_6-7-es2021" data-v-b57cc07c>6.7 ES2021</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#_1-string-prototype-replaceall" class="sidebar-link reco-side-_1-string-prototype-replaceall" data-v-b57cc07c>1. String.prototype.replaceAll</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#_2-数值分隔符" class="sidebar-link reco-side-_2-数值分隔符" data-v-b57cc07c>2. 数值分隔符 _</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#_3-promise-any" class="sidebar-link reco-side-_3-promise-any" data-v-b57cc07c>3. Promise.any()</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#_4-逻辑赋值操作符-、-、" class="sidebar-link reco-side-_4-逻辑赋值操作符-、-、" data-v-b57cc07c>4. 逻辑赋值操作符 &amp;&amp;= 、||= 、？？=</a></li><li class="level-2" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#_6-8-es2022" class="sidebar-link reco-side-_6-8-es2022" data-v-b57cc07c>6.8 ES2022</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#_1-class-的扩展" class="sidebar-link reco-side-_1-class-的扩展" data-v-b57cc07c>1. class 的扩展</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#_2-await-在顶层使用" class="sidebar-link reco-side-_2-await-在顶层使用" data-v-b57cc07c>2. await 在顶层使用</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#_3-object-hasown" class="sidebar-link reco-side-_3-object-hasown" data-v-b57cc07c>3. Object.hasOwn()</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#_4-array-prototype-at" class="sidebar-link reco-side-_4-array-prototype-at" data-v-b57cc07c>4. Array.prototype.at()</a></li><li class="level-2" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#七、-dom" class="sidebar-link reco-side-七、-dom" data-v-b57cc07c>七、 DOM</a></li><li class="level-2" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#_7-1-说一下-dom-事件流" class="sidebar-link reco-side-_7-1-说一下-dom-事件流" data-v-b57cc07c>7.1 说一下 DOM 事件流</a></li><li class="level-2" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#_7-2-什么是事件冒泡-event-bubbling" class="sidebar-link reco-side-_7-2-什么是事件冒泡-event-bubbling" data-v-b57cc07c>7.2 什么是事件冒泡（Event Bubbling）</a></li><li class="level-2" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#_7-3-什么是事件捕获-event-capturing" class="sidebar-link reco-side-_7-3-什么是事件捕获-event-capturing" data-v-b57cc07c>7.3 什么是事件捕获（Event Capturing）</a></li><li class="level-2" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#_7-4-什么是事件委托" class="sidebar-link reco-side-_7-4-什么是事件委托" data-v-b57cc07c>7.4 什么是事件委托</a></li><li class="level-2" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#_7-5-什么是-dom" class="sidebar-link reco-side-_7-5-什么是-dom" data-v-b57cc07c>7.5 什么是 DOM</a></li><li class="level-2" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#_7-6-dom-的常用操作" class="sidebar-link reco-side-_7-6-dom-的常用操作" data-v-b57cc07c>7.6 DOM 的常用操作</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#_1-创建节点" class="sidebar-link reco-side-_1-创建节点" data-v-b57cc07c>(1)创建节点</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#_2-获取节点" class="sidebar-link reco-side-_2-获取节点" data-v-b57cc07c>(2)获取节点</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#_3-更新节点" class="sidebar-link reco-side-_3-更新节点" data-v-b57cc07c>(3)更新节点</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#_4-添加节点" class="sidebar-link reco-side-_4-添加节点" data-v-b57cc07c>(4)添加节点</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#_5-删除节点" class="sidebar-link reco-side-_5-删除节点" data-v-b57cc07c>(5)删除节点</a></li><li class="level-2" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#_7-7-什么是-dom-树" class="sidebar-link reco-side-_7-7-什么是-dom-树" data-v-b57cc07c>7.7 什么是 DOM 树</a></li><li class="level-2" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#_7-8-什么是-dom-对象-什么是-document-对象" class="sidebar-link reco-side-_7-8-什么是-dom-对象-什么是-document-对象" data-v-b57cc07c>7.8 什么是 DOM 对象，什么是 document 对象</a></li><li class="level-2" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#_7-9-l0-和-l2-注册事件的区别" class="sidebar-link reco-side-_7-9-l0-和-l2-注册事件的区别" data-v-b57cc07c>7.9 L0 和 L2 注册事件的区别</a></li><li class="level-2" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#_7-10-怎么解绑事件" class="sidebar-link reco-side-_7-10-怎么解绑事件" data-v-b57cc07c>7.10 怎么解绑事件</a></li><li class="level-2" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#_7-11-addeventlistener-的第三个参数有什么用" class="sidebar-link reco-side-_7-11-addeventlistener-的第三个参数有什么用" data-v-b57cc07c>7.11 addEventListener 的第三个参数有什么用</a></li><li class="level-2" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#_7-12-常用-dom-事件" class="sidebar-link reco-side-_7-12-常用-dom-事件" data-v-b57cc07c>7.12 常用 DOM 事件</a></li><li class="level-2" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#_7-13-怎么阻止事件冒泡、阻止默认事件" class="sidebar-link reco-side-_7-13-怎么阻止事件冒泡、阻止默认事件" data-v-b57cc07c>7.13 怎么阻止事件冒泡、阻止默认事件？</a></li><li class="level-2" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#_7-14-dom-的类型有哪几种" class="sidebar-link reco-side-_7-14-dom-的类型有哪几种" data-v-b57cc07c>7.14 DOM 的类型有哪几种？</a></li><li class="level-2" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#_7-15-dom-种获取坐标的属性有哪些-它们有什么不同" class="sidebar-link reco-side-_7-15-dom-种获取坐标的属性有哪些-它们有什么不同" data-v-b57cc07c>7.15 DOM 种获取坐标的属性有哪些，它们有什么不同？</a></li><li class="level-2" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#_7-16-dom-种元素视图尺寸的属性有哪些" class="sidebar-link reco-side-_7-16-dom-种元素视图尺寸的属性有哪些" data-v-b57cc07c>7.16 DOM 种元素视图尺寸的属性有哪些？</a></li><li class="level-2" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#_7-17-如何判断元素是否在可视区域" class="sidebar-link reco-side-_7-17-如何判断元素是否在可视区域" data-v-b57cc07c>7.17 如何判断元素是否在可视区域</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#getboundingclientrect" class="sidebar-link reco-side-getboundingclientrect" data-v-b57cc07c>getBoundingClientRect</a></li><li class="level-2" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#_7-18-intersectionobserver" class="sidebar-link reco-side-_7-18-intersectionobserver" data-v-b57cc07c>7.18 IntersectionObserver</a></li><li class="level-2" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#_7-19-如何遍历输出页面中的所有元素" class="sidebar-link reco-side-_7-19-如何遍历输出页面中的所有元素" data-v-b57cc07c>7.19 如何遍历输出页面中的所有元素</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#createnodeiterator" class="sidebar-link reco-side-createnodeiterator" data-v-b57cc07c>createNodeIterator</a></li><li class="level-2" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#_7-20-什么是-bom-对象" class="sidebar-link reco-side-_7-20-什么是-bom-对象" data-v-b57cc07c>7.20 什么是 BOM 对象</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#_1-location-对象的常用方法" class="sidebar-link reco-side-_1-location-对象的常用方法" data-v-b57cc07c>(1) location 对象的常用方法</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#_2-navigator-对象-获取浏览器平台和版本数据" class="sidebar-link reco-side-_2-navigator-对象-获取浏览器平台和版本数据" data-v-b57cc07c>(2) navigator 对象 (获取浏览器平台和版本数据)</a></li><li class="level-3" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#_3-histroy-对象-管理浏览器历史记录" class="sidebar-link reco-side-_3-histroy-对象-管理浏览器历史记录" data-v-b57cc07c>(3) histroy 对象 （管理浏览器历史记录）</a></li><li class="level-2" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#八、其他类型问题补充" class="sidebar-link reco-side-八、其他类型问题补充" data-v-b57cc07c>八、其他类型问题补充</a></li><li class="level-2" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#_8-1-简单说说你对观察者模式的理解" class="sidebar-link reco-side-_8-1-简单说说你对观察者模式的理解" data-v-b57cc07c>8.1 简单说说你对观察者模式的理解</a></li><li class="level-2" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#_8-2-简单说说你对发布订阅模式的理解" class="sidebar-link reco-side-_8-2-简单说说你对发布订阅模式的理解" data-v-b57cc07c>8.2 简单说说你对发布订阅模式的理解</a></li><li class="level-2" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#_8-3-观察者模式与发布订阅的区别" class="sidebar-link reco-side-_8-3-观察者模式与发布订阅的区别" data-v-b57cc07c>8.3 观察者模式与发布订阅的区别</a></li><li class="level-2" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#_8-4-说说你对正则表达式的理解" class="sidebar-link reco-side-_8-4-说说你对正则表达式的理解" data-v-b57cc07c>8.4 说说你对正则表达式的理解</a></li><li class="level-2" data-v-b57cc07c><a href="/blog/pages/%E9%80%9F%E8%AE%B0%E5%8C%BA/5.JS%E7%AF%87%E4%B8%8B.html#_8-5-如何判断当前的-js-代码是否在浏览器环境中运行" class="sidebar-link reco-side-_8-5-如何判断当前的-js-代码是否在浏览器环境中运行" data-v-b57cc07c>8.5 如何判断当前的 Js 代码是否在浏览器环境中运行</a></li></ul></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-c6073ba8 data-v-c6073ba8><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-c6073ba8><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-c6073ba8></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-c6073ba8></path></svg></div></div></div>
    <script src="/blog/assets/js/app.1bd983b1.js" defer></script><script src="/blog/assets/js/4.84f2b8c1.js" defer></script><script src="/blog/assets/js/1.2f8de4ad.js" defer></script><script src="/blog/assets/js/83.6d1bebc4.js" defer></script>
  </body>
</html>
